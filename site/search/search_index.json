{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ASTRA! \ud83d\ude80","text":"<p>ASTRA (Automatic Swing-by TRAjectories) is a MATLAB-based toolbox for optimally building multi-gravity assist (MGA) trajectories. This has been built as a result of Andrea Bellome's Ph.D. thesis [1]. ASTRA is based on Dynamic Programming (DP) to optimize MGA trajectories, both in single-objective (SODP) and multi-objective (MODP) variant.</p> <p>To cite this folder please use the references [1] and [2].</p>"},{"location":"#overview","title":"Overview","text":"<ul> <li>\ud83c\udf0d Developed for space trajectory optimization and mission design</li> <li>\ud83d\udd2c Written in MATLAB with modular architecture</li> <li>\ud83e\uddea Includes automated tests and examples</li> </ul> <p>Use the sidebar to navigate the documentation.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Currently, only invited developers can contribute to the repository.</p> <p>For the moment, the only contributor is... Andrea Bellome! Yeee \ud83d\udc32</p>"},{"location":"#license","title":"License","text":"<p>The work is under license CC BY-NC-SA 4.0, that is an Attribution Non-Commercial license.</p>"},{"location":"#references","title":"References","text":"<p>[1]  Bellome, A., \u201cTrajectory design of multi-target missions via graph transcription and dynamic programming,\u201d Ph.D. thesis, Cranfield University, 2023. https://dspace.lib.cranfield.ac.uk/items/711f45c8-e6e4-4f27-909d-94170df400e3</p> <p>[2]  Bellome, A., et al. \"Multiobjective design of gravity-assist trajectories via graph transcription and dynamic programming.\" Journal of Spacecraft and Rockets 60.5 (2023): 1381-1399. https://doi.org/10.2514/1.A35472</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#requirements","title":"Requirements","text":"<p>To run a full exploration of MGA trajectories, the following system requirements are recommended:</p> <ul> <li>CPU six-core from 2.6 GHz to 3.6 GHz.</li> <li>RAM minimum 16 GB.</li> <li>Any version of MATLAB \u22652021b.</li> <li>A compiler for C functions should be used. You can use the minGW.</li> <li>(optional) MATLAB Parallel Computing Toolbox. This is needed to run ASTRA in parallel mode, and to use the low-thrust module.</li> <li>(optional) MATLAB Optimization Toolbox. This is needed to refine trajectories with Deep Space Manoeuvres (DSMs), if needed by the user.</li> </ul> <p>These are suggested requirements for ASTRA to work to its full potential. Lighter requirements might work well, as ASTRA is able to optimize one launch year at a time, and even one date at a time. The price is the computational time. </p> <p>ASTRA should be agnostic with respect to the operating system. However, some bugs might arise if Windows is not used.</p>"},{"location":"install/#installation-steps","title":"Installation Steps","text":""},{"location":"install/#astra","title":"ASTRA","text":"<p>To work with ASTRA (without any external toolkits), one can simply clone the repository in the local machine:</p> <pre><code>git clone \"https://github.com/andreabellome/astra\"\n</code></pre> <p>And start using the tutorials.</p> <p>In particular, the project structure should be something like the following:</p> <pre><code>local-folder/\n\u251c\u2500\u2500 ASTRA/\n\u251c\u2500\u2500 clearDeleteAdd.m\n\u2514\u2500\u2500 main_script.m\n</code></pre> <p>where the script <code>clearDeleteAdd.m</code> is used to add all the ASTRA functionalities to the working local folder, and it is directly available when downloading the repository from GitHub. The <code>main_script.m</code> is a generic script that uses ASTRA (e.g., one of the tutorials).</p>"},{"location":"install/#nasa-mice-toolkit","title":"NASA MICE Toolkit","text":"<p>It is suggested to have also the SPICE toolkit. In particular, the MATLAB interface of SPICE is called MICE, and one can download it from here, for different operating systems. This is very useful to integrate high-precision ephemerides of Solar System objects in ASTRA (planets, moons, asteroids, comets...).</p> <p>Without going too much in detail on MICE, here the steps are reported for a proper integration in ASTRA:</p> <ol> <li>Open the toolkit page and select the operating system.</li> <li>Download the zip file <code>mice.zip</code> for the desired operating system</li> <li>Create a folder called <code>MICE_TOOLBOX</code> in the main path where ASTRA is and extract there the <code>mice.zip</code>.</li> <li>Then create a folder called <code>Kernel</code> within <code>MICE_TOOLBOX/mice</code>.</li> <li> <p>Download the required kernels, and add them to the <code>Kernel</code> folder. We will use the following (link to the NASA repository where to find them):     <ul> <li>de430.bsp -- Solar System planets' ephemerides</li> <li>mar097.bsp -- Mars ephemerides</li> <li>sat375.bsp -- Saturn ephemerides</li> <li>gm_de431.tpc -- gravity constants</li> <li>naif0012.tls -- leapseconds kernel</li> <li>pck00010.tpc -- body orientation kernel</li> </ul></p> </li> <li> <p>Within <code>MICE_TOOLBOX</code> folder, create a makefile called <code>data.mk</code> like the following:</p> </li> </ol> <pre><code>KPL/MK\n\n\n   \\begindata\n\n      PATH_VALUES     = ( './MICE_TOOLBOX/mice/Kernel' )\n\n      PATH_SYMBOLS    = ( 'KERNELS' )\n\n      KERNELS_TO_LOAD = (\n\n                          '$KERNELS/naif0012.tls'\n                          '$KERNELS/de430.bsp'\n                          '$KERNELS/sat375.bsp'\n                          '$KERNELS/mar097.bsp'\n                          '$KERNELS/gm_de431.tpc'\n                          '$KERNELS/pck00010.tpc'\n                        )\n\n   \\begintext\n\nEnd of MK.\n</code></pre> <p>After all the steps, the final structure of the project should be the following:</p> <pre><code>local-folder/\n\u251c\u2500\u2500 ASTRA\n\u251c\u2500\u2500 MICE_TOOLBOX/\n    \u251c\u2500\u2500 mice/\n        \u251c\u2500\u2500 Kernel/\n            \u251c\u2500\u2500 de430.bsp\n            \u251c\u2500\u2500 gm_de431.tpc\n            \u251c\u2500\u2500 mar097.bsp\n            \u251c\u2500\u2500 naif0012.tls\n            \u251c\u2500\u2500 pck00010.tpc\n            \u2514\u2500\u2500 sat375.bsp\n        \u251c\u2500\u2500mice\n\u251c\u2500\u2500 clearDeleteAdd.m\n\u2514\u2500\u2500 main_script.m\n</code></pre> <p>One now has brand new MICE toolkit ready to be integrated with ASTRA. Different tutorials will show how to use it.</p>"},{"location":"low_thrust_trajectories/","title":"Low-thrust trajectories","text":"<p>This tutorial shows how to convert trajectories coming from ASTRA into low-thrust. It has to be said that ASTRA is currently able to convert solutions by solving a time-fixed fuel-optimal optimal control problem on each leg of the MGA trajectory under consideration. Many references are available, but the main ones that inspired us are [1] and [2].</p>"},{"location":"low_thrust_trajectories/#converting-astra-solution-to-low-thrust","title":"Converting ASTRA solution to low-thrust","text":""},{"location":"low_thrust_trajectories/#converting-mga-ndsm-solution-to-low-thrust","title":"Converting MGA-nDSM solution to low-thrust","text":""},{"location":"low_thrust_trajectories/#references","title":"References","text":"<p>[1]  Junkins, John L., and Ehsan Taheri. \"Exploration of alternative state vector choices for low-thrust trajectory optimization.\" Journal of Guidance, Control, and Dynamics 42.1 (2019): 47-64. https://doi.org/10.2514/1.G003686</p> <p>[2]  Wijayatunga, Minduli C., Roberto Armellin, and Laura Pirovano. \"Exploiting scaling constants to facilitate the convergence of indirect trajectory optimization methods.\" Journal of Guidance, Control, and Dynamics 46.5 (2023): 958-969. https://doi.org/10.2514/1.G007091</p>"},{"location":"nasa_ephemerides/","title":"Using NASA ephemerides","text":"<p>This page shows how to integrate NASA high-precision ephemerides in ASTRA. This is particularly useful when using different planetary systems or when trips to comets or asteroids are sought.</p>"},{"location":"nasa_ephemerides/#integrating-nasa-ephemerides-for-solar-system-planets","title":"Integrating NASA ephemerides for Solar System planets","text":"<p>Before considering other bodies, let's consider the Solar System planets. As from the intallation guide, one should have the following structure in the local directory:</p> <pre><code>local-folder/\n\u251c\u2500\u2500 ASTRA\n\u251c\u2500\u2500 MICE_TOOLBOX/\n    \u251c\u2500\u2500 mice/\n        \u251c\u2500\u2500 Kernel/\n            \u251c\u2500\u2500 de430.bsp\n            \u251c\u2500\u2500 gm_de431.tpc\n            \u251c\u2500\u2500 mar097.bsp\n            \u251c\u2500\u2500 naif0012.tls\n            \u251c\u2500\u2500 pck00010.tpc\n            \u2514\u2500\u2500 sat375.bsp\n        \u251c\u2500\u2500mice\n\u251c\u2500\u2500 clearDeleteAdd.m\n\u2514\u2500\u2500 main_script.m\n</code></pre> <p>The <code>main_script.m</code> is the one we want to modify (see, for example the tutorial on trips to Jupiter or this script).</p> <p>After having set-up all the input and the ASTRA environment, one needs to load the NASA ephemerides. This can be done by imposing that:</p> <pre><code>% --&gt; load MICE toolbox\nMICE_path = './MICE_TOOLBOX' ;\naddpath(genpath(MICE_path)); % --&gt; always include this\ncspice_furnsh([MICE_path '/data.mk']);\n</code></pre> <p>In this way, one loads the kernels for planetary ephemerides. This is not sufficient. One needs to tell ASTRA which ephemerides it should use. The default ones are encoded in the script EphSS_cartesian.m. To overwrite those, one can simply set:</p> <pre><code>INPUT.customEphemerides = @EphSS_from_mice;\n</code></pre> <p>In particular, the function EphSS_from_mice.m allows to automatically use the NASA ephemerides.</p> <p>That's it. </p> <p>Then one can launch an optimization for the EVEMEJ similar to the tutorial on trips to Jupiter. Obviously, the two optimizations should provide very similar result:</p> <ul> <li>the one with approximate ephemerides has a minimum cost of: 8.94774 km/s and 6.45038 years</li> <li>the one with NASA ephemerides has a minimum cost of: 8.95409 km/s  and 6.45038 years</li> </ul> <p>which indeed are very close. Thus, if one needs to plan missions to any of the solar system planet, the approximate ephemerides are suggested, as these are quite faster to compute with respect to high-precision ones.</p> <p>BUG DETECTED: currently, high-precision NASA ephemerides prevent ASTRA to be run in parallel mode when resonances are present in the sequence. A work-around to this is shown later, but a rearchitect is needed. This will be solved in the next update...</p>"},{"location":"nasa_ephemerides/#integrating-nasa-ephemerides-for-small-objects","title":"Integrating NASA ephemerides for small objects","text":"<p>A very interesting application for integrating NASA ephemerides into ASTRA is when one needs to plan missions to Solar System objects that are not planets (asteroids and/or comets). This opens a very wide range of possibilities in terms of mission design.</p>"},{"location":"trips_to_jupiter/","title":"Trips to Jupiter","text":"<p>This tutorial allows to run a simple test script with ASTRA for a mission towards Jupiter. Different sequences will be optimized, just to see different options for ASTRA.</p>"},{"location":"trips_to_jupiter/#eath-venus-earth-mars-earth-jupiter","title":"Eath-Venus-Earth-Mars-Earth-Jupiter","text":"<p>First sequence to analyse is the Eath-Venus-Earth-Mars-Earth-Jupiter (EVEMEJ), that has been considered for JUICE mission.</p> <p>This tutorial is based on this script. This allows to optimize the sequence either with SODP (single-objective dynamic programming) or with MODP (multi-objective dynamic programming). A breakdown of the minimum input parameter needed is provided here.</p> <p>From this script, one needs to call ASTRA and building the mex functions (namely Lambert solver, defects function, and low-thrust module):</p> <pre><code>clearDeleteAdd;\n</code></pre> <p>Then one proceeds to select appropriate input parameters.</p> <pre><code>%% --&gt; input section\n\n% --&gt; clear INPUT and define new ones\ntry clear INPUT; catch; end; clc;\n\n% --&gt; sequence to be optimized\nINPUT.idcentral = 1; \nseq = [ 3 2 3 4 3 5 ]; res = [ ];\n\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\nmaxrev                        = 0;                                         % --&gt; max. number of revolutions (round number)\nchosenRevs                    = differentRuns_v2(seq, maxrev);             % --&gt; generate successive runs\n[INPUT.chosenRevs, INPUT.res] = processResonances(chosenRevs, res);        % --&gt; process the resonances options\n[INPUT.chosenRevs]            = maxRevOuterPlanets(seq, INPUT.chosenRevs); % --&gt; only zero revs. on outer planets\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\n\n%%%%%%%%%% set departing options %%%%%%%%%%\nt0 = date2mjd2000([2023 1 1 0 0 0]); % --&gt; initial date range for launch (MJD2000)\ntf = t0 + 1*365.25;                  % --&gt; final date range for launch (MJD2000)\ndt = 2.5;                            % --&gt; step size in launch window (days)\nINPUT.depOpts = [t0 tf dt];\n%%%%%%%%%% set departing options %%%%%%%%%%\n\n%%%%%%%%%% set options %%%%%%%%%%\nINPUT.opt      = 2;          % --&gt; (1) is for SODP, (2) is for MODP, (3) is for DATES, (4) is for YEARS - MODP\nINPUT.vInfOpts = [3 5];      % --&gt; min/max departing infinity velocities (km/s)\nINPUT.dsmOpts  = [1 Inf];    % --&gt; max defect DSM, and total DSMs (km/s)\nINPUT.plot     = [0 0];      % --&gt; plot(1) for Pareto front, plot(2) for best traj. DV\nINPUT.parallel = true;       % --&gt; put true for parallel, false otherwise\nINPUT.tstep    = dt;         % --&gt; step size for Time of flight            \n%%%%%%%%%% set options %%%%%%%%%%\n</code></pre> <p>Things to notice are:</p> <ul> <li><code>INPUT.idcentral</code> allows to select the system. In this example, <code>INPUT.idcentral = 1</code> means that Solar System is selected. Other options are: 5 for Jupiter system, 6 for Saturn system and 7 for Uranus system. See also constants.m for knowing about the IDs of the bodies.</li> <li><code>maxrev</code> is the number of revolutions for Lambert arcs. ASTRA computes all the possible permutations of revolutions per leg (both long and short option) up to the maximum desired by the user.</li> <li><code>maxRevOuterPlanets</code> will prune options with more than one rev. on legs towards outer planets (i.e., from Jupiter on). This to prevent the mission duration to increase a lot.</li> <li><code>res</code> is a list of integers with <code>[ N, M, LEG_ID ]</code>, where <code>N</code> and <code>M</code> are the object and spacecraft revolutions, respectively, and <code>LEG_ID</code> is the number of the leg at which the resonance is. In this case, it is empty as no resonances are included in the transfer. Later, an example will be shown.</li> <li><code>INPUT.opt</code> selects the type of optimization. </li> <li><code>1</code> is for SODP</li> <li><code>2</code> is for MODP</li> <li><code>3</code> is for SODP run each launch date. </li> <li><code>4</code> is for MODP run each launch year. If the user selects a launch window greater or equal than 3 year AND <code>INPUT.opt=2</code>, this option is selected automatically. This allows to reduce the computational burden in terms of RAM.</li> </ul> <p>The options defined above allow for an MGA trajectory search of <code>Earth-Venus-Earth-Mars-Earth-Jupiter</code> mission in year <code>2023</code> using MODP (<code>INPUT.opt=2</code>).</p> <p>ASTRA main engine can then be run using:</p> <pre><code>%% --&gt; optimize using ASTRA\n\n% --&gt; launch ASTRA optimization\nOUTPUT = ASTRA_DP(seq, INPUT);\n</code></pre> <p>Results are saved in a structure called <code>OUTPUT</code>.</p> <p>If needed, one can then post-process the results, extracting the desired trajectory from the Pareto front, plotting the Pareto front itself and the selected path.</p> <pre><code>% --&gt; process the OUTPUT\nprocessed_OUTPUT = postProcessOutputASTRA( OUTPUT );\n\n% --&gt; process the output for better user experience\nparetoFront = process_paretoFront_structure( INPUT, processed_OUTPUT );\n</code></pre> <p>Specfically, the structure <code>paretoFront</code> has all the relevant information about the trajectories on the Pareto front that are easily interpretable. In particular, the default objective functions to be minimized and represented in the plots are:</p> <ul> <li>overall $ \\Delta v$ consumption (that is the departing infinity velocity $ v_{\\infty,dep} $, sum of defects and arrival infinity velocity $ v_{\\infty,arr}$)</li> <li>overall time of flight</li> </ul> <p>Custom objective functions can also be included as shown in another tutorial.</p> <p>Once the pareto front is extracted, one can plot it:</p> <pre><code>% --&gt; plot the Pareto front\nfigPareto = plotPareto(processed_OUTPUT.PARETO_FRONT);\n</code></pre> <p></p> <p>A specific trajectory (variable <code>path</code> in the <code>paretoFront</code> structure) can also be extracted and plotted.</p> <pre><code>row  = length(paretoFront);   % --&gt; select the path to plot (minimum DV in this specific example)\npath = paretoFront(row).path;\nrevs = paretoFront(row).revs;\nres  = paretoFront(row).res;\n\n% --&gt; plot the path\n[figECI, STRUC, figSYN, figRSC, figVSC] = plotPath(path, INPUT.idcentral);\n</code></pre> <p>The plot of the optimal trajectory in inertial and Earth-Sun synodic frame is the following:</p> <p>The function plotPath.m also allows to plot the evolutions of spacecraft distance and velocity with respect to central body:</p> <p>The function generateOutputTXT.m creates a .txt file in a folder called <code>./results</code> that has all the info of the trajectory.</p> <pre><code>% --&gt; save the output\ngenerateOutputTXT(path, INPUT.idcentral, ...\n    @EphSS_cartesian, ...\n    '/target_folder', ...\n    'name_of_the_file');\n</code></pre> <p>This is reported here:</p> <pre><code>\n          _/_/_/     _/_/_/  _/_/_/_/_/  _/_/_/    _/_/_/ \n        _/    _/   _/           _/     _/    _/  _/    _/ \n       _/_/_/_/     _/_/       _/     _/_/_/    _/_/_/_/  \n      _/    _/         _/     _/     _/    _/  _/    _/   \n     _/    _/    _/_/_/      _/     _/    _/  _/    _/    \n\n\n               - ASTRA solution - \n\n-------------------------------------------------------------- \n\nDeparting body                 : Earth  \nDistance from the central body : 1.0000 AU \n\n-------------------------------------------------------------- \n\nArrival body                   : Jupiter\nDistance from the central body : 5.2026 AU \nDeparting C3                   : 9.9710 km^2/s^2 \nDeparting infinity velocity    : 3.1577 km/s \nArrival infinity velocity      : 5.5622 km/s \nTotal cost (DSMs)              : 0.2279 km/s \nTotal cost                     : 8.9477 km/s \nTime of flight                 : 6.4504 years \n\n-------------------------------------------------------------- \n\nMGA Details : \n\nSwing-by sequence      : -E--V--E--M--E--J-\n\nDeparting date         : [2023   5  25   0   0   0]\nArrival date           : [2029  11   5   0   0   0]\nTime of flight per leg : 149 days \n                         314 days \n                         164 days \n                         653 days \n                         1076 days \n\nDSMs magnitudes        : 0 km/s \n                         0 km/s \n                         0.0435 km/s \n                         0.175 km/s \n                         0.0030602 km/s \n                         0.0062967 km/s \n\nInfinity velocities    : \nEarth   - Venus        : 3.1577 - 5.491 km/s \nVenus   - Earth        : 5.5345 - 8.6843 km/s \nEarth   - Mars         : 8.8594 - 9.9807 km/s \nMars    - Earth        : 9.9837 - 11.356 km/s \nEarth   - Jupiter      : 11.3497 - 5.5622 km/s \n\nState at departure/arrival (km and km/s) : \nEarth                         : [-67443219.33399     -135660718.6523                   0        24.241512589      -11.7048292755      1.836903188908]  \nVenus                         : [37311161.50828      101201436.6601     -794434.8182506     -35.16859904353      13.90789291013     -2.571549670311]  \n\nVenus                         : [37311161.50828      101201436.6601     -794434.8182506     -38.11916712221      12.05366801041    0.02734636620768]  \nEarth                         : [139172686.8417     -58704309.11459                   0      2.765219554958      29.78400878435    -0.2102630162746]  \n\nEarth                         : [139172686.8417     -58704309.11459                   0      6.581015760611      34.63293925256       2.19921939779]  \nMars                          : [-149676335.9057      195136449.5053      7760204.399362     -23.46960002881     -4.185823816296    -0.8280693030055]  \n\nMars                          : [-149676335.9057      195136449.5053      7760204.399362     -22.68651649801     -3.708904715841     0.6440840164211]  \nEarth                         : [67683770.4888      131263396.4678                   0     -25.22025731172      24.69727827743      1.176764665526]  \n\nEarth                         : [67683770.4888      131263396.4678                   0     -30.54695793792      24.14446259252       1.85752423869]  \nJupiter                       : [-638295113.4513     -502726641.4791      16376543.69961      4.808110564511     -5.055217205055    -0.3203290652118]  \n\nEncounter dates        : \nEarth                  : [2023   5  25   0   0   0]\nVenus                  : [2023  10  21   0   0   0]\nEarth                  : [2024   8  30   0   0   0]\nMars                   : [2025   2  10   0   0   0]\nEarth                  : [2026  11  25   0   0   0]\nJupiter                : [2029  11   5   0   0   0]\n\nTransfer types         : \nEarth   - Venus        : inbound - outbound \nVenus   - Earth        : inbound - inbound \nEarth   - Mars         : inbound - outbound \nMars    - Earth        : outbound - outbound \nEarth   - Jupiter      : outbound - inbound \n\n-------------------------------------------------------------- \n</code></pre> <p>Finally, one can further refine the solution around a specified trajectory, to further reduce the defects that might arise:</p> <pre><code>%% --&gt; futher refine around the optimal DV-solution\n\nINPUT.t0days  = 10;   % --&gt; days around current solution departing epoch\nINPUT.tofdays = 15;   % --&gt; days around current solution TOFs\nINPUT.dt      = 0.5;  % --&gt; step size (days)\nINPUT.revs    = revs;\nINPUT.res     = res;\n\n% --&gt; further refine using ASTRA\nOUTPUTref           = refineUsingASTRApath(path, INPUT);\nprocessed_OUTPUTref = postProcessOutputASTRA( OUTPUTref );\nparetoFrontref      = process_paretoFront_structure( INPUT, processed_OUTPUTref );\n</code></pre> <p>It is always suggested to run this second step as one might use coarse grids as initial optimization. In this specific example one has that:</p> <ul> <li>minimum cost function before the refinement is: 8.94774 km/s and 6.450376 years</li> <li>mimimum cost functions after the refinement are: 8.85087 km/s and 6.46407 years</li> </ul> <p>so the refinement actually helped at the price of slightly increased transfer time.</p>"},{"location":"trips_to_jupiter/#eath-venus-earth-earth-jupiter","title":"Eath-Venus-Earth-Earth-Jupiter","text":"<p>This second tutorial is very similar to the one above. The main difference is that one uses a resonant transfer in the Earth-Earth leg.</p> <p>The only difference with the script above is:</p> <pre><code>seq = [ 3 2 3 3 5 ];   res = [ 2 1 3 ];\n</code></pre> <p>where <code>res</code> now specifies <code>[2 1 3]</code>, i.e., 2:1 resonance on the 3rd leg. If multiple resonances are needed, one specifies it via: </p> <ul> <li><code>res = [N, M, LEG_ID_1, N, M, LEG_ID_1]</code> and so on...</li> </ul> <p>The same input as before are used. The results are reported below. One notices the resonant leg, on which the trajectory returns back at Earth at the same position of the planet on its orbit after 2 orbital periods (2:1 resonance).</p> <p></p>"},{"location":"trips_to_jupiter/#earth-venus-earth-mars-mars-mars-jupiter","title":"Earth-Venus-Earth-Mars-Mars-Mars-Jupiter","text":"<p>This last script is just to show consecutive resonant legs setup in ASTRA. Specifically, 2:1 and 3:1 resonant ratios are used in successive Mars-Mars legs.</p> <p>Again, the only thing that changes is the following:</p> <pre><code>seq = [ 3 2 3 4 4 4 5 ];   res = [ 2 1 4 3 1 5 ];\n</code></pre> <p></p>"}]}