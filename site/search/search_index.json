{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ASTRA! \ud83d\ude80","text":"<p>ASTRA (Automatic Swing-by TRAjectories) is a MATLAB-based toolbox for optimally building multi-gravity assist (MGA) trajectories. This has been built as a result of Andrea Bellome's Ph.D. thesis [1]. ASTRA is based on Dynamic Programming (DP) to optimize MGA trajectories, both in single-objective (SODP) and multi-objective (MODP) variant.</p> <p>To cite this folder please use the references [1] and [2].</p>"},{"location":"#overview","title":"Overview","text":"<ul> <li>\ud83c\udf0d Developed for space trajectory optimization and mission design</li> <li>\ud83d\udd2c Written in MATLAB with modular architecture</li> <li>\ud83e\uddea Includes automated tests and examples</li> </ul> <p>Use the sidebar to navigate the documentation.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Currently, only invited developers can contribute to the repository.</p> <p>For the moment, the only contributor is... Andrea Bellome! Yeee \ud83d\udc32</p>"},{"location":"#license","title":"License","text":"<p>The work is under license CC BY-NC-SA 4.0, that is an Attribution Non-Commercial license.</p>"},{"location":"#references","title":"References","text":"<p>[1]  Bellome, A., \u201cTrajectory design of multi-target missions via graph transcription and dynamic programming,\u201d Ph.D. thesis, Cranfield University, 2023. https://dspace.lib.cranfield.ac.uk/items/711f45c8-e6e4-4f27-909d-94170df400e3</p> <p>[2]  Bellome, A., et al. \"Multiobjective design of gravity-assist trajectories via graph transcription and dynamic programming.\" Journal of Spacecraft and Rockets 60.5 (2023): 1381-1399. https://doi.org/10.2514/1.A35472</p>"},{"location":"custom_input/","title":"Using custom input parameters","text":"<p>This tutorial shows how to include some custom input parameters to ASTRA optimization. These are the following:</p> <ul> <li>Custom boundaries for time of flight between planets</li> <li>Custom maximum overall mission duration</li> <li>Custom boundaries of infinity velocities $ v_{\\infty} $ at different bodies encounters</li> <li>Custom ephemerides</li> <li>Custom objective functions for both SODP and MODP</li> </ul>"},{"location":"custom_input/#custom-boundaries","title":"Custom boundaries","text":"<p>This section shows how to add custom boundaries to time of flight, overall mission duration, and infinity velocities at objects' encounters.</p> <p>This is very easy to do in ASTRA as one needs to select the following optional input to be appended to the <code>INPUT</code> structure:</p> <pre><code>% --&gt; sequence and resonances\nseq = [ 3 2 3 3 5 ]; res = [ 2 1 3 ];\n\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\nmaxrev                        = 1;                                                          % --&gt; max. number of revolutions (round number)\nchosenRevs                    = differentRuns_v2(seq, maxrev);                              % --&gt; generate successive runs\n[INPUT.chosenRevs, INPUT.res] = processResonances(chosenRevs, res);                         % --&gt; process the resonances options\n[INPUT.chosenRevs]            = maxRevOuterPlanets(seq, INPUT.chosenRevs, INPUT.idcentral); % --&gt; only zero revs. on outer planets\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\n\n%%%%%%%%%% set departing options %%%%%%%%%%\nt0 = date2mjd2000([2023 1 1 12 0 0]); % --&gt; initial date range (MJD2000)\ntf = t0 + 1*365.25;                   % --&gt; final date range (MJD2000)\ndt = 5;                               % --&gt; step size (days)\nINPUT.depOpts = [t0 tf dt];\n%%%%%%%%%% set departing options %%%%%%%%%%\n\n%%%%%%%%%% set options %%%%%%%%%%\nINPUT.opt      = 1;          % --&gt; (1) is for SODP, (2) is for MODP, (3) is for DATES - SODP, (4) is for YEARS - MODP\nINPUT.vInfOpts = [0 4];      % --&gt; min/max departing infinity velocities (km/s)\nINPUT.dsmOpts  = [1 Inf];    % --&gt; max defect DSM, and total DSMs (km/s)\nINPUT.plot     = [1 1];      % --&gt; plot(1) for Pareto front, plot(2) for best traj. DV\nINPUT.parallel = true;       % --&gt; put true for parallel, false otherwise\nINPUT.tstep    = 3;          % --&gt; step size for Time of flight            \n%%%%%%%%%% set options %%%%%%%%%%\n\n%%%%%%%%%% custom boundaries %%%%%%%%%%\nINPUT.TOF_LIM = [ 100 500; 100 500; 100 500; 500 2000 ]; % --&gt; min./max TOF [days] for each leg\nINPUT.vInfLim = [ 0 5; 0 9; 0 11; 0 11; 0 7 ];           % --&gt; min./max infinity velocity [km/s] for each planet \nINPUT.tofyMax = 7;                                       % --&gt; max. overall mission duration [years]\n%%%%%%%%%% custom boundaries %%%%%%%%%%\n</code></pre> <p>Specifically:</p> <ul> <li> <p>The field <code>INPUT.TOF_LIM</code> specifies the minimum and maximum time of flight for each leg -- a leg is a planet-to-planet transfer. Thus, in the example, one has 5 planets (EVEEJ) and 4 legs (EV, VE, EE, EJ). One notices that a resonance is specified on the 3rd leg. Therefore, setting up the time-of-flight bounds on that leg it has no effect (the resonance dictates the time).</p> </li> <li> <p>Similarly, the field <code>INPUT.vInfLim</code> specifies minimum and maximum infinity velocities at planetary encounters. One should specify one for each planet. If the target object is a comet/asteroid, then the bounds on infinity velocity actually correspond to the bounds for a $ \\Delta v $ to rendezvous with the object. One should notice that infinity velocity bounds at the first planet are not effective as one should always specify:</p> <p><code>matlab INPUT.vInfOpts = [0 5];      % --&gt; min/max departing infinity velocities (km/s)</code></p> <p>Obviously, if the first object of the sequence is an asteroid/comet, this is equivalent to a $ \\Delta v $ to depart from it.</p> </li> <li> <p>Finally, the field <code>INPUT.tofyMax</code> allows to set-up the maximum transfer time in years of the whole trip.</p> </li> </ul>"},{"location":"custom_input/#custom-ephemerides","title":"Custom ephemerides","text":"<p>Customising ephemerides function requires a bit of coding.</p> <p>Essentially, ASTRA works with approximate planetary positions encoded in the script EphSS_cartesian.m. These are proven to be sufficiently close to NASA high-precsion ones (e.g., de430.bsp), as shown in this tutorial.</p> <p>If one wants to specify a custom function (say <code>Eph_custom</code>), the template should be:</p> <pre><code>function [ rr, vv ] = Eph_custom( pl, t, idcentral )\n\n% --&gt; here the logic...\n\nend\n</code></pre> <p>Where in input is required:</p> <ul> <li><code>pl</code> is the ID of the body</li> <li><code>t</code> is the epoch at which the ephemerides are computed in MJD2000</li> <li><code>idcentral</code> should specify the central body (e.g., <code>idcentral=1</code> if the Sun is the central body)</li> </ul> <p>The output are:</p> <ul> <li><code>rr</code>: a <code>3x1</code> vector with object position in consistent reference frame, expressed in km</li> <li><code>vv</code>: a <code>3x1</code> vector with object velocity in consistent reference frame, expressed in km/s</li> </ul> <p>It is important to notice that custom objects in the Solar System must have IDs that are greater than 9 (<code>pl = 9</code> corresponds to Pluto). This is because when computing fly-bys, ASTRA reads the function constants.m to retrieve the fly-by parameters. For asteroids and comets (i.e., for objects with <code>pl &gt; 9</code>), zero gravity is assumed and thus zero sphere of influence.</p> <p>Thus, a template for including a custom objects (if one does not want to use NASA ephemerides as shown here) can be:</p> <pre><code>function [ rr, vv ] = Eph_custom( pl, t, idcentral )\n\nif idcentral == 1 &amp;&amp; pl &lt;= 9 % --&gt; Sun as main body and max. ID for planets is 9 (Pluto)\n\n    [ rr, vv ] = EpSS_cartesian( pl, t, idcentral );\n\nelse\n    % --&gt; here the logic for the custom object...\n\nend\n\nend\n</code></pre> <p>Finally, in the main script one simply sets the following before launching the optimization:</p> <pre><code>INPUT.customEphemerides = @Eph_custom; % --&gt; specify the custom ephemerides function\n</code></pre> <p>In this way, ASTRA uses the custom ephemerides function defined by the user. </p>"},{"location":"custom_input/#custom-objective-functions","title":"Custom objective functions","text":"<p>Customising objective functions requires a bit of coding. </p> <p>By default, ASTRA will optimise the following objective functions:</p> <ul> <li>overall $ \\Delta v $ as the sum of departing infinity velocity $ v_{\\infty,dep} $, defects along the transfer, and arrival infinity velocity $ v_{\\infty,arr} $</li> <li>overall transfer time</li> </ul> <p>However, one might want to define custom objectives.</p> <p>(coming soon...)</p>"},{"location":"deep_space_man/","title":"Trajectories with Deep-Space Manoeuvres","text":"<p>(coming soon...)</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#requirements","title":"Requirements","text":"<p>To run a full exploration of MGA trajectories, the following system requirements are recommended:</p> <ul> <li>CPU six-core from 2.6 GHz to 3.6 GHz.</li> <li>RAM minimum 16 GB.</li> <li>Any version of MATLAB \u22652021b.</li> <li>A compiler for C functions should be used. You can use the minGW.</li> <li>(optional) MATLAB Parallel Computing Toolbox. This is needed to run ASTRA in parallel mode, and to use the low-thrust module.</li> <li>(optional) MATLAB Optimization Toolbox. This is needed to refine trajectories with Deep Space Manoeuvres (DSMs), if needed by the user.</li> </ul> <p>These are suggested requirements for ASTRA to work to its full potential. Lighter requirements might work well, as ASTRA is able to optimize one launch year at a time, and even one date at a time. The price is the computational time. </p> <p>ASTRA should be agnostic with respect to the operating system. However, some bugs might arise if Windows is not used.</p>"},{"location":"install/#installation-steps","title":"Installation Steps","text":""},{"location":"install/#astra","title":"ASTRA","text":"<p>To work with ASTRA (without any external toolkits), one can simply clone the repository in the local machine:</p> <pre><code>git clone \"https://github.com/andreabellome/astra\"\n</code></pre> <p>And start using the tutorials.</p> <p>In particular, the project structure should be something like the following:</p> <pre><code>local-folder/\n\u251c\u2500\u2500 ASTRA/\n\u251c\u2500\u2500 clearDeleteAdd.m\n\u2514\u2500\u2500 main_script.m\n</code></pre> <p>where the script <code>clearDeleteAdd.m</code> is used to add all the ASTRA functionalities to the working local folder, and it is directly available when downloading the repository from GitHub. The <code>main_script.m</code> is a generic script that uses ASTRA (e.g., one of the tutorials).</p>"},{"location":"install/#nasa-mice-toolkit","title":"NASA MICE Toolkit","text":"<p>It is suggested to have also the SPICE toolkit. In particular, the MATLAB interface of SPICE is called MICE, and one can download it from here, for different operating systems. This is very useful to integrate high-precision ephemerides of Solar System objects in ASTRA (planets, moons, asteroids, comets...).</p> <p>Without going too much in detail on MICE, here the steps are reported for a proper integration in ASTRA:</p> <ol> <li>Open the toolkit page and select the operating system.</li> <li>Download the zip file <code>mice.zip</code> for the desired operating system</li> <li>Create a folder called <code>MICE_TOOLBOX</code> in the main path where ASTRA is and extract there the <code>mice.zip</code>.</li> <li>Then create a folder called <code>Kernel</code> within <code>MICE_TOOLBOX/mice</code>.</li> <li> <p>Download the required kernels, and add them to the <code>Kernel</code> folder. We will use the following (link to the NASA repository where to find them):     <ul> <li>de430.bsp -- Solar System planets' ephemerides</li> <li>mar097.bsp -- Mars ephemerides</li> <li>sat375.bsp -- Saturn ephemerides</li> <li>gm_de431.tpc -- gravity constants</li> <li>naif0012.tls -- leapseconds kernel</li> <li>pck00010.tpc -- body orientation kernel</li> </ul></p> </li> <li> <p>Within <code>MICE_TOOLBOX</code> folder, create a makefile called <code>data.mk</code> like the following:</p> </li> </ol> <pre><code>KPL/MK\n\n\n   \\begindata\n\n      PATH_VALUES     = ( './MICE_TOOLBOX/mice/Kernel' )\n\n      PATH_SYMBOLS    = ( 'KERNELS' )\n\n      KERNELS_TO_LOAD = (\n\n                          '$KERNELS/naif0012.tls'\n                          '$KERNELS/de430.bsp'\n                          '$KERNELS/sat375.bsp'\n                          '$KERNELS/mar097.bsp'\n                          '$KERNELS/gm_de431.tpc'\n                          '$KERNELS/pck00010.tpc'\n                        )\n\n   \\begintext\n\nEnd of MK.\n</code></pre> <p>After all the steps, the final structure of the project should be the following:</p> <pre><code>local-folder/\n\u251c\u2500\u2500 ASTRA\n\u251c\u2500\u2500 MICE_TOOLBOX/\n    \u251c\u2500\u2500 mice/\n        \u251c\u2500\u2500 Kernel/\n            \u251c\u2500\u2500 de430.bsp\n            \u251c\u2500\u2500 gm_de431.tpc\n            \u251c\u2500\u2500 mar097.bsp\n            \u251c\u2500\u2500 naif0012.tls\n            \u251c\u2500\u2500 pck00010.tpc\n            \u2514\u2500\u2500 sat375.bsp\n        \u2514\u2500\u2500 mice\n\u251c\u2500\u2500 clearDeleteAdd.m\n\u2514\u2500\u2500 main_script.m\n</code></pre> <p>One now has brand new MICE toolkit ready to be integrated with ASTRA. Different tutorials will show how to use it.</p>"},{"location":"low_thrust_trajectories/","title":"Low-thrust trajectories","text":"<p>This tutorial shows how to convert trajectories coming from ASTRA into low-thrust. It has to be said that ASTRA is currently able to convert solutions by solving a time-fixed fuel-optimal optimal control problem on each leg of the MGA trajectory under consideration. Many references are available, but the main ones that inspired us are [1] and [2]. Other OCPs (e.g., fuel-optimal time-fixed with variable thrust) are currently not available in ASTRA. </p>"},{"location":"low_thrust_trajectories/#converting-astra-solution-to-low-thrust","title":"Converting ASTRA solution to low-thrust","text":"<p>Assume you just launched an ASTRA run as from the tutorial on trajectories to Jupiter. Now, one can extract the Pareto front as from:</p> <pre><code>% --&gt; process the OUTPUT\nprocessed_OUTPUT = postProcessOutputASTRA( OUTPUT );\n\n% --&gt; process the output for better user experience\nparetoFront = process_paretoFront_structure( INPUT, processed_OUTPUT );\n</code></pre> <p>From the structure <code>paretoFront</code> one selects the preferred solutions based on user-defined objectives (e.g., launch date, departing infinity velocity, arrival infinity velocity,...). Say that you want the first solution:</p> <pre><code>path = paretoFront(1).path;  % --&gt; this encodes the trajectory\nrevs = paretoFront(1).revs;  % --&gt; this encodes the revolutions for the Lambert solver\nres  = paretoFront(1).res;   % --&gt; this encodes the resonance (empty if no resonances are present)\n</code></pre> <p>Then, one can build the following structure:</p> <pre><code>% --&gt; extract ASTRA solution\nastraSolution.path      = path;             % --&gt; ASTRA solution\nastraSolution.revs      = revs;             % --&gt; revolutions' options from ASTRA solution\nastraSolution.res       = res;              % --&gt; resonances' options from ASTRA solution\nastraSolution.vdep_free = vdep_free;        % --&gt; v-infinity provided by launcher 'for free' [km/s]\nastraSolution.varr_free = varr_free;        % --&gt; arrival infinity velocity 'for free' [km/s]\n</code></pre> <p>One notices that:</p> <ul> <li> <p><code>vdep_free</code> is the infinity velocity provided by the launcher, and thus the thrusting system shoud not provide it. When departing from a comet/asteroid, this should be put to 0, to simulate the departing burn (i.e., leaving the comet/asteroid orbit).</p> </li> <li> <p><code>varr_free</code> is the maximum infinity velocity admissible at the arrival. When arriving at a comet/asteroid, this should be put to 0, to simulate the rendezvous.</p> </li> </ul> <p>Then one needs to set-up the thrusting system:</p> <pre><code>% --&gt; define low-thrust parameters\nlowThrustParameters.Tmax        = 0.1;      % --&gt; max. thrust                       [N]\nlowThrustParameters.Isp         = 3000;     % --&gt; specific impulse                  [s]\nlowThrustParameters.m0          = 1800;     % --&gt; initial mass                      [kg]    \nlowThrustParameters.g0          = 9.80665;  % --&gt; Earth acceleration at sea level   [m/s]\n</code></pre> <p>And some specific parameters for the solver:</p> <pre><code>% --&gt; further optional parameters for optimal control solution\nlowThrustParameters.gamma       = 0.5;      % --&gt; discount factor for the smoothing parameter (default is 0.5)\nlowThrustParameters.plot        = true;     % --&gt; this plots the thrust evolution over time for different rho (default is false)\nlowThrustParameters.useParallel = true;     % --&gt; if true, uses parallel for fsolve (default is false)\nlowThrustParameters.rhoLim      = 1e-4;     % --&gt; limit on smoothing parameter (default is 1e-5)\n</code></pre> <p>The most critical ones are <code>gamma</code> and <code>rhoLim</code> and their impact is discussed in Ref [1]. Essentially:</p> <ul> <li> <p><code>gamma</code> is the factor that allows progressive transition from smooth to non-smooth optimal control problem. Typical values are in the range <code>0.5</code> to <code>0.9</code>. A higher value might help when short burns are found, at the price of higher computational effort. A small value makes the whole routine faster, but might be too aggressive in some cases. The user should decide on a case-to-case basis (<code>0.75</code> is suggested for most cases).</p> </li> <li> <p><code>rhoLim</code> is the limit on the smoothness of the fuel-optimal problem. A small value corresponds to a more optimal thrust profile, at the price of increased computational effort (some numerical issues might even prevent solutions to appear). A high value correspopnds to less accurate solution to the fuel-optimal problem. A trial-and-error approach identified values between <code>1e-3</code> to <code>1e-5</code> to be sufficiently good ones, as a compromise between computational effort and solutions quality. In other words, for values smaller than those, no significant improvement on the final mass is registered for the interplanetary transfers considered in ASTRA.</p> </li> </ul> <p>Finally, one can launch the solver:</p> <pre><code>% --&gt; find low-thrust transfers from ASTRA solution      \n[LT_SOLUTION, struc] = lowThrustFromASTRASolution( astraSolution, lowThrustParameters, INPUT.idcentral, INPUT.customEphemerides );\n</code></pre> <p>that attempts to solve fuel-optimal time-fixed optimal control problem for each leg of the ASTRA trajectory.</p> <p>It has to be noticed that one requires in input <code>INPUT.customEphemerides</code> that depends upon the user. See this tutorial. </p> <p>One can finally plot the resulting trajectories, mass, and thrust evolutions:</p> <pre><code>% --&gt; plot the final output\nclose all; clc;\n\nplanets = [struc.idD, struc(end).idA];\nt0      = struc(1).tD;\ntend    = struc(end).tA;\n\n[figTRAJ, figMASS, figTHRmag] = wrapPlotLTFull(LT_SOLUTION, LT_SOLUTION(1).LTsol.param);\n\nfigure(figTRAJ);\nplotPLTS_tt(planets, t0, tend, INPUT.idcentral, INPUT.customEphemerides, 1, [], [], 0.5, '--');\n</code></pre> <p>An example is shown for an EMEE-1000508 (where the SPKID 1000508 corresponds to the comet 320P/McNaught). </p> <p>In this case, the following options are used:</p> <pre><code>vdep_free = 4; % --&gt; km/s\nvarr_free = 0; % --&gt; km/s\n</code></pre> <p>Firstly, let's take the ASTRA solution (no refinement with DSM) before and after the low-thrust solver. One notices that the largest burns are in the first leg, to compensate the required infinity velocity at the departure (the needed one is <code>4.41932</code> km/s), and on the last leg, to rendezvous with the asteroid (matching position and velocity).</p> <p>The corresponding evolution of the thrust profile and the mass is shown in the figures below.</p> <p>Final trajectory details:</p> <ul> <li>overall time of flight: 3120.5 days</li> <li>final mass: 1470.218 kg</li> </ul>"},{"location":"low_thrust_trajectories/#converting-mga-ndsm-solution-to-low-thrust","title":"Converting MGA-nDSM solution to low-thrust","text":"<p>Now, let's assume that the same solution obtained before is refined with DSM (e.g., using this tutorial).</p> <p>One needs to post-process the MGA-nDSM solution:</p> <pre><code>[struc] = postProcessPathASTRA_dsm_lowThrust( dv, output, MAT, vdep_free, varr_free, idcentral, customEphemerides )\n</code></pre> <p>Then, simply passing this:</p> <pre><code>astraSolution.struc = struc;\n</code></pre> <p>alongside the other required inputs, will make ASTRA understand that the solution to be converted to low-thrust is the one with DSM (i.e., the one encoded in <code>struc</code>). In other words, ASTRA will only consider <code>astraSolution.struc = struc;</code> to solve the fuel-optimal problem, and not anymore <code>astraSolution.path = path;</code>, even if it is specified by the user.</p> <p>Below the corresponding trajectories before (left) and after (right) low-thrust conversion. One notices that the overall time of fight is increased, especially in the last leg, where a DSM of about 147.9 m/s is needed to lower the $ \\Delta v $ needed to rendezvous (i.e., from 1.9047 km/s of the defects solution, to 1.2112 km/s with DSMs).</p> <p>The corresponding evolution of the thrust profile and the mass is shown in the figures below.</p> <p>Final trajectory details:</p> <ul> <li>overall time of flight: 3248.720 days</li> <li>final mass: 1588.721 kg</li> </ul> <p>which indeed has higher mass compared to the previous case, at the price of increased transfer time.</p>"},{"location":"low_thrust_trajectories/#references","title":"References","text":"<p>[1]  Junkins, John L., and Ehsan Taheri. \"Exploration of alternative state vector choices for low-thrust trajectory optimization.\" Journal of Guidance, Control, and Dynamics 42.1 (2019): 47-64. https://doi.org/10.2514/1.G003686</p> <p>[2]  Wijayatunga, Minduli C., Roberto Armellin, and Laura Pirovano. \"Exploiting scaling constants to facilitate the convergence of indirect trajectory optimization methods.\" Journal of Guidance, Control, and Dynamics 46.5 (2023): 958-969. https://doi.org/10.2514/1.G007091</p>"},{"location":"nasa_ephemerides/","title":"Using NASA ephemerides","text":"<p>This page shows how to integrate NASA high-precision ephemerides in ASTRA. This is particularly useful when using different planetary systems or when trips to comets or asteroids are sought.</p>"},{"location":"nasa_ephemerides/#integrating-nasa-ephemerides-for-solar-system-planets","title":"Integrating NASA ephemerides for Solar System planets","text":"<p>Before considering other bodies, let's consider the Solar System planets. As from the intallation guide, one should have the following structure in the local directory:</p> <pre><code>local-folder/\n\u251c\u2500\u2500 ASTRA\n\u251c\u2500\u2500 MICE_TOOLBOX/\n    \u251c\u2500\u2500 mice/\n        \u251c\u2500\u2500 Kernel/\n            \u251c\u2500\u2500 de430.bsp\n            \u251c\u2500\u2500 gm_de431.tpc\n            \u251c\u2500\u2500 mar097.bsp\n            \u251c\u2500\u2500 naif0012.tls\n            \u251c\u2500\u2500 pck00010.tpc\n            \u2514\u2500\u2500 sat375.bsp\n        \u2514\u2500\u2500 mice\n\u251c\u2500\u2500 clearDeleteAdd.m\n\u2514\u2500\u2500 main_script.m\n</code></pre> <p>The <code>main_script.m</code> is the one we want to modify (see, for example the tutorial on trips to Jupiter or this script).</p> <p>After having set-up all the input and the ASTRA environment, one needs to load the NASA ephemerides. This can be done by imposing that:</p> <pre><code>% --&gt; load MICE toolbox\nMICE_path = './MICE_TOOLBOX' ;\naddpath(genpath(MICE_path)); % --&gt; always include this\ncspice_furnsh([MICE_path '/data.mk']);\n</code></pre> <p>In this way, one loads the kernels for planetary ephemerides. This is not sufficient. One needs to tell ASTRA which ephemerides it should use. The default ones are encoded in the script EphSS_cartesian.m. To overwrite those, one can simply set:</p> <pre><code>INPUT.customEphemerides = @EphSS_from_mice;\n</code></pre> <p>In particular, the function EphSS_from_mice.m allows to automatically use the NASA ephemerides.</p> <p>That's it. </p> <p>Then one can launch an optimization for the EVEMEJ similar to the tutorial on trips to Jupiter. Obviously, the two optimizations should provide very similar result:</p> <ul> <li>the one with approximate ephemerides has a minimum cost of: 8.94774 km/s and 6.45038 years</li> <li>the one with NASA ephemerides has a minimum cost of: 8.95409 km/s  and 6.45038 years</li> </ul> <p>which indeed are very close. Thus, if one needs to plan missions to any of the Solar System planet, the approximate ephemerides are suggested, as these are quite faster to compute with respect to high-precision ones.</p> <p>BUG DETECTED: currently, high-precision NASA ephemerides prevent ASTRA to be run in parallel mode when resonances are present in the sequence. A workaround to this is shown later, but a rearchitect is needed. This will be solved in the next update...</p>"},{"location":"nasa_ephemerides/#integrating-nasa-ephemerides-for-small-objects","title":"Integrating NASA ephemerides for small objects","text":"<p>A very interesting application for integrating NASA ephemerides into ASTRA is when one needs to plan missions to Solar System objects that are not planets (asteroids and/or comets). This opens a very wide range of possibilities in terms of mission design.</p> <p>If one has properly set-up the MICE toolbox as from the intallation guide, then the only thing that remains to do is to download the <code>.bsp</code> file containing the ephemerides of the desired object. EphSS_from_mice.m shows how to do it and the steps are reported here.</p> <p>As always, one needs to add ASTRA and MICE_TOOLBOX to the path:</p> <pre><code>% --&gt; load ASTRA\nclearDeleteAdd; % --&gt; !!! ONLY CALL IT ONCE FOR SPEED\n\n% --&gt; load mice\nMICE_path = './MICE_TOOLBOX';\naddpath(genpath(MICE_path)); % --&gt; always include this\ncspice_furnsh([MICE_path '/data.mk']);\n</code></pre> <p>Then, one selects the central body, and the time-span for the ephemerides validity:</p> <pre><code>% --&gt; central ID (Sun in this case)\nidcentral = 1;\n\n% --&gt; lower and upper bounds for ephemerides\nt0 = [ 2030 1 1 12 0 0 ];\ntf = [ 2100 1 1 12 0 0 ];\n</code></pre> <p>One now needs the SPKID of the object (in this case a comet is used):</p> <pre><code>% --&gt; SPKID of the object (found at https://ssd.jpl.nasa.gov/tools/sbdb_lookup.html#/)\nspk_id = 1000508;\n</code></pre> <p>SPKID of small bodies can be found at NASA Small Body Database Lookup page.</p> <p>One finally specifies the folder where the file should be downloaded (default path is used here):</p> <pre><code>% --&gt; set the path where to save the ephemerides\nspk_dir = pwd;\n</code></pre> <p>and finally one can call the NASA API:</p> <pre><code>% --&gt; run the code (if success=1 then everything is okay)\nsuccess = getSPK(num2str(spk_id), num2str(t0), num2str(tf), spk_dir, 'overwrite', 'on');\n</code></pre> <p>If everything is set-up properly, then one should have a file called <code>1000508.bsp</code> in the specified target folder.</p> <p>ASTRA is now ready to be run with the newly-generated ephemerides. The set-up is very similar as before. The desired comet has now ID that is <code>1000508</code> and thus the ASTRA set-up will be like:</p> <pre><code>% --&gt; sequence to be optimized\nINPUT.idcentral = 1; % --&gt; central body (Sun in this case)\n\nseq = [ 3 2 3 3 1000508 ]; res = [ 2 1 3 ];\n\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\nmaxrev                        = 1;                                                          % --&gt; max. number of revolutions (round number)\nchosenRevs                    = differentRuns_v2(seq, maxrev);                              % --&gt; generate successive runs\n[INPUT.chosenRevs, INPUT.res] = processResonances(chosenRevs, res);                         % --&gt; process the resonances options\n[INPUT.chosenRevs]            = maxRevOuterPlanets(seq, INPUT.chosenRevs, INPUT.idcentral); % --&gt; only zero revs. on outer planets\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\n\n%%%%%%%%%% set departing options %%%%%%%%%%\nt0 = date2mjd2000([2030 1 1 12 0 0]); % --&gt; initial date range (MJD2000)\ntf = t0 + 5*365.25;                  % --&gt; final date range (MJD2000)\ndt = 3;                            % --&gt; step size (days)\nINPUT.depOpts = [t0 tf dt];\n%%%%%%%%%% set departing options %%%%%%%%%%\n\n%%%%%%%%%% set options %%%%%%%%%%\nINPUT.opt      = 4;          % --&gt; (1) is for SODP, (2) is for MODP, (3) is for DATES - SODP, (4) is for YEARS - MODP\nINPUT.vInfOpts = [0 5];      % --&gt; min/max departing infinity velocities (km/s)\nINPUT.dsmOpts  = [1 Inf];    % --&gt; max defect DSM, and total DSMs (km/s)\nINPUT.plot     = [1 1];      % --&gt; plot(1) for Pareto front, plot(2) for best traj. DV\nINPUT.parallel = false;       % --&gt; put true for parallel, false otherwise\nINPUT.tstep    = dt;         % --&gt; step size for Time of flight            \n%%%%%%%%%% set options %%%%%%%%%%\n</code></pre> <p>Finally, one loads the ephemerides of the comet:</p> <pre><code>% --&gt; load custom ephemerides\nMICE_path = './MICE_TOOLBOX';\naddpath(genpath(MICE_path)); % --&gt; always include this\ncspice_furnsh([MICE_path '/data.mk']);\n\nspk_dir = [];           % --&gt; location of the bsp file with object ephemerides (if empty, then the current directory is used)\ncspice_furnsh([ pwd '\\' spk_dir '\\' num2str(max(seq)) '.bsp']); % --&gt; load the object ephemerides\n</code></pre> <p>As before, the ephemerides as passed to ASTRA as:</p> <pre><code>INPUT.customEphemerides = @EphSS_from_mice_workaround;\n</code></pre> <p>Please, note that in this case the ephemerides are loaded with a workaround to prevent the aforementioned bug to appear. Basically, EphSS_from_mice_workaround.m loads the approximate positions of the planets (that are proved to work well for planets), thus avoiding the bug, while for the desired object it uses the NASA kernels.</p> <p>One notices here that a scan of 5 years is set-up for this specific example, and thus one has that <code>INPUT.opt=4</code> (i.e., every year, multi-objective dynamic programming is used).</p>"},{"location":"nasa_ephemerides/#performing-asteroid-fly-bys-with-nasa-ephemerides-in-astra","title":"Performing asteroid fly-bys with NASA ephemerides in ASTRA","text":"<p>It has to be said that one can also write sequences of objects that simulate asteroids fly-bys. In this case, ASTRA will consider them as massless points in space (so zero sphere of influence). </p> <p>Let's take the following example. </p>"},{"location":"trips_to_jupiter/","title":"Trips to Jupiter","text":"<p>This tutorial allows to run a simple test script with ASTRA for a mission towards Jupiter. Different sequences will be optimized, just to see different options for ASTRA.</p>"},{"location":"trips_to_jupiter/#eath-venus-earth-mars-earth-jupiter","title":"Eath-Venus-Earth-Mars-Earth-Jupiter","text":"<p>First sequence to analyse is the Eath-Venus-Earth-Mars-Earth-Jupiter (EVEMEJ), that has been considered for JUICE mission.</p> <p>This tutorial is based on this script. This allows to optimize the sequence either with SODP (single-objective dynamic programming) or with MODP (multi-objective dynamic programming). A breakdown of the minimum input parameter needed is provided here.</p> <p>From this script, one needs to call ASTRA and building the mex functions (namely Lambert solver, defects function, and low-thrust module):</p> <pre><code>clearDeleteAdd;\n</code></pre> <p>Then one proceeds to select appropriate input parameters.</p> <pre><code>%% --&gt; input section\n\n% --&gt; clear INPUT and define new ones\ntry clear INPUT; catch; end; clc;\n\n% --&gt; sequence to be optimized\nINPUT.idcentral = 1; \nseq = [ 3 2 3 4 3 5 ]; res = [ ];\n\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\nmaxrev                        = 0;                                         % --&gt; max. number of revolutions (round number)\nchosenRevs                    = differentRuns_v2(seq, maxrev);             % --&gt; generate successive runs\n[INPUT.chosenRevs, INPUT.res] = processResonances(chosenRevs, res);        % --&gt; process the resonances options\n[INPUT.chosenRevs]            = maxRevOuterPlanets(seq, INPUT.chosenRevs); % --&gt; only zero revs. on outer planets\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\n\n%%%%%%%%%% set departing options %%%%%%%%%%\nt0 = date2mjd2000([2023 1 1 0 0 0]); % --&gt; initial date range for launch (MJD2000)\ntf = t0 + 1*365.25;                  % --&gt; final date range for launch (MJD2000)\ndt = 2.5;                            % --&gt; step size in launch window (days)\nINPUT.depOpts = [t0 tf dt];\n%%%%%%%%%% set departing options %%%%%%%%%%\n\n%%%%%%%%%% set options %%%%%%%%%%\nINPUT.opt      = 2;          % --&gt; (1) is for SODP, (2) is for MODP, (3) is for DATES, (4) is for YEARS - MODP\nINPUT.vInfOpts = [3 5];      % --&gt; min/max departing infinity velocities (km/s)\nINPUT.dsmOpts  = [2 Inf];    % --&gt; max defect DSM, and total defects DSMs (km/s)\nINPUT.plot     = [0 0];      % --&gt; plot(1) for Pareto front, plot(2) for best traj. DV\nINPUT.parallel = true;       % --&gt; put true for parallel, false otherwise\nINPUT.tstep    = dt;         % --&gt; step size for Time of flight            \n%%%%%%%%%% set options %%%%%%%%%%\n</code></pre> <p>Things to notice are:</p> <ul> <li> <p><code>INPUT.idcentral</code> allows to select the system. In this example, <code>INPUT.idcentral = 1</code> means that Solar System is selected. Other options are:</p> <ul> <li>5 for Jupiter system</li> <li>6 for Saturn system</li> <li>7 for Uranus system. See also constants.m for knowing about the IDs of the bodies.</li> </ul> </li> <li> <p><code>maxrev</code> is the number of revolutions for Lambert arcs. ASTRA computes all the possible permutations of revolutions per leg (both long and short option) up to the maximum desired by the user.</p> </li> <li><code>maxRevOuterPlanets</code> will prune options with more than one rev. on legs towards outer planets (i.e., from Jupiter on). This to prevent the mission duration to increase a lot.</li> <li><code>res</code> is a list of integers with <code>[ N, M, LEG_ID ]</code>, where <code>N</code> and <code>M</code> are the object and spacecraft revolutions, respectively, and <code>LEG_ID</code> is the number of the leg at which the resonance is. In this case, it is empty as no resonances are included in the transfer. Later, an example will be shown.</li> <li><code>INPUT.opt</code> selects the type of optimization. </li> <li><code>1</code> is for SODP</li> <li><code>2</code> is for MODP</li> <li><code>3</code> is for SODP run each launch date. </li> <li><code>4</code> is for MODP run each launch year. If the user selects a launch window greater or equal than 3 year AND <code>INPUT.opt=2</code>, this option is selected automatically. This allows to reduce the computational burden in terms of RAM.</li> </ul> <p>The options defined above allow for an MGA trajectory search of <code>Earth-Venus-Earth-Mars-Earth-Jupiter</code> mission in year <code>2023</code> using MODP (<code>INPUT.opt=2</code>).</p> <p>ASTRA main engine can then be run using:</p> <pre><code>%% --&gt; optimize using ASTRA\n\n% --&gt; launch ASTRA optimization\nOUTPUT = ASTRA_DP(seq, INPUT);\n</code></pre> <p>Results are saved in a structure called <code>OUTPUT</code>.</p> <p>If needed, one can then post-process the results, extracting the desired trajectory from the Pareto front, plotting the Pareto front itself and the selected path.</p> <pre><code>% --&gt; process the OUTPUT\nprocessed_OUTPUT = postProcessOutputASTRA( OUTPUT );\n\n% --&gt; process the output for better user experience\nparetoFront = process_paretoFront_structure( INPUT, processed_OUTPUT );\n</code></pre> <p>Specfically, the structure <code>paretoFront</code> has all the relevant information about the trajectories on the Pareto front that are easily interpretable. In particular, the default objective functions to be minimized and represented in the plots are:</p> <ul> <li>overall $ \\Delta v$ consumption (that is the departing infinity velocity $ v_{\\infty,dep} $, sum of defects and arrival infinity velocity $ v_{\\infty,arr}$)</li> <li>overall time of flight</li> </ul> <p>Custom objective functions can also be included as shown in another tutorial.</p> <p>Once the pareto front is extracted, one can plot it:</p> <pre><code>% --&gt; plot the Pareto front\nfigPareto = plotPareto(processed_OUTPUT.PARETO_FRONT);\n</code></pre> <p></p> <p>A specific trajectory (variable <code>path</code> in the <code>paretoFront</code> structure) can also be extracted and plotted.</p> <pre><code>row  = length(paretoFront);   % --&gt; select the path to plot (minimum DV in this specific example)\npath = paretoFront(row).path;\nrevs = paretoFront(row).revs;\nres  = paretoFront(row).res;\n\n% --&gt; plot the path\n[figECI, STRUC, figSYN, figRSC, figVSC] = plotPath(path, INPUT.idcentral);\n</code></pre> <p>The plot of the optimal trajectory in inertial and Earth-Sun synodic frame is the following:</p> <p>The function plotPath.m also allows to plot the evolutions of spacecraft distance and velocity with respect to central body:</p> <p>The function generateOutputTXT.m creates a .txt file in a folder called <code>./results</code> that has all the info of the trajectory.</p> <pre><code>% --&gt; save the output\ngenerateOutputTXT(path, INPUT.idcentral, ...\n    @EphSS_cartesian, ...\n    '/target_folder', ...\n    'name_of_the_file');\n</code></pre> <p>This is reported here:</p> <pre><code>\n          _/_/_/     _/_/_/  _/_/_/_/_/  _/_/_/    _/_/_/ \n        _/    _/   _/           _/     _/    _/  _/    _/ \n       _/_/_/_/     _/_/       _/     _/_/_/    _/_/_/_/  \n      _/    _/         _/     _/     _/    _/  _/    _/   \n     _/    _/    _/_/_/      _/     _/    _/  _/    _/    \n\n\n               - ASTRA solution - \n\n-------------------------------------------------------------- \n\nDeparting body                 : Earth  \nDistance from the central body : 1.0000 AU \n\n-------------------------------------------------------------- \n\nArrival body                   : Jupiter\nDistance from the central body : 5.2026 AU \nDeparting C3                   : 9.9710 km^2/s^2 \nDeparting infinity velocity    : 3.1577 km/s \nArrival infinity velocity      : 5.5622 km/s \nTotal cost (DSMs)              : 0.2279 km/s \nTotal cost                     : 8.9477 km/s \nTime of flight                 : 6.4504 years \n\n-------------------------------------------------------------- \n\nMGA Details : \n\nSwing-by sequence      : -E--V--E--M--E--J-\n\nDeparting date         : [2023   5  25   0   0   0]\nArrival date           : [2029  11   5   0   0   0]\nTime of flight per leg : 149 days \n                         314 days \n                         164 days \n                         653 days \n                         1076 days \n\nDSMs magnitudes        : 0 km/s \n                         0 km/s \n                         0.0435 km/s \n                         0.175 km/s \n                         0.0030602 km/s \n                         0.0062967 km/s \n\nInfinity velocities    : \nEarth   - Venus        : 3.1577 - 5.491 km/s \nVenus   - Earth        : 5.5345 - 8.6843 km/s \nEarth   - Mars         : 8.8594 - 9.9807 km/s \nMars    - Earth        : 9.9837 - 11.356 km/s \nEarth   - Jupiter      : 11.3497 - 5.5622 km/s \n\nState at departure/arrival (km and km/s) : \nEarth                         : [-67443219.33399     -135660718.6523                   0        24.241512589      -11.7048292755      1.836903188908]  \nVenus                         : [37311161.50828      101201436.6601     -794434.8182506     -35.16859904353      13.90789291013     -2.571549670311]  \n\nVenus                         : [37311161.50828      101201436.6601     -794434.8182506     -38.11916712221      12.05366801041    0.02734636620768]  \nEarth                         : [139172686.8417     -58704309.11459                   0      2.765219554958      29.78400878435    -0.2102630162746]  \n\nEarth                         : [139172686.8417     -58704309.11459                   0      6.581015760611      34.63293925256       2.19921939779]  \nMars                          : [-149676335.9057      195136449.5053      7760204.399362     -23.46960002881     -4.185823816296    -0.8280693030055]  \n\nMars                          : [-149676335.9057      195136449.5053      7760204.399362     -22.68651649801     -3.708904715841     0.6440840164211]  \nEarth                         : [67683770.4888      131263396.4678                   0     -25.22025731172      24.69727827743      1.176764665526]  \n\nEarth                         : [67683770.4888      131263396.4678                   0     -30.54695793792      24.14446259252       1.85752423869]  \nJupiter                       : [-638295113.4513     -502726641.4791      16376543.69961      4.808110564511     -5.055217205055    -0.3203290652118]  \n\nEncounter dates        : \nEarth                  : [2023   5  25   0   0   0]\nVenus                  : [2023  10  21   0   0   0]\nEarth                  : [2024   8  30   0   0   0]\nMars                   : [2025   2  10   0   0   0]\nEarth                  : [2026  11  25   0   0   0]\nJupiter                : [2029  11   5   0   0   0]\n\nTransfer types         : \nEarth   - Venus        : inbound - outbound \nVenus   - Earth        : inbound - inbound \nEarth   - Mars         : inbound - outbound \nMars    - Earth        : outbound - outbound \nEarth   - Jupiter      : outbound - inbound \n\n-------------------------------------------------------------- \n</code></pre> <p>Finally, one can further refine the solution around a specified trajectory, to further reduce the defects that might arise:</p> <pre><code>%% --&gt; futher refine around the optimal DV-solution\n\nINPUT.t0days  = 10;   % --&gt; days around current solution departing epoch\nINPUT.tofdays = 15;   % --&gt; days around current solution TOFs\nINPUT.dt      = 0.5;  % --&gt; step size (days)\nINPUT.revs    = revs;\nINPUT.res     = res;\n\n% --&gt; further refine using ASTRA\nOUTPUTref           = refineUsingASTRApath(path, INPUT);\nprocessed_OUTPUTref = postProcessOutputASTRA( OUTPUTref );\nparetoFrontref      = process_paretoFront_structure( INPUT, processed_OUTPUTref );\n</code></pre> <p>It is always suggested to run this second step as one might use coarse grids as initial optimization. In this specific example one has that:</p> <ul> <li>minimum cost function before the refinement is: 8.94774 km/s and 6.450376 years</li> <li>mimimum cost functions after the refinement are: 8.85087 km/s and 6.46407 years</li> </ul> <p>so the refinement actually helped at the price of slightly increased transfer time.</p>"},{"location":"trips_to_jupiter/#eath-venus-earth-earth-jupiter","title":"Eath-Venus-Earth-Earth-Jupiter","text":"<p>This second tutorial is very similar to the one above. The main difference is that one uses a resonant transfer in the Earth-Earth leg.</p> <p>The only difference with the script above is:</p> <pre><code>seq = [ 3 2 3 3 5 ];   res = [ 2 1 3 ];\n</code></pre> <p>where <code>res</code> now specifies <code>[2 1 3]</code>, i.e., 2:1 resonance on the 3rd leg. If multiple resonances are needed, one specifies it via: </p> <ul> <li><code>res = [N, M, LEG_ID_1, N, M, LEG_ID_1]</code> and so on...</li> </ul> <p>The same input as before are used. The results are reported below. One notices the resonant leg, on which the trajectory returns back at Earth at the same position of the planet on its orbit after 2 orbital periods (2:1 resonance).</p> <p></p>"},{"location":"trips_to_jupiter/#earth-venus-earth-mars-mars-mars-jupiter","title":"Earth-Venus-Earth-Mars-Mars-Mars-Jupiter","text":"<p>This last script is just to show consecutive resonant legs setup in ASTRA. Specifically, 2:1 and 3:1 resonant ratios are used in successive Mars-Mars legs.</p> <p>Again, the only thing that changes is the following:</p> <pre><code>seq = [ 3 2 3 4 4 4 5 ];   res = [ 2 1 4 3 1 5 ];\n</code></pre> <p></p>"}]}