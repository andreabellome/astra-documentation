{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ASTRA! \ud83d\ude80","text":"<p>ASTRA (Automatic Swing-by TRAjectories) is a MATLAB-based toolbox for optimally building multi-gravity assist (MGA) trajectories. This has been built as a result of Andrea Bellome's Ph.D. thesis [1]. ASTRA is based on Dynamic Programming (DP) to optimize MGA trajectories, both in single-objective (SODP) and multi-objective (MODP) variant.</p> <p>To cite this folder please use the references [1] and [2].</p>"},{"location":"#overview","title":"Overview","text":"<ul> <li>\ud83c\udf0d Developed for space trajectory optimization and mission design</li> <li>\ud83d\udd2c Written in MATLAB with modular architecture</li> <li>\ud83e\uddea Includes tests and examples</li> </ul> <p>Use the sidebar to navigate the documentation.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Currently, only invited developers can contribute to the repository.</p> <p>For the moment, the only contributor is... Andrea Bellome! Yeee \ud83d\udc32</p>"},{"location":"#license","title":"License","text":"<p>The work is under license CC BY-NC-SA 4.0, that is an Attribution Non-Commercial license.</p>"},{"location":"#references","title":"References","text":"<p>[1]  Bellome, A., \u201cTrajectory design of multi-target missions via graph transcription and dynamic programming,\u201d Ph.D. thesis, Cranfield University, 2023. https://dspace.lib.cranfield.ac.uk/items/711f45c8-e6e4-4f27-909d-94170df400e3</p> <p>[2]  Bellome, A., et al. \"Multiobjective design of gravity-assist trajectories via graph transcription and dynamic programming.\" Journal of Spacecraft and Rockets 60.5 (2023): 1381-1399. https://doi.org/10.2514/1.A35472</p>"},{"location":"custom_input/","title":"Using custom input parameters","text":"<p>This tutorial shows how to include some custom input parameters to ASTRA optimization. These are the following:</p> <ul> <li>Custom boundaries for time of flight between planets</li> <li>Custom maximum overall mission duration</li> <li>Custom boundaries of infinity velocities $ v_{\\infty} $ at different bodies encounters</li> <li>Custom ephemerides</li> <li>Custom objective functions for both SODP and MODP</li> </ul>"},{"location":"custom_input/#custom-boundaries","title":"Custom boundaries","text":"<p>This section shows how to add custom boundaries to time of flight, overall mission duration, and infinity velocities at objects' encounters.</p> <p>This is very easy to do in ASTRA as one needs to select the following optional input to be appended to the <code>INPUT</code> structure:</p> <pre><code>% --&gt; sequence and resonances\nseq = [ 3 2 3 3 5 ]; res = [ 2 1 3 ];\n\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\nmaxrev                        = 1;                                                          % --&gt; max. number of revolutions (round number)\nchosenRevs                    = differentRuns_v2(seq, maxrev);                              % --&gt; generate successive runs\n[INPUT.chosenRevs, INPUT.res] = processResonances(chosenRevs, res);                         % --&gt; process the resonances options\n[INPUT.chosenRevs]            = maxRevOuterPlanets(seq, INPUT.chosenRevs, INPUT.idcentral); % --&gt; only zero revs. on outer planets\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\n\n%%%%%%%%%% set departing options %%%%%%%%%%\nt0 = date2mjd2000([2023 1 1 12 0 0]); % --&gt; initial date range (MJD2000)\ntf = t0 + 1*365.25;                   % --&gt; final date range (MJD2000)\ndt = 5;                               % --&gt; step size (days)\nINPUT.depOpts = [t0 tf dt];\n%%%%%%%%%% set departing options %%%%%%%%%%\n\n%%%%%%%%%% set options %%%%%%%%%%\nINPUT.opt      = 1;          % --&gt; (1) is for SODP, (2) is for MODP, (3) is for DATES - SODP, (4) is for YEARS - MODP\nINPUT.vInfOpts = [0 4];      % --&gt; min/max departing infinity velocities (km/s)\nINPUT.dsmOpts  = [1 Inf];    % --&gt; max defect DSM, and total DSMs (km/s)\nINPUT.plot     = [1 1];      % --&gt; plot(1) for Pareto front, plot(2) for best traj. DV\nINPUT.parallel = true;       % --&gt; put true for parallel, false otherwise\nINPUT.tstep    = 3;          % --&gt; step size for Time of flight            \n%%%%%%%%%% set options %%%%%%%%%%\n\n%%%%%%%%%% custom boundaries %%%%%%%%%%\nINPUT.TOF_LIM = [ 100 500; 100 500; 100 500; 500 2000 ]; % --&gt; min./max TOF [days] for each leg\nINPUT.vInfLim = [ 0 5; 0 9; 0 11; 0 11; 0 7 ];           % --&gt; min./max infinity velocity [km/s] for each planet \nINPUT.tofyMax = 7;                                       % --&gt; max. overall mission duration [years]\n%%%%%%%%%% custom boundaries %%%%%%%%%%\n</code></pre> <p>Specifically:</p> <ul> <li> <p>The field <code>INPUT.TOF_LIM</code> specifies the minimum and maximum time of flight for each leg -- a leg is a planet-to-planet transfer. Thus, in the example, one has 5 planets (EVEEJ) and 4 legs (EV, VE, EE, EJ). One notices that a resonance is specified on the 3rd leg. Therefore, setting up the time-of-flight bounds on that leg it has no effect (the resonance dictates the time).</p> </li> <li> <p>Similarly, the field <code>INPUT.vInfLim</code> specifies minimum and maximum infinity velocities at planetary encounters. One should specify one for each planet. If the target object is a comet/asteroid, then the bounds on infinity velocity actually correspond to the bounds for a $ \\Delta v $ to rendezvous with the object. One should notice that infinity velocity bounds at the first planet are not effective as one should always specify:</p> <p><code>matlab INPUT.vInfOpts = [0 5];      % --&gt; min/max departing infinity velocities (km/s)</code></p> <p>Obviously, if the first object of the sequence is an asteroid/comet, this is equivalent to a $ \\Delta v $ to depart from it.</p> </li> <li> <p>Finally, the field <code>INPUT.tofyMax</code> allows to set-up the maximum transfer time in years of the whole trip.</p> </li> </ul>"},{"location":"custom_input/#custom-ephemerides","title":"Custom ephemerides","text":"<p>Customising ephemerides function requires a bit of coding.</p> <p>Essentially, ASTRA works with approximate planetary positions encoded in the script EphSS_cartesian.m. These are proven to be sufficiently close to NASA high-precsion ones (e.g., de430.bsp), as shown in this tutorial.</p> <p>If one wants to specify a custom function (say <code>Eph_custom</code>), the template should be:</p> <pre><code>function [ rr, vv ] = Eph_custom( pl, t, idcentral )\n\n% --&gt; here the logic...\n\nend\n</code></pre> <p>Where in input is required:</p> <ul> <li><code>pl</code> is the ID of the body</li> <li><code>t</code> is the epoch at which the ephemerides are computed in MJD2000</li> <li><code>idcentral</code> should specify the central body (e.g., <code>idcentral=1</code> if the Sun is the central body)</li> </ul> <p>The output are:</p> <ul> <li><code>rr</code>: a <code>3x1</code> vector with object position in consistent reference frame, expressed in km</li> <li><code>vv</code>: a <code>3x1</code> vector with object velocity in consistent reference frame, expressed in km/s</li> </ul> <p>It is important to notice that custom ephemerides function should in any case override the EphSS_cartesian.m function, or include it. Moreover, custom objects in the Solar System must have IDs that are greater than 9 (<code>pl = 9</code> corresponds to Pluto). This is because when computing fly-bys, ASTRA reads the function constants.m to retrieve the fly-by parameters. For asteroids and comets (i.e., for objects with <code>pl &gt; 9</code>), zero gravity is assumed and thus zero sphere of influence.</p> <p>Thus, a template for including a custom objects (if one does not want to use NASA ephemerides as shown here) should look like the following:</p> <pre><code>function [ rr, vv ] = Eph_custom( pl, t, idcentral )\n\nif idcentral == 1 &amp;&amp; pl &lt;= 9 % --&gt; Sun as main body and max. ID for planets is 9 (Pluto)\n\n    [ rr, vv ] = EpSS_cartesian( pl, t, idcentral );\n\nelse\n    % --&gt; here the logic for the custom object...\n\nend\n\nend\n</code></pre> <p>Finally, in the main script one simply sets the following before launching the optimization:</p> <pre><code>INPUT.customEphemerides = @Eph_custom; % --&gt; specify the custom ephemerides function\n</code></pre> <p>In this way, ASTRA uses the custom ephemerides function defined by the user. </p>"},{"location":"custom_input/#custom-objective-functions","title":"Custom objective functions","text":"<p>Customising objective functions requires a bit of coding. </p> <p>By default, ASTRA will optimise the following objective functions:</p> <ul> <li>overall $ \\Delta v $ as the sum of departing infinity velocity $ v_{\\infty,dep} $, defects along the transfer, and arrival infinity velocity $ v_{\\infty,arr} $</li> <li>overall transfer time</li> </ul> <p>However, one might want to define custom objectives.</p> <p>(coming soon...)</p>"},{"location":"deep_space_man/","title":"Trajectories with Deep-Space Manoeuvres","text":"<p>This tutorial shows how to refine trajectory solutions generated by ASTRA using multiple Deep Space Manoeuvres (DSMs). These impulsive manoeuvres are assumed to occur between consecutive planetary encounters. It is also possible to include more than one manoeuvre in each leg of a Multiple Gravity Assist (MGA) mission.</p> <p>For further background on this topic, you may refer to [1] and [2].</p> <p>In order to run this tutorial, the MATLAB Parallel Computing Toolbox is needed.</p>"},{"location":"deep_space_man/#method-overview","title":"Method Overview","text":"<p>The main model used to refine ASTRA solutions is the MGA-nDSM model, where one or more manoeuvres are placed between consecutive planetary encounters.</p> <p>The following sections provide more detail.</p>"},{"location":"deep_space_man/#using-one-dsm","title":"Using One DSM","text":"<p>After each planetary encounter, the trajectory is propagated forward to the time of the manoeuvre. From that point, a Lambert problem is solved to reach the next encounter. The DSM is then computed as the difference between the final velocity from propagation and the initial velocity provided by the Lambert solution.</p> <p>It is also possible to specify whether a DSM should be included in the first leg. - If not, a Lambert arc is solved directly between the departure body and the first planetary encounter. - If yes, the initial position is taken from the object's ephemerides (see also the ephemerides tutorial), while the initial velocity is defined by:</p> <ul> <li>infinity velocity magnitude  </li> <li>declination  </li> <li>right ascension  </li> </ul> <p>At the next encounter, the Lambert solution yields the arrival velocity, from which the incoming hyperbolic excess velocity can be derived. The fly-by parameters are then optimised:</p> <ul> <li>periapsis radius of the flyby hyperbola  </li> <li>inclination of the flyby plane  </li> </ul> <p>From these, the outgoing hyperbolic excess velocity and the post-flyby spacecraft velocity are obtained, and the process is repeated.</p>"},{"location":"deep_space_man/#using-multiple-dsms","title":"Using Multiple DSMs","text":"<p>When using multiple DSMs per leg, the principle is similar. After each planetary encounter:</p> <ol> <li>The trajectory is propagated to the first manoeuvre point.  </li> <li>A DSM is applied, defined by its components: <code>[DSMx, DSMy, DSMz]</code></li> <li>The trajectory is then propagated to the next manoeuvre point, and so on.</li> </ol> <p>If the final DSM point in the leg has been reached, a Lambert problem is solved to reach the next object. As before, the final DSM is computed as the difference between the velocity after propagation and the initial velocity from the Lambert arc.</p>"},{"location":"deep_space_man/#mission-to-saturn","title":"Mission to Saturn","text":"<p>Let's have a look at a mission to Saturn similar to Cassini mission. This uses an MGA trajectory that is Earth-Venus-Venus-Earth-Jupiter-Saturn, using one main DSM in the Venus-Venus leg [3].</p>"},{"location":"deep_space_man/#set-up","title":"Set-up","text":"<p>Assume you just launched an ASTRA run as from the tutorial on trajectories to Jupiter. Now, one can extract the Pareto front as from:</p> <pre><code>% --&gt; process the OUTPUT\nprocessed_OUTPUT = postProcessOutputASTRA( OUTPUT );\n\n% --&gt; process the output for better user experience\nparetoFront = process_paretoFront_structure( INPUT, processed_OUTPUT );\n</code></pre> <p>From the structure <code>paretoFront</code> one selects the preferred solutions based on user-defined objectives (e.g., launch date, departing infinity velocity, arrival infinity velocity,...). Say that you want the <code>n_sol</code> solution:</p> <pre><code>path = paretoFront(n_sol).path;  % --&gt; this encodes the trajectory\nrevs = paretoFront(n_sol).revs;  % --&gt; this encodes the revolutions for the Lambert solver\nres  = paretoFront(n_sol).res;   % --&gt; this encodes the resonance (empty if no resonances are present)\n</code></pre> <p>Let's also specify the ephemerides and central body used to obtain such solution:</p> <pre><code>INPUT.customEphemerides = @EphSS_cartesian; % --&gt; ephemerides used\nINPUT.idcentral         = idcentral;        % --&gt; central body (Sun in this case)\n</code></pre>"},{"location":"deep_space_man/#bounds-and-constraints","title":"Bounds and constraints","text":"<p>First, one needs to specify how many manoeuvres are needed for each planet-to-planet leg. A function is present that assumes 1 manoeuvre per leg for each revolution in the leg (so if the spacecraft does 2 revolutions in one leg, then 2 manoeuvres are added):</p> <pre><code>% --&gt; number of DSM w.r.t. the number of revolutions per leg\n[NmanLeg] = revs2NmanLeg(revs);\n</code></pre> <p>Now one needs to specify the bounds for the optimisation problem. One defines these with respect to the ASTRA solution contained in <code>path</code>:</p> <pre><code>t0days      = 35;      % --&gt; days plus/minus the reference launch epoch from the path\ntofperc     = 10/100;  % --&gt; percentage plus/minus the reference time of flights from the path\nrpperc      = 90/100;  % --&gt; percentage plus/minus the reference periapsis altitude from the path\nksperc      = 90/100;  % --&gt; percentage plus/minus the reference flyby plane inclination from the path\n</code></pre> <p>The variables are the following:</p> <ul> <li><code>t0days</code>: Time window (in days) allowed around the reference launch epoch.</li> <li><code>tofperc</code>: Percentage variation permitted in the time of flight for each leg.</li> <li><code>rpperc</code>: Percentage variation allowed in the periapsis altitude during flybys.</li> <li><code>ksperc</code>: Percentage variation allowed in the inclination of the flyby plane.</li> </ul> <p>Then, one specifies if a DSM is needed on the first leg. If yes, then the maximum and minimum infinity velocity should be specified, otherwise those values are ignored</p> <pre><code>optFirstMan = 0;       % --&gt; flag to check if the first leg has a manoeuvre (0 is okay for most of the cases)\nvinfMin     = 0;       % --&gt; minimum v-infinity at departure [km/s] -- only works for optFirstMan = 1;\nvinfMax     = 4.0;     % --&gt; maximum v-infinity at departure [km/s] -- only works for optFirstMan = 1;\n</code></pre> <p>Finally, one needs to specify the maximum and minimum values for the <code>[DSMx, DSMy, DSMz]</code>, if multiple manoeuvres are present in any of the legs. Otherwise, this will be ignored by the optimiser.</p> <pre><code>dvsMaxMag   = 0.5;     % --&gt; maximum DSM magnitude [km/s] -- only works if more than one manoeuvre is present in the leg\n</code></pre> <p>One can assemble the full problem by building the lower and upper bounds, as well as passing in a structure the number of revolutions and DSMs per leg (this behaviour might change in the future...):</p> <pre><code>% --&gt; build the lower/upper bounds based on previous options\n[ t0Min, t0Max, TOFMin, TOFMax, rpMin, rpMax, etaMin, etaMax, seq, path ] = ...\n            minMaxFromPath(path, t0days, tofperc, rpperc, ksperc);\n[epsMin, epsMax] = minMaxEps(NmanLeg);                                          % --&gt; min. and max. fraction of time in the leg at which the manoeuvre is applied (between 0 and 1)\n[dvsMin, dvsMax] = minMaxDVS(dvsMaxMag, NmanLeg);                               % --&gt; min. and max. DSM components -- only works if multiple manoeuvres are present in one leg\n[dv1Min, dv1Max] = minMaxFirstMan(vinfMin, vinfMax, optFirstMan, NmanLeg);      % --&gt; min. and max. initial infinity velocity -- only works only works for optFirstMan = 1;\nlb               = [ t0Min TOFMin dv1Min dvsMin epsMin etaMin rpMin ];\nub               = [ t0Max TOFMax dv1Max dvsMax epsMax etaMax rpMax ];\n\nstruc_revs_man.revs       = revs;       % --&gt; revolutions per leg\nstruc_revs_man.NmanLeg    = NmanLeg;    % --&gt; number of manoeuvres per leg\n</code></pre> <p>Finally, the cost function is specified, that takes into account the first delta-v (or infinity velocity if leaving a planet), plus the sum of all DSMs that are present in the trajectory, plus the final delta-v (or final infinity velocity if arriving at a planet):</p> <pre><code>% --&gt; define the cost function\ncostFun                = @(x) wrap_mga_nDSM(seq, x, struc_revs_man, INPUT.customEphemerides);\n</code></pre>"},{"location":"deep_space_man/#optimisation","title":"Optimisation","text":"<p>One can now launch the optimisation. MATLAB Particle Swarm Optimisation (PSO) is used.</p> <p>First, let's define some options for the PSO:</p> <pre><code>% --&gt; options for the PSO\nmaxit       = 2;                           % --&gt; max. iteration for the PSO\nuseParallel = true;                        % --&gt; use parallel computing for the PSO (suggested: true)\noptionsPSO  = optPSO(lb, ub, useParallel); % --&gt; build the options for the PSO\n</code></pre> <p>One specifies 2 iterations for the PSO running, as this is a meta-heuristic algorithm that is not deterministic so in order to increase the chances to find good solutions multiple run might be needed.</p> <p>Finally, one can run the PSO for the number of times selected, and the minimum solution is retrieved:</p> <pre><code>% --&gt; optimise\nsol        = zeros(maxit, length(lb));\nfval       = zeros(maxit, 1);\nfor ind = 1:maxit\n    [sol(ind,:), fval(ind,:)] = particleswarm(costFun, length(lb), lb, ub, optionsPSO);\nend\n\n% --&gt; extract the minimum solution\n[minc, row] = min(fval);\nminsol      = sol(row,:);\n</code></pre> <p>To plot the optimised trajectory, one re-uses the function <code>wrap_mga_nDSM</code>:</p> <pre><code>% --&gt; plot\n[DV, dv, t0, tofs, MAT, output] = wrap_mga_nDSM(seq, minsol, struc_revs_man, INPUT.customEphemerides, 1);\n</code></pre> <p>The final output should be something like the following trajectory. </p> <p></p> <p>As it can be seen, the PSO has found a DSM of about 0.4295 km/s on the Venus-Venus leg of the transfer. The initial infinity velocity at Earth is about 4.045 km/s and the final one at Saturn is 5.131 km/s. These values are compatible with the ones of the actual Cassini mission [3].</p>"},{"location":"deep_space_man/#references","title":"References","text":"<p>[1]  Vasile, Massimiliano, and Paolo De Pascale. \"Preliminary design of multiple gravity-assist trajectories.\" Journal of Spacecraft and Rockets 43.4 (2006): 794-805. https://doi.org/10.2514/1.17413</p> <p>[2]  Bellome, A., \u201cTrajectory design of multi-target missions via graph transcription and dynamic programming,\u201d Ph.D. thesis, Cranfield University, 2023. https://dspace.lib.cranfield.ac.uk/items/711f45c8-e6e4-4f27-909d-94170df400e3</p> <p>[3]  F. Peralta and S. Flanagan, \u201cCassini interplanetary trajectory design,\u201d Control Engineering Practice, vol. 3, no. 11, pp. 1603\u20131610, 1995. https://doi.org/10.1016/0967-0661(95)00171-P</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#requirements","title":"Requirements","text":"<p>To run a full exploration of MGA trajectories, the following system requirements are recommended:</p> <ul> <li>CPU six-core from 2.6 GHz to 3.6 GHz.</li> <li>RAM minimum 16 GB.</li> <li>Any version of MATLAB \u22652021b.</li> <li>A compiler for C functions should be used. You can use the minGW.</li> <li>(optional) MATLAB Parallel Computing Toolbox. This is needed to run ASTRA in parallel mode, and to use the low-thrust module.</li> <li>(optional) MATLAB Optimization Toolbox. This is needed to refine trajectories with Deep Space Manoeuvres (DSMs), if needed by the user.</li> </ul> <p>These are suggested requirements for ASTRA to work to its full potential. Lighter requirements might work well, as ASTRA is able to optimize one launch year at a time, and even one date at a time. The price is the computational time. </p> <p>ASTRA should be agnostic with respect to the operating system. However, some bugs might arise if Windows is not used.</p>"},{"location":"install/#installation-steps","title":"Installation Steps","text":""},{"location":"install/#astra","title":"ASTRA","text":"<p>To work with ASTRA (without any external toolkits), one can simply clone the repository in the local machine:</p> <pre><code>git clone \"https://github.com/andreabellome/astra\"\n</code></pre> <p>And start using the tutorials.</p> <p>In particular, the project structure should be something like the following:</p> <pre><code>local-folder/\n\u251c\u2500\u2500 ASTRA/\n\u251c\u2500\u2500 clearDeleteAdd.m\n\u2514\u2500\u2500 main_script.m\n</code></pre> <p>where the script <code>clearDeleteAdd.m</code> is used to add all the ASTRA functionalities to the working local folder, and it is directly available when downloading the repository from GitHub. The <code>main_script.m</code> is a generic script that uses ASTRA (e.g., one of the tutorials).</p>"},{"location":"install/#nasa-mice-toolkit","title":"NASA MICE Toolkit","text":"<p>It is suggested to have also the SPICE toolkit. In particular, the MATLAB interface of SPICE is called MICE, and one can download it from here, for different operating systems. This is very useful to integrate high-precision ephemerides of Solar System objects in ASTRA (planets, moons, asteroids, comets...).</p> <p>Without going too much in detail on MICE, here the steps are reported for a proper integration in ASTRA:</p> <ol> <li>Open the toolkit page and select the operating system.</li> <li>Download the zip file <code>mice.zip</code> for the desired operating system</li> <li>Create a folder called <code>MICE_TOOLBOX</code> in the main path where ASTRA is and extract there the <code>mice.zip</code>.</li> <li>Then create a folder called <code>Kernel</code> within <code>MICE_TOOLBOX/mice</code>.</li> <li> <p>Download the required kernels, and add them to the <code>Kernel</code> folder. We will use the following (link to the NASA repository where to find them):     <ul> <li>de430.bsp -- Solar System planets' ephemerides</li> <li>mar097.bsp -- Mars ephemerides</li> <li>sat375.bsp -- Saturn ephemerides</li> <li>gm_de431.tpc -- gravity constants</li> <li>naif0012.tls -- leapseconds kernel</li> <li>pck00010.tpc -- body orientation kernel</li> </ul></p> </li> <li> <p>Within <code>MICE_TOOLBOX</code> folder, create a makefile called <code>data.mk</code> like the following:</p> </li> </ol> <pre><code>KPL/MK\n\n\n   \\begindata\n\n      PATH_VALUES     = ( './MICE_TOOLBOX/mice/Kernel' )\n\n      PATH_SYMBOLS    = ( 'KERNELS' )\n\n      KERNELS_TO_LOAD = (\n\n                          '$KERNELS/naif0012.tls'\n                          '$KERNELS/de430.bsp'\n                          '$KERNELS/sat375.bsp'\n                          '$KERNELS/mar097.bsp'\n                          '$KERNELS/gm_de431.tpc'\n                          '$KERNELS/pck00010.tpc'\n                        )\n\n   \\begintext\n\nEnd of MK.\n</code></pre> <p>After all the steps, the final structure of the project should be the following:</p> <pre><code>local-folder/\n\u251c\u2500\u2500 ASTRA\n\u251c\u2500\u2500 MICE_TOOLBOX/\n    \u251c\u2500\u2500 mice/\n        \u251c\u2500\u2500 Kernel/\n            \u251c\u2500\u2500 de430.bsp\n            \u251c\u2500\u2500 gm_de431.tpc\n            \u251c\u2500\u2500 mar097.bsp\n            \u251c\u2500\u2500 naif0012.tls\n            \u251c\u2500\u2500 pck00010.tpc\n            \u2514\u2500\u2500 sat375.bsp\n        \u2514\u2500\u2500 mice\n\u251c\u2500\u2500 clearDeleteAdd.m\n\u2514\u2500\u2500 main_script.m\n</code></pre> <p>One now has brand new MICE toolkit ready to be integrated with ASTRA. Different tutorials will show how to use it.</p>"},{"location":"low_thrust_trajectories/","title":"Converting ASTRA trajectories to low-thrust","text":"<p>This tutorial shows how to convert trajectories coming from ASTRA into low-thrust. It has to be said that ASTRA is currently able to convert solutions by solving a fuel-optimal time-fixed optimal control problem on each leg of the MGA trajectory under consideration, although with the current functions available in ASTRA, also the time-fixed energy-optimal control problem is solvable.</p> <p>Many references are available, but the main ones that inspired us are [1] and [2].</p> <p>Other OCPs (e.g., fuel-optimal time-fixed with variable thrust) are currently not available in ASTRA. </p>"},{"location":"low_thrust_trajectories/#converting-astra-solution-to-low-thrust","title":"Converting ASTRA solution to low-thrust","text":"<p>Assume you just launched an ASTRA run as from the tutorial on trajectories to Jupiter. Now, one can extract the Pareto front as from:</p> <pre><code>% --&gt; process the OUTPUT\nprocessed_OUTPUT = postProcessOutputASTRA( OUTPUT );\n\n% --&gt; process the output for better user experience\nparetoFront = process_paretoFront_structure( INPUT, processed_OUTPUT );\n</code></pre> <p>From the structure <code>paretoFront</code> one selects the preferred solutions based on user-defined objectives (e.g., launch date, departing infinity velocity, arrival infinity velocity,...). Say that you want the first solution:</p> <pre><code>path = paretoFront(1).path;  % --&gt; this encodes the trajectory\nrevs = paretoFront(1).revs;  % --&gt; this encodes the revolutions for the Lambert solver\nres  = paretoFront(1).res;   % --&gt; this encodes the resonance (empty if no resonances are present)\n</code></pre> <p>Then, one can build the following structure:</p> <pre><code>% --&gt; extract ASTRA solution\nastraSolution.path      = path;             % --&gt; ASTRA solution\nastraSolution.revs      = revs;             % --&gt; revolutions' options from ASTRA solution\nastraSolution.res       = res;              % --&gt; resonances' options from ASTRA solution\nastraSolution.vdep_free = vdep_free;        % --&gt; v-infinity provided by launcher 'for free' [km/s]\nastraSolution.varr_free = varr_free;        % --&gt; arrival infinity velocity 'for free' [km/s]\n</code></pre> <p>One notices that:</p> <ul> <li> <p><code>vdep_free</code> is the infinity velocity provided by the launcher, and thus the thrusting system shoud not provide it. When departing from a comet/asteroid, this should be put to 0, to simulate the departing burn (i.e., leaving the comet/asteroid orbit).</p> </li> <li> <p><code>varr_free</code> is the maximum infinity velocity admissible at the arrival. When arriving at a comet/asteroid, this should be put to 0, to simulate the rendezvous.</p> </li> </ul> <p>Then one needs to set-up the thrusting system:</p> <pre><code>% --&gt; define low-thrust parameters\nlowThrustParameters.Tmax        = 0.1;      % --&gt; max. thrust                       [N]\nlowThrustParameters.Isp         = 3000;     % --&gt; specific impulse                  [s]\nlowThrustParameters.m0          = 1800;     % --&gt; initial mass                      [kg]    \nlowThrustParameters.g0          = 9.80665;  % --&gt; Earth acceleration at sea level   [m/s]\n</code></pre> <p>And some specific parameters for the solver:</p> <pre><code>% --&gt; further optional parameters for optimal control solution\nlowThrustParameters.gamma       = 0.5;      % --&gt; discount factor for the smoothing parameter (default is 0.5)\nlowThrustParameters.plot        = true;     % --&gt; this plots the thrust evolution over time for different rho (default is false)\nlowThrustParameters.useParallel = true;     % --&gt; if true, uses parallel for fsolve (default is false)\nlowThrustParameters.rhoLim      = 1e-4;     % --&gt; limit on smoothing parameter (default is 1e-5)\n</code></pre> <p>The most critical ones are <code>gamma</code> and <code>rhoLim</code> and their impact is discussed in Ref [1]. Essentially:</p> <ul> <li> <p><code>gamma</code> is the factor that allows progressive transition from smooth to non-smooth optimal control problem. Typical values are in the range <code>0.5</code> to <code>0.9</code>. A higher value might help when short burns are found, at the price of higher computational effort. A small value makes the whole routine faster, but might be too aggressive in some cases. The user should decide on a case-to-case basis (<code>0.75</code> is suggested for most cases).</p> </li> <li> <p><code>rhoLim</code> is the limit on the smoothness of the fuel-optimal problem. A small value corresponds to a more optimal thrust profile, at the price of increased computational effort (some numerical issues might even prevent solutions to appear). A high value correspopnds to less accurate solution to the fuel-optimal problem. A trial-and-error approach identified values between <code>1e-3</code> to <code>1e-5</code> to be sufficiently good ones, as a compromise between computational effort and solutions quality. In other words, for values smaller than those, no significant improvement on the final mass is registered for the interplanetary transfers considered in ASTRA.</p> </li> </ul> <p>Finally, one can launch the solver:</p> <pre><code>% --&gt; find low-thrust transfers from ASTRA solution      \n[LT_SOLUTION, struc] = lowThrustFromASTRASolution( astraSolution, lowThrustParameters, INPUT.idcentral, INPUT.customEphemerides );\n</code></pre> <p>that attempts to solve fuel-optimal time-fixed optimal control problem for each leg of the ASTRA trajectory.</p> <p>It has to be noticed that one requires in input <code>INPUT.customEphemerides</code> that depends upon the user. See this tutorial. </p> <p>One can finally plot the resulting trajectories, mass, and thrust evolutions:</p> <pre><code>% --&gt; plot the final output\nclose all; clc;\n\nplanets = [struc.idD, struc(end).idA];\nt0      = struc(1).tD;\ntend    = struc(end).tA;\n\n[figTRAJ, figMASS, figTHRmag] = wrapPlotLTFull(LT_SOLUTION, LT_SOLUTION(1).LTsol.param);\n\nfigure(figTRAJ);\nplotPLTS_tt(planets, t0, tend, INPUT.idcentral, INPUT.customEphemerides, 1, [], [], 0.5, '--');\n</code></pre> <p>An example is shown for an EMEE-1000508 (where the SPKID 1000508 corresponds to the comet 320P/McNaught). </p> <p>In this case, the following options are used:</p> <pre><code>vdep_free = 4; % --&gt; km/s\nvarr_free = 0; % --&gt; km/s\n</code></pre> <p>Firstly, let's take the ASTRA solution (no refinement with DSM) before and after the low-thrust solver. One notices that the largest burns are in the first leg, to compensate the required infinity velocity at the departure (the needed one is <code>4.41932</code> km/s), and on the last leg, to rendezvous with the asteroid (matching position and velocity).</p> <p>The corresponding evolution of the thrust profile and the mass is shown in the figures below.</p> <p>Final trajectory details:</p> <ul> <li>overall time of flight: 3120.5 days</li> <li>final mass: 1470.218 kg</li> </ul>"},{"location":"low_thrust_trajectories/#converting-mga-ndsm-solution-to-low-thrust","title":"Converting MGA-nDSM solution to low-thrust","text":"<p>Now, let's assume that the same solution obtained before is refined with DSM (e.g., using this tutorial).</p> <p>One needs to post-process the MGA-nDSM solution:</p> <pre><code>[struc] = postProcessPathASTRA_dsm_lowThrust( dv, output, MAT, vdep_free, varr_free, idcentral, customEphemerides )\n</code></pre> <p>Then, simply passing this:</p> <pre><code>astraSolution.struc = struc;\n</code></pre> <p>alongside the other required inputs, will make ASTRA understand that the solution to be converted to low-thrust is the one with DSM (i.e., the one encoded in <code>struc</code>). In other words, ASTRA will only consider <code>astraSolution.struc = struc;</code> to solve the fuel-optimal problem, and not anymore <code>astraSolution.path = path;</code>, even if it is specified by the user.</p> <p>Below the corresponding trajectories before (left) and after (right) low-thrust conversion. One notices that the overall time of fight is increased, especially in the last leg, where a DSM of about 147.9 m/s is needed to lower the $ \\Delta v $ needed to rendezvous (i.e., from 1.9047 km/s of the defects solution, to 1.2112 km/s with DSMs).</p> <p>The corresponding evolution of the thrust profile and the mass is shown in the figures below.</p> <p>Final trajectory details:</p> <ul> <li>overall time of flight: 3248.720 days</li> <li>final mass: 1588.721 kg</li> </ul> <p>which indeed has higher mass compared to the previous case, at the price of increased transfer time.</p>"},{"location":"low_thrust_trajectories/#references","title":"References","text":"<p>[1]  Junkins, John L., and Ehsan Taheri. \"Exploration of alternative state vector choices for low-thrust trajectory optimization.\" Journal of Guidance, Control, and Dynamics 42.1 (2019): 47-64. https://doi.org/10.2514/1.G003686</p> <p>[2]  Wijayatunga, Minduli C., Roberto Armellin, and Laura Pirovano. \"Exploiting scaling constants to facilitate the convergence of indirect trajectory optimization methods.\" Journal of Guidance, Control, and Dynamics 46.5 (2023): 958-969. https://doi.org/10.2514/1.G007091</p>"},{"location":"lt_traj/","title":"Low-thrust trajectories","text":"<p>This tutorial shows how to solve fuel-optimal time-fixed optimal control problem. With the current functions available in ASTRA, also the time-fixed energy-optimal control problem is solvable, but not direct function is available via user-friendly API.</p> <p>It has to be said that to solve the fuel-optimal time-fixed optimal control problem ASTRA uses the solution from the time-fixed energy-optimal control problem as initial guess.</p> <p>Two representative test cases are shown:</p> <ul> <li> <p>An Earth-Mars transfer, realtively easy to solve as less than 1 revolution is needed to perform the transfer. Plus, the planets have very similar inclinations.</p> </li> <li> <p>A transfer from Earth to Dionysus asteroid, where multiple revolutions are needed and the inclination changes substantially (approx. 13 degrees).</p> </li> </ul> <p>One can find the reference script for these tutorials at this link.</p>"},{"location":"lt_traj/#earth-mars","title":"Earth-Mars","text":"<p>The first test case is an Earth-Mars transfer.</p> <p>One should select the system parameters:</p> <pre><code>clearDeleteAdd; % --&gt; !!! ONLY CALL IT ONCE FOR SPEED\n\n% --&gt; parameters\nidcentral   = 1;          % --&gt; 1) central body is the Sun\nTmax        = 0.5;        % --&gt; max. thrust                       [N]\nIsp         = 2000;       % --&gt; specific impulse                  [s]\nm0          = 1000;       % --&gt; initial mass                      [kg]           \ng0          = 9.80665;    % --&gt; Earth acceleration at sea level   [m/s]\nuseParallel = false;      % --&gt; if true, uses parallel for fsolve\n</code></pre> <p>Then one specifies the time of flight (in seconds), initial and final states (in km and km/s, for position and velocity, respectively), as well as the desired number of revolutions:</p> <pre><code>tof    = 348.795 * 86400;                                                       % --&gt; time of flight [sec]\nstate1 = [ -140699693 -51614428 980 9.774596  -28.07828  4.337725e-4 ];         % --&gt; initial state [km],[km/s]\nstate2 = [ -172682023 176959469 7948912 -16.427384  -14.860506  9.21486e-4 ];   % --&gt; final state [km],[km/s]\nNrev   = 0;                                                                     % --&gt; number of revolutions\n</code></pre> <p>A function is called to process such parameters:</p> <pre><code>% --&gt; initialise the parameters\nparam = processDataAndWriteParam(m0, tof, state1, state2, Tmax, Isp, g0, Nrev, idcentral, useParallel);\n</code></pre> <p>The user can then modify some of them to meet the desired accuracy:</p> <pre><code>% --&gt; you might want to overwrite some of those (some examples below)\nparam.rhoLim                                = 0.0001;\nparam.rho                                   = 1;\nparam.gamma                                 = 0.1;\nparam.plot                                  = true;    % --&gt; this plots the thrust evolution over time for different rho (default is false)\nparam.fsolveoptions.MaxFunctionEvaluations  = 10e3;\nparam.fsolveoptions.MaxIterations           = 10e3;\n</code></pre> <p>Specifically, <code>rhoLim</code>, <code>rho</code> and <code>gamma</code> are smoothing parameters that help solving the fuel-optimal problem. Having in mind that the fuel-optimal problem has a bang-off-bang optimal control, one has as general rules that:</p> <ul> <li> <p><code>rho</code> dictates the transition from energy-optimal to fuel-optimal problem. A low value (e.g., <code>0.0001</code>) will make the transition quite steep, and the fuel-optimal problem might not converge. A high value (max. is 1) will allow a smoother transition, but it will take more time to converge. Suggested values are <code>0.75</code> to <code>1</code>.</p> </li> <li> <p><code>rhoLim</code> dictates the quality of the fuel-optimal solution. A small value (e.g., <code>0.0001</code>) will make the smooth problem to be basically identical to a pure fuel-optimal problem, but it will take more time to run. Higher values correspond to smooth final solutions, not precisely corresponding to optimal trajectories. Values between <code>0.0001</code> and <code>0.01</code> are suggested.</p> </li> <li> <p><code>gamma</code> is the factor that cuts progressively <code>rho</code>, solving smoother problems at each iteration. A high value (max. is <code>1</code>) makes the transition from smooth problems to non-smooth quite gentle, helping the convergence, but sacrifycing the computing time. A small value makes the transition quite steep, saving computing time but potentially reducing convergence. Suggested values are <code>0.1</code> (simple problems) to <code>0.95</code> (complex problems).</p> </li> </ul> <p>Finally, one can solve the problem:</p> <pre><code>% --&gt; solve the problem\nLTsol = wrapSolveFopt( param );\n</code></pre> <p>The solution is contained in the <code>LTsol.transfer</code> variable, which is used to plot the results:</p> <pre><code>% --&gt; plot the solution\ntransfer = LTsol.transfer;\n[figTRAJ, figMASS, figTHRmag] = plotLT( transfer, param );\n\n% --&gt; add Mars and Earth orbits to the plot\nfigure(figTRAJ);\nplotPLTS_tt([3 4], 0, 3*365.25, idcentral, @EphSS_cartesian, 1);\n</code></pre> <p>Specifically, the trajectory, the mass evolution and the thrust profile are shown.</p> <p>This specific transfer has a final mass of 603.715 kg (all the info about the solution are within the variable <code>LTsol</code>).</p> <p></p>"},{"location":"lt_traj/#earth-dionysus","title":"Earth-Dionysus","text":"<p>As before, the system parameters are defined. In this case, one gives the states directly in Mean Equinoctial Elements (MEE), so a different function is used to build the parameters:</p> <pre><code>% --&gt; parameters\nidcentral = 1;        % --&gt; 1) central body is the Sun\nTmax      = 0.32;     % --&gt; max. thrust                       [N]\nIsp       = 3000;     % --&gt; specific impulse                  [s]\nm0        = 4000;     % --&gt; initial mass                      [kg]          \ng0        = 9.80665;  % --&gt; Earth acceleration at sea level   [m/s]\n\n% --&gt; initialise the parameters\nparam     = writeParamLT( Tmax, Isp, m0, g0, idcentral, true );\n</code></pre> <p>Then, one manually builds the initial and final states. Note that in this case, the optimal solution corresponds to <code>Nrev = 5</code>:</p> <pre><code>% --&gt; Earth-to-Dionysus\ntStart    = 0;\ntEnd      = 3534; % --&gt; please note that in this case the tof is in [days] as this is already scaled!!!\ninitState = [ 0.999316, -0.004023, 0.015873, -1.623e-5, 1.667e-5, 1.59491 ];\nfinState  = [ 1.555261 0.152514 -0.519189 0.016353 0.117461 2.36696 ];\n\nparam.tStart = tStart;\nparam.tEnd   = tEnd;\nparam.x0     = initState;\nparam.xf     = finState;\n\nparam.rhoGuess1 = 0.75;\nparam.plot      = true;\nparam.rhoLim    = 0.0001;\nparam.rho       = 1;\nparam.gamma     = 0.1;\nparam.iterMax   = 5;\nparam.tol       = 1e-8;\n\nwhile param.xf(end) &lt; param.x0(end)\n    param.xf(end) = param.xf(end) + 2*pi;\nend\n\nNrev            = 5;\nparam.xf(end)   = param.xf(end) + 2*Nrev*pi;\n</code></pre> <p>As before, one can solve the problem by calling:</p> <pre><code>% --&gt; solve the problem\nLTsol = wrapSolveFopt( param );\n</code></pre> <p>The solution is plotted:</p> <pre><code>% --&gt; plot the solution\ntransfer                      = LTsol.transfer;\n[figTRAJ, figMASS, figTHRmag] = plotLT( transfer, param );\n\nfigure(figTRAJ);\nview( [-19 13] );\nplotPLTS_tt(3, 0, 2*365.25, idcentral, @EphSS_cartesian, 1); % --&gt; add Earth orbit to the plot\n</code></pre> <p>Specifically, the trajectory, the mass evolution and the thrust profile are shown.</p> <p>This specific transfer has a final mass of 2719.995 kg (all the info about the solution are within the variable <code>LTsol</code>).</p> <p></p>"},{"location":"nasa_ephemerides/","title":"Using NASA ephemerides","text":"<p>This page shows how to integrate NASA high-precision ephemerides in ASTRA. This is particularly useful when using different planetary systems or when trips to comets or asteroids are sought.</p>"},{"location":"nasa_ephemerides/#integrating-nasa-ephemerides-for-solar-system-planets","title":"Integrating NASA ephemerides for Solar System planets","text":"<p>Before considering other bodies, let's consider the Solar System planets. As from the intallation guide, one should have the following structure in the local directory:</p> <pre><code>local-folder/\n\u251c\u2500\u2500 ASTRA\n\u251c\u2500\u2500 MICE_TOOLBOX/\n    \u251c\u2500\u2500 mice/\n        \u251c\u2500\u2500 Kernel/\n            \u251c\u2500\u2500 de430.bsp\n            \u251c\u2500\u2500 gm_de431.tpc\n            \u251c\u2500\u2500 mar097.bsp\n            \u251c\u2500\u2500 naif0012.tls\n            \u251c\u2500\u2500 pck00010.tpc\n            \u2514\u2500\u2500 sat375.bsp\n        \u2514\u2500\u2500 mice\n\u251c\u2500\u2500 clearDeleteAdd.m\n\u2514\u2500\u2500 main_script.m\n</code></pre> <p>The <code>main_script.m</code> is the one we want to modify (see, for example the tutorial on trips to Jupiter or this script).</p> <p>After having set-up all the input and the ASTRA environment, one needs to load the NASA ephemerides. This can be done by imposing that:</p> <pre><code>% --&gt; load MICE toolbox\nMICE_path = './MICE_TOOLBOX' ;\naddpath(genpath(MICE_path)); % --&gt; always include this\ncspice_furnsh([MICE_path '/data.mk']);\n</code></pre> <p>In this way, one loads the kernels for planetary ephemerides. This is not sufficient. One needs to tell ASTRA which ephemerides it should use. The default ones are encoded in the script EphSS_cartesian.m. To overwrite those, one can simply set:</p> <pre><code>INPUT.customEphemerides = @EphSS_from_mice;\n</code></pre> <p>In particular, the function EphSS_from_mice.m allows to automatically use the NASA ephemerides.</p> <p>That's it. </p> <p>Then one can launch an optimization for the EVEMEJ similar to the tutorial on trips to Jupiter. Obviously, the two optimizations should provide very similar result:</p> <ul> <li>the one with approximate ephemerides has a minimum cost of: 8.94774 km/s and 6.45038 years</li> <li>the one with NASA ephemerides has a minimum cost of: 8.95409 km/s  and 6.45038 years</li> </ul> <p>which indeed are very close. Thus, if one needs to plan missions to any of the Solar System planet, the approximate ephemerides are suggested, as these are quite faster to compute with respect to high-precision ones.</p> <p>BUG DETECTED: currently, high-precision NASA ephemerides prevent ASTRA to be run in parallel mode when resonances are present in the sequence. A workaround to this is shown later, but a rearchitect is needed. This will be solved in the next update...</p>"},{"location":"nasa_ephemerides/#integrating-nasa-ephemerides-for-small-objects","title":"Integrating NASA ephemerides for small objects","text":"<p>A very interesting application for integrating NASA ephemerides into ASTRA is when one needs to plan missions to Solar System objects that are not planets (asteroids and/or comets). This opens a very wide range of possibilities in terms of mission design.</p> <p>If one has properly set-up the MICE toolbox as from the intallation guide, then the only thing that remains to do is to download the <code>.bsp</code> file containing the ephemerides of the desired object. The script download_nasa_ephemerides.m shows how to do it and the steps are reported here.</p> <p>As always, one needs to add ASTRA and MICE_TOOLBOX to the path:</p> <pre><code>% --&gt; load ASTRA\nclearDeleteAdd; % --&gt; !!! ONLY CALL IT ONCE FOR SPEED\n\n% --&gt; load mice\nMICE_path = './MICE_TOOLBOX';\naddpath(genpath(MICE_path)); % --&gt; always include this\ncspice_furnsh([MICE_path '/data.mk']);\n</code></pre> <p>Then, one selects the central body, and the time-span for the ephemerides validity:</p> <pre><code>% --&gt; central ID (Sun in this case)\nidcentral = 1;\n\n% --&gt; lower and upper bounds for ephemerides\nt0 = [ 2030 1 1 12 0 0 ];\ntf = [ 2100 1 1 12 0 0 ];\n</code></pre> <p>One now needs the SPKID of the object (in this case a comet is used):</p> <pre><code>% --&gt; SPKID of the object (found at https://ssd.jpl.nasa.gov/tools/sbdb_lookup.html#/)\nspk_id = 1000508;\n</code></pre> <p>SPKID of small bodies can be found at NASA Small Body Database Lookup page.</p> <p>One finally specifies the folder where the file should be downloaded (default path is used here):</p> <pre><code>% --&gt; set the path where to save the ephemerides\nspk_dir = pwd;\n</code></pre> <p>and finally one can call the NASA API:</p> <pre><code>% --&gt; run the code (if success=1 then everything is okay)\nsuccess = getSPK(num2str(spk_id), num2str(t0), num2str(tf), spk_dir, 'overwrite', 'on');\n</code></pre> <p>If everything is set-up properly, then one should have a file called <code>1000508.bsp</code> in the specified target folder.</p> <p>ASTRA is now ready to be run with the newly-generated ephemerides. The set-up is very similar as before. The desired comet has now ID that is <code>1000508</code> and thus the ASTRA set-up will be like:</p> <pre><code>% --&gt; sequence to be optimized\nINPUT.idcentral = 1; % --&gt; central body (Sun in this case)\n\nseq = [ 3 2 3 3 1000508 ]; res = [ 2 1 3 ];\n\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\nmaxrev                        = 1;                                                          % --&gt; max. number of revolutions (round number)\nchosenRevs                    = differentRuns_v2(seq, maxrev);                              % --&gt; generate successive runs\n[INPUT.chosenRevs, INPUT.res] = processResonances(chosenRevs, res);                         % --&gt; process the resonances options\n[INPUT.chosenRevs]            = maxRevOuterPlanets(seq, INPUT.chosenRevs, INPUT.idcentral); % --&gt; only zero revs. on outer planets\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\n\n%%%%%%%%%% set departing options %%%%%%%%%%\nt0 = date2mjd2000([2030 1 1 12 0 0]); % --&gt; initial date range (MJD2000)\ntf = t0 + 5*365.25;                  % --&gt; final date range (MJD2000)\ndt = 3;                            % --&gt; step size (days)\nINPUT.depOpts = [t0 tf dt];\n%%%%%%%%%% set departing options %%%%%%%%%%\n\n%%%%%%%%%% set options %%%%%%%%%%\nINPUT.opt      = 4;          % --&gt; (1) is for SODP, (2) is for MODP, (3) is for DATES - SODP, (4) is for YEARS - MODP\nINPUT.vInfOpts = [0 5];      % --&gt; min/max departing infinity velocities (km/s)\nINPUT.dsmOpts  = [1 Inf];    % --&gt; max defect DSM, and total DSMs (km/s)\nINPUT.plot     = [1 1];      % --&gt; plot(1) for Pareto front, plot(2) for best traj. DV\nINPUT.parallel = false;       % --&gt; put true for parallel, false otherwise\nINPUT.tstep    = dt;         % --&gt; step size for Time of flight            \n%%%%%%%%%% set options %%%%%%%%%%\n</code></pre> <p>Finally, one loads the ephemerides of the comet:</p> <pre><code>% --&gt; load custom ephemerides\nMICE_path = './MICE_TOOLBOX';\naddpath(genpath(MICE_path)); % --&gt; always include this\ncspice_furnsh([MICE_path '/data.mk']);\n\nspk_dir = [];           % --&gt; location of the bsp file with object ephemerides (if empty, then the current directory is used)\ncspice_furnsh([ pwd '\\' spk_dir '\\' num2str(max(seq)) '.bsp']); % --&gt; load the object ephemerides\n</code></pre> <p>As before, the ephemerides as passed to ASTRA as:</p> <pre><code>INPUT.customEphemerides = @EphSS_from_mice_workaround;\n</code></pre> <p>Please, note that in this case the ephemerides are loaded with a workaround to prevent the aforementioned bug to appear. Basically, EphSS_from_mice_workaround.m loads the approximate positions of the planets (that are proved to work well for planets), thus avoiding the bug, while for the desired object it uses the NASA kernels.</p> <p>One notices here that a scan of 5 years is set-up for this specific example, and thus one has that <code>INPUT.opt=4</code> (i.e., every year, multi-objective dynamic programming is used).</p>"},{"location":"nasa_ephemerides/#performing-asteroid-fly-bys-with-nasa-ephemerides-in-astra","title":"Performing asteroid fly-bys with NASA ephemerides in ASTRA","text":"<p>It has to be said that one can also write sequences of objects that simulate asteroids fly-bys. In this case, ASTRA will consider them as massless points in space (so zero sphere of influence). </p> <p>Let's take the following example. </p> <pre><code>% --&gt; clear INPUT and define new ones\ntry clear INPUT; catch; end; clc;\n\n% --&gt; sequence to be optimized\nINPUT.idcentral = 1; % --&gt; central body (Sun in this case)\nseq = [ 3 2 3 3 20348435 5 ]; res = [ 2 1 3 ];\n\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\nmaxrev                        = 1;                                                          % --&gt; max. number of revolutions (round number)\nchosenRevs                    = differentRuns_v2(seq, maxrev);                              % --&gt; generate successive runs\n[INPUT.chosenRevs, INPUT.res] = processResonances(chosenRevs, res);                         % --&gt; process the resonances options\n[INPUT.chosenRevs]            = maxRevOuterPlanets(seq, INPUT.chosenRevs, INPUT.idcentral); % --&gt; only zero revs. on outer planets\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\n\n%%%%%%%%%% set departing options %%%%%%%%%%\nt0 = date2mjd2000([2037 1 1 0 0 0]); % --&gt; initial date range (MJD2000)\ntf = t0 + 1*365.25;                  % --&gt; final date range (MJD2000)\ndt = 2.5;                            % --&gt; step size (days)\nINPUT.depOpts = [t0 tf dt];\n%%%%%%%%%% set departing options %%%%%%%%%%\n\n%%%%%%%%%% set options %%%%%%%%%%\nINPUT.opt      = 2;          % --&gt; (1) is for SODP, (2) is for MODP, (3) is for DATES, (4) is for YEARS - MODP\nINPUT.vInfOpts = [0 5];      % --&gt; min/max departing infinity velocities (km/s)\nINPUT.dsmOpts  = [1 Inf];    % --&gt; max defect DSM, and total DSMs (km/s)\nINPUT.plot     = [1 1];      % --&gt; plot(1) for Pareto front, plot(2) for best traj. DV\nINPUT.parallel = true;       % --&gt; put true for parallel, false otherwise\nINPUT.tstep    = dt;         % --&gt; step size for Time of flight            \n%%%%%%%%%% set options %%%%%%%%%%\n\n%%\n\n% --&gt; load custom ephemerides\nMICE_path = './MICE_TOOLBOX';\naddpath(genpath(MICE_path)); % --&gt; always include this\ncspice_furnsh([MICE_path '/data.mk']);\n\nspk_dir = [];           % --&gt; location of the bsp file with object ephemerides\n\nfor inds = 1:length(seq)\n    if seq(inds) &gt; 9\n        cspice_furnsh([ pwd '\\' spk_dir '\\' num2str(seq(inds)) '.bsp']); % --&gt; load the object ephemerides\n    end\nend\n\nINPUT.customEphemerides = @EphSS_from_mice_workaround;\n\n%% --&gt; optimize using ASTRA\n\n% --&gt; launch ASTRA optimization\nOUTPUT = ASTRA_DP(seq, INPUT);\n</code></pre> <p>This considers an EVEEJ transfer with a fly-by with asteroid 20348435 (348435 (2005 QM35)) on the EJ leg, and a 2:1 resonance on the 3rd leg (i.e., on the EE one), and launching in 2037. The resulting sequence thus looks like the following:</p> <pre><code>seq = [ 3 2 3 3 20348435 5 ]; res = [ 2 1 3 ];\n</code></pre> <p>In this case, ASTRA considers that the asteroids has null mass (i.e., zero sphere of influence), and the fly-by is performed at the arbitrary altitude of 1000 km. The prerequisite is to have the <code>.bsp</code> file of the object in the current working directory, as shown in the previous section.</p> <p>The following plot shows the resulting optimal trajectory. One notices the fly-by with the desired object on the EJ leg.</p> <p></p>"},{"location":"trips_to_jupiter/","title":"Trips to Jupiter","text":"<p>This tutorial allows to run a simple test script with ASTRA for a mission towards Jupiter. Different sequences will be optimized, just to see different options for ASTRA.</p>"},{"location":"trips_to_jupiter/#earth-venus-earth-mars-earth-jupiter","title":"Earth-Venus-Earth-Mars-Earth-Jupiter","text":"<p>First sequence to analyse is the Earth-Venus-Earth-Mars-Earth-Jupiter (EVEMEJ), that has been considered for JUICE mission.</p> <p>This tutorial is based on this script. This allows to optimize the sequence either with SODP (single-objective dynamic programming) or with MODP (multi-objective dynamic programming). A breakdown of the minimum input parameter needed is provided here.</p> <p>From this script, one needs to call ASTRA and building the mex functions (namely Lambert solver, defects function, and low-thrust module):</p> <pre><code>clearDeleteAdd;\n</code></pre> <p>Then one proceeds to select appropriate input parameters.</p> <pre><code>%% --&gt; input section\n\n% --&gt; clear INPUT and define new ones\ntry clear INPUT; catch; end; clc;\n\n% --&gt; sequence to be optimized\nINPUT.idcentral = 1; \nseq = [ 3 2 3 4 3 5 ]; res = [ ];\n\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\nmaxrev                        = 0;                                         % --&gt; max. number of revolutions (round number)\nchosenRevs                    = differentRuns_v2(seq, maxrev);             % --&gt; generate successive runs\n[INPUT.chosenRevs, INPUT.res] = processResonances(chosenRevs, res);        % --&gt; process the resonances options\n[INPUT.chosenRevs]            = maxRevOuterPlanets(seq, INPUT.chosenRevs); % --&gt; only zero revs. on outer planets\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\n\n%%%%%%%%%% set departing options %%%%%%%%%%\nt0 = date2mjd2000([2023 1 1 0 0 0]); % --&gt; initial date range for launch (MJD2000)\ntf = t0 + 1*365.25;                  % --&gt; final date range for launch (MJD2000)\ndt = 2.5;                            % --&gt; step size in launch window (days)\nINPUT.depOpts = [t0 tf dt];\n%%%%%%%%%% set departing options %%%%%%%%%%\n\n%%%%%%%%%% set options %%%%%%%%%%\nINPUT.opt      = 2;          % --&gt; (1) is for SODP, (2) is for MODP, (3) is for DATES, (4) is for YEARS - MODP\nINPUT.vInfOpts = [3 5];      % --&gt; min/max departing infinity velocities (km/s)\nINPUT.dsmOpts  = [2 Inf];    % --&gt; max defect DSM, and total defects DSMs (km/s)\nINPUT.plot     = [0 0];      % --&gt; plot(1) for Pareto front, plot(2) for best traj. DV\nINPUT.parallel = true;       % --&gt; put true for parallel, false otherwise\nINPUT.tstep    = dt;         % --&gt; step size for Time of flight            \n%%%%%%%%%% set options %%%%%%%%%%\n</code></pre> <p>Things to notice are:</p> <ul> <li> <p><code>INPUT.idcentral</code> allows to select the system. In this example, <code>INPUT.idcentral = 1</code> means that Solar System is selected. Other options are:</p> <ul> <li>5 for Jupiter system</li> <li>6 for Saturn system</li> <li>7 for Uranus system. See also constants.m for knowing about the IDs of the bodies.</li> </ul> </li> <li> <p><code>maxrev</code> is the number of revolutions for Lambert arcs. ASTRA computes all the possible permutations of revolutions per leg (both long and short option) up to the maximum desired by the user.</p> </li> <li><code>maxRevOuterPlanets</code> will prune options with more than one rev. on legs towards outer planets (i.e., from Jupiter on). This to prevent the mission duration to increase a lot.</li> <li><code>res</code> is a list of integers with <code>[ N, M, LEG_ID ]</code>, where <code>N</code> and <code>M</code> are the object and spacecraft revolutions, respectively, and <code>LEG_ID</code> is the number of the leg at which the resonance is. In this case, it is empty as no resonances are included in the transfer. Later, an example will be shown.</li> <li><code>INPUT.opt</code> selects the type of optimization. </li> <li><code>1</code> is for SODP</li> <li><code>2</code> is for MODP</li> <li><code>3</code> is for SODP run each launch date. </li> <li><code>4</code> is for MODP run each launch year. If the user selects a launch window greater or equal than 3 year AND <code>INPUT.opt=2</code>, this option is selected automatically. This allows to reduce the computational burden in terms of RAM.</li> </ul> <p>The options defined above allow for an MGA trajectory search of <code>Earth-Venus-Earth-Mars-Earth-Jupiter</code> mission in year <code>2023</code> using MODP (<code>INPUT.opt=2</code>).</p> <p>ASTRA main engine can then be run using:</p> <pre><code>%% --&gt; optimize using ASTRA\n\n% --&gt; launch ASTRA optimization\nOUTPUT = ASTRA_DP(seq, INPUT);\n</code></pre> <p>Results are saved in a structure called <code>OUTPUT</code>.</p> <p>If needed, one can then post-process the results, extracting the desired trajectory from the Pareto front, plotting the Pareto front itself and the selected path.</p> <pre><code>% --&gt; process the OUTPUT\nprocessed_OUTPUT = postProcessOutputASTRA( OUTPUT );\n\n% --&gt; process the output for better user experience\nparetoFront = process_paretoFront_structure( INPUT, processed_OUTPUT );\n</code></pre> <p>Specfically, the structure <code>paretoFront</code> has all the relevant information about the trajectories on the Pareto front that are easily interpretable. In particular, the default objective functions to be minimized and represented in the plots are:</p> <ul> <li>overall $ \\Delta v$ consumption (that is the departing infinity velocity $ v_{\\infty,dep} $, sum of defects and arrival infinity velocity $ v_{\\infty,arr}$)</li> <li>overall time of flight</li> </ul> <p>Custom objective functions can also be included as shown in another tutorial.</p> <p>Once the pareto front is extracted, one can plot it:</p> <pre><code>% --&gt; plot the Pareto front\nfigPareto = plotPareto(processed_OUTPUT.PARETO_FRONT);\n</code></pre> <p></p> <p>A specific trajectory (variable <code>path</code> in the <code>paretoFront</code> structure) can also be extracted and plotted.</p> <pre><code>row  = length(paretoFront);   % --&gt; select the path to plot (minimum DV in this specific example)\npath = paretoFront(row).path;\nrevs = paretoFront(row).revs;\nres  = paretoFront(row).res;\n\n% --&gt; plot the path\n[figECI, STRUC, figSYN, figRSC, figVSC] = plotPath(path, INPUT.idcentral);\n</code></pre> <p>The plot of the optimal trajectory in inertial and Earth-Sun synodic frame is the following:</p> <p>The function plotPath.m also allows to plot the evolutions of spacecraft distance and velocity with respect to central body:</p> <p>The function generateOutputTXT.m creates a .txt file in a folder called <code>./results</code> that has all the info of the trajectory.</p> <pre><code>% --&gt; save the output\ngenerateOutputTXT(path, INPUT.idcentral, ...\n    @EphSS_cartesian, ...\n    '/target_folder', ...\n    'name_of_the_file');\n</code></pre> <p>This is reported here:</p> <pre><code>\n          _/_/_/     _/_/_/  _/_/_/_/_/  _/_/_/    _/_/_/ \n        _/    _/   _/           _/     _/    _/  _/    _/ \n       _/_/_/_/     _/_/       _/     _/_/_/    _/_/_/_/  \n      _/    _/         _/     _/     _/    _/  _/    _/   \n     _/    _/    _/_/_/      _/     _/    _/  _/    _/    \n\n\n               - ASTRA solution - \n\n-------------------------------------------------------------- \n\nDeparting body                 : Earth  \nDistance from the central body : 1.0000 AU \n\n-------------------------------------------------------------- \n\nArrival body                   : Jupiter\nDistance from the central body : 5.2026 AU \nDeparting C3                   : 9.9710 km^2/s^2 \nDeparting infinity velocity    : 3.1577 km/s \nArrival infinity velocity      : 5.5622 km/s \nTotal cost (DSMs)              : 0.2279 km/s \nTotal cost                     : 8.9477 km/s \nTime of flight                 : 6.4504 years \n\n-------------------------------------------------------------- \n\nMGA Details : \n\nSwing-by sequence      : -E--V--E--M--E--J-\n\nDeparting date         : [2023   5  25   0   0   0]\nArrival date           : [2029  11   5   0   0   0]\nTime of flight per leg : 149 days \n                         314 days \n                         164 days \n                         653 days \n                         1076 days \n\nDSMs magnitudes        : 0 km/s \n                         0 km/s \n                         0.0435 km/s \n                         0.175 km/s \n                         0.0030602 km/s \n                         0.0062967 km/s \n\nInfinity velocities    : \nEarth   - Venus        : 3.1577 - 5.491 km/s \nVenus   - Earth        : 5.5345 - 8.6843 km/s \nEarth   - Mars         : 8.8594 - 9.9807 km/s \nMars    - Earth        : 9.9837 - 11.356 km/s \nEarth   - Jupiter      : 11.3497 - 5.5622 km/s \n\nState at departure/arrival (km and km/s) : \nEarth                         : [-67443219.33399     -135660718.6523                   0        24.241512589      -11.7048292755      1.836903188908]  \nVenus                         : [37311161.50828      101201436.6601     -794434.8182506     -35.16859904353      13.90789291013     -2.571549670311]  \n\nVenus                         : [37311161.50828      101201436.6601     -794434.8182506     -38.11916712221      12.05366801041    0.02734636620768]  \nEarth                         : [139172686.8417     -58704309.11459                   0      2.765219554958      29.78400878435    -0.2102630162746]  \n\nEarth                         : [139172686.8417     -58704309.11459                   0      6.581015760611      34.63293925256       2.19921939779]  \nMars                          : [-149676335.9057      195136449.5053      7760204.399362     -23.46960002881     -4.185823816296    -0.8280693030055]  \n\nMars                          : [-149676335.9057      195136449.5053      7760204.399362     -22.68651649801     -3.708904715841     0.6440840164211]  \nEarth                         : [67683770.4888      131263396.4678                   0     -25.22025731172      24.69727827743      1.176764665526]  \n\nEarth                         : [67683770.4888      131263396.4678                   0     -30.54695793792      24.14446259252       1.85752423869]  \nJupiter                       : [-638295113.4513     -502726641.4791      16376543.69961      4.808110564511     -5.055217205055    -0.3203290652118]  \n\nEncounter dates        : \nEarth                  : [2023   5  25   0   0   0]\nVenus                  : [2023  10  21   0   0   0]\nEarth                  : [2024   8  30   0   0   0]\nMars                   : [2025   2  10   0   0   0]\nEarth                  : [2026  11  25   0   0   0]\nJupiter                : [2029  11   5   0   0   0]\n\nTransfer types         : \nEarth   - Venus        : inbound - outbound \nVenus   - Earth        : inbound - inbound \nEarth   - Mars         : inbound - outbound \nMars    - Earth        : outbound - outbound \nEarth   - Jupiter      : outbound - inbound \n\n-------------------------------------------------------------- \n</code></pre> <p>Finally, one can further refine the solution around a specified trajectory, to further reduce the defects that might arise:</p> <pre><code>%% --&gt; futher refine around the optimal DV-solution\n\nINPUT.t0days  = 10;   % --&gt; days around current solution departing epoch\nINPUT.tofdays = 15;   % --&gt; days around current solution TOFs\nINPUT.dt      = 0.5;  % --&gt; step size (days)\nINPUT.revs    = revs;\nINPUT.res     = res;\n\n% --&gt; further refine using ASTRA\nOUTPUTref           = refineUsingASTRApath(path, INPUT);\nprocessed_OUTPUTref = postProcessOutputASTRA( OUTPUTref );\nparetoFrontref      = process_paretoFront_structure( INPUT, processed_OUTPUTref );\n</code></pre> <p>It is always suggested to run this second step as one might use coarse grids as initial optimization. In this specific example one has that:</p> <ul> <li>minimum cost function before the refinement is: 8.94774 km/s and 6.450376 years</li> <li>mimimum cost functions after the refinement are: 8.85087 km/s and 6.46407 years</li> </ul> <p>so the refinement actually helped at the price of slightly increased transfer time.</p>"},{"location":"trips_to_jupiter/#earth-venus-earth-earth-jupiter","title":"Earth-Venus-Earth-Earth-Jupiter","text":"<p>This second tutorial is very similar to the one above. The main difference is that one uses a resonant transfer in the Earth-Earth leg.</p> <p>The only difference with the script above is:</p> <pre><code>seq = [ 3 2 3 3 5 ];   res = [ 2 1 3 ];\n</code></pre> <p>where <code>res</code> now specifies <code>[2 1 3]</code>, i.e., 2:1 resonance on the 3rd leg. If multiple resonances are needed, one specifies it via: </p> <ul> <li><code>res = [N, M, LEG_ID_1, N, M, LEG_ID_1]</code> and so on...</li> </ul> <p>The same input as before are used. The results are reported below. One notices the resonant leg, on which the trajectory returns back at Earth at the same position of the planet on its orbit after 2 orbital periods (2:1 resonance).</p> <p></p>"},{"location":"trips_to_jupiter/#earth-venus-earth-mars-mars-mars-jupiter","title":"Earth-Venus-Earth-Mars-Mars-Mars-Jupiter","text":"<p>This last script is just to show consecutive resonant legs setup in ASTRA. Specifically, 2:1 and 3:1 resonant ratios are used in successive Mars-Mars legs.</p> <p>Again, the only things that change are:</p> <pre><code>seq = [ 3 2 3 4 4 4 5 ];   res = [ 2 1 4 3 1 5 ];\n</code></pre> <p>as well as the maximum number of revolutions (set to 1 in this case):</p> <pre><code>%%%%%%%%%% multi-rev. options %%%%%%%%%%\nmaxrev                        = 1;                                         % --&gt; max. number of revolutions (round number)\nchosenRevs                    = differentRuns_v2(seq, maxrev);             % --&gt; generate successive runs\n[INPUT.chosenRevs, INPUT.res] = processResonances(chosenRevs, res);        % --&gt; process the resonances options\n[INPUT.chosenRevs]            = maxRevOuterPlanets(seq, INPUT.chosenRevs); % --&gt; only zero revs. on outer planets\n%%%%%%%%%% multi-rev. options %%%%%%%%%%\n</code></pre> <p>To speed up the process, one can set the maximum defect equal to 1 km/s instead of 2 km/s, with limited degradation in the Pareto front:</p> <pre><code>INPUT.dsmOpts  = [1 Inf];    % --&gt; max defect DSM, and total defects DSMs (km/s)\n</code></pre> <p>Below the results are shown.</p> <p></p>"},{"location":"matlab/","title":"MATLAB Functions","text":"<p>Browse the automatically generated documentation:</p> <ul> <li>Astrodynamics/</li> <li>Astrodynamics conversions/<ul> <li>M2theta</li> <li>RTNtoECI</li> <li>car2Spherical</li> <li>car2VinfBplane</li> <li>car2kep</li> <li>car2mee</li> <li>eci2synodic_eph</li> <li>kep2car</li> <li>kep2mee</li> <li>kepler2MEOE</li> <li>mee2car</li> <li>mee2kep</li> <li>spherical2Car</li> <li>theta2M</li> <li>vinfBplane2car</li> <li>wrapECI2Synodic_SE</li> </ul> </li> <li>Basic Transfers/<ul> <li>hohmann_transfer</li> <li>rocketEq_givenDV</li> <li>rocketEq_givenFinalMass</li> </ul> </li> <li>Conics/<ul> <li>Vinf2Hyperbola</li> <li>apses_velocities</li> <li>deltaV_hyperbola</li> <li>hill_radius</li> <li>hyperbola_peri_time</li> <li>sphere_of_influence</li> <li>vinfBplane2Hyperbola</li> </ul> </li> <li>Propagation/<ul> <li>FGCar_dt</li> <li>FGKepler_dt</li> <li>kepEq_t</li> <li>propagateKepler</li> <li>propagateKepler_tof</li> </ul> </li> <li>Time conversions/<ul> <li>date2jd</li> <li>date2mjd2000</li> <li>datetime_string_to_mjd2000</li> <li>datetime_string_to_vector</li> <li>fracday2hms</li> <li>hms2fracday</li> <li>jd2date</li> <li>jd2mjd2000</li> <li>mjd20002date</li> <li>mjd20002jd</li> <li>mjd20002mjd</li> <li>mjd2date</li> <li>mjd2jd</li> <li>mjd2mjd2000</li> </ul> </li> <li>Cost functions/</li> <li>MODP/<ul> <li>costFunction1_MODP</li> <li>costFunction2_MODP</li> <li>custom/</li> <li>costFunction1_MODP_vdep</li> <li>costFunction2_MODP_vdep_varr</li> </ul> </li> <li>SODP/<ul> <li>costFunction1_DP</li> <li>costFunction2_DP</li> <li>custom/</li> <li>costFunction1_DP_custom</li> <li>costFunction1_DP_custom_vdep</li> <li>costFunction2_DP_custom</li> <li>costFunction2_DP_custom_vdep_varr</li> </ul> </li> <li>Dynamic programming/</li> <li>ASTRA_DP</li> <li>ASTRA_MODP_v2</li> <li>ASTRA_SODP_v2</li> <li>ASTRA_dates</li> <li>ASTRA_wrapPath_DP</li> <li>ASTRA_years</li> <li>ASTRA_years_sodp</li> <li>DP functions/<ul> <li>wrap_DynProgr_st1</li> <li>wrap_DynProgr_st2</li> </ul> </li> <li>refineUsingASTRApath</li> <li>wrap_MODP_st2</li> <li>Ephemerides &amp; constants/</li> <li>Eph_MICE_interface/<ul> <li>EphSS_from_mice</li> <li>EphSS_from_mice_workaround</li> <li>getSPK</li> <li>processDate</li> </ul> </li> <li>Jupiter system/<ul> <li>approxEphemJupMoons_cc</li> <li>jupMoonsConstants</li> </ul> </li> <li>Saturn system/<ul> <li>approxEphemSatMoons_cc</li> <li>satMoonsConstants</li> </ul> </li> <li>Solar System/<ul> <li>EphSS_car</li> <li>EphSS_cartesian</li> <li>Other bodies/</li> <li>EphCA_car</li> <li>EphCE_car</li> <li>EphLOWq</li> <li>EphLutetia</li> <li>planetConstants</li> <li>uplanet</li> </ul> </li> <li>Uranus system/<ul> <li>approxEphemUraMoons_cc</li> <li>uranusMoonsConstants</li> </ul> </li> <li>approxEphem_CC</li> <li>astroConstantsj2000</li> <li>constants</li> <li>generateEPH</li> <li>generateMAT</li> <li>maxmin_flybyAltitude</li> <li>planet_names_GA</li> <li>wrap_generateEPH</li> <li>Lambert problem and defects/</li> <li>findDV</li> <li>lambertMR_MEXIFY</li> <li>maxRev_LP</li> <li>Low thrust/</li> <li>Plot_low_thrust/<ul> <li>plotLT</li> <li>plotLT_Th</li> <li>wrapPlotLTFull</li> </ul> </li> <li>Processing_low_thrust/<ul> <li>postProcessLT</li> <li>postProcessPathASTRA_lowThrust</li> <li>processDataAndWriteParam</li> <li>writeParamLT</li> </ul> </li> <li>Propagation_optimal_control/<ul> <li>propagateEopt_MEXIFY</li> <li>propagateFopt_MEXIFY</li> <li>propagateState_vA</li> </ul> </li> <li>lowThrustFromASTRASolution</li> <li>wrapSolveFopt</li> <li>Pareto front/</li> <li>paretoFront</li> <li>paretoFront_MODP</li> <li>Plot and save/</li> <li>generateOutputSequenceTXT</li> <li>generateOutputTXT</li> <li>plotPLTS_tt</li> <li>plotPareto</li> <li>plotPath</li> <li>saveOUTPUT_MODP</li> <li>saveOUTPUT_SODP</li> <li>Processing/</li> <li>fromSeq2Legs</li> <li>generateDiffRuns</li> <li>numberOfDefects</li> <li>path2Vinfs</li> <li>planetIdToName</li> <li>postProcessOutputASTRA</li> <li>process_paretoFront_structure</li> <li>seq2SeqName</li> <li>transferTypes</li> <li>Pruning/</li> <li>check_ISNAN_DP</li> <li>prune_DEFECT_DP</li> <li>prune_DEFECTtot_DP</li> <li>prune_TOFY_tot</li> <li>prune_VINF_DP</li> <li>prune_VINFn_DP</li> <li>wrap_Pruning_DP</li> <li>wrap_Pruning_DP_st1</li> <li>Resonances/</li> <li>checkResonance_DP</li> <li>constructResonantOrbits_DP</li> <li>wrapConstructionResonance_DP</li> <li>Revolutions options/</li> <li>maxRevOuterPlanets</li> <li>permn</li> <li>processResonances</li> <li>rev2RevOpt</li> <li>Time of flight options/</li> <li>TOF_per_LEGS_ASTRA</li> <li>tofGeneration_v2</li> <li>wrap_TOFs</li> <li>astra_optimization/</li> <li>crossFast</li> <li>findFlyby_TE</li> <li>maxMinPeriAltitude</li> <li>mga_nDSM_customEph</li> <li>minMaxDVS</li> <li>minMaxEps</li> <li>minMaxFirstMan</li> <li>optPSO</li> <li>path2FlybyParam</li> <li>postProcessPathASTRA_dsm_lowThrust</li> <li>revs2NmanLeg</li> <li>swingby_vA</li> <li>tnh2car</li> <li>v02dv1</li> <li>wrap_mga_nDSM</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/M2theta/","title":"<code>M2theta</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/M2theta/#description","title":"DESCRIPTION","text":"<p>Conversion from mean anomaly to true anomaly for keplerian orbits. Also works for hyperbolic paths. Newton method is used.</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/M2theta/#input","title":"INPUT","text":"<ul> <li>M : mean anomaly</li> <li>e : eccentricity</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/M2theta/#output","title":"OUTPUT","text":"<ul> <li>theta :true anomaly [rad]</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/M2theta/#function-signature","title":"Function Signature","text":"<pre><code>[theta] = M2theta(M, e)\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/RTNtoECI/","title":"<code>RTNtoECI</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/RTNtoECI/#description","title":"DESCRIPTION","text":"<p>This function converts a vector from the RTN (Radial, Transverse, Normal) frame to the ECI (Earth-Centered Inertial) frame by constructing the transformation matrix based on the input position and velocity vectors.</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/RTNtoECI/#input","title":"INPUT","text":"<ul> <li>rr : Position vector in the ECI frame (3x1 vector).</li> <li>vv : Velocity vector in the ECI frame (3x1 vector).</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/RTNtoECI/#output","title":"OUTPUT","text":"<ul> <li>rtn2eci : 3x3 transformation matrix to convert a vector from the RTN frame to the ECI frame.</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/RTNtoECI/#function-signature","title":"Function Signature","text":"<pre><code>[rtn2eci] = RTNtoECI(rr,vv)\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2Spherical/","title":"<code>car2Spherical</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2Spherical/#description","title":"DESCRIPTION","text":"<p>Spherical coordinates (r, th, phi) to position vector (pos_x, pos_y, pos_z).</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2Spherical/#input","title":"INPUT","text":"<ul> <li>cart : position vector (pos_x, pos_y, pos_z)</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2Spherical/#output","title":"OUTPUT","text":"<ul> <li>spherical : 1x3 spherical coordinates such that :</li> <li>spherical(1) is the radius</li> <li>spherical(2) is the azimuth</li> <li>spherical(3) is the elevation</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2Spherical/#function-signature","title":"Function Signature","text":"<pre><code>[spherical] = car2Spherical( cart )\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2VinfBplane/","title":"<code>car2VinfBplane</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2VinfBplane/#description","title":"DESCRIPTION","text":"<p>This function computes the B-plane elements from cartesian elements.</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2VinfBplane/#input","title":"INPUT","text":"<ul> <li>cart      : 1x6 vector with (pos_x, pos_y, pos_z, vel_x, vel_y, vel_z) in [km] and [km/s]</li> <li>mu_planet : gravitational parameter of the planet [km3/s2]</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2VinfBplane/#output","title":"OUTPUT","text":"<ul> <li>vinf_bplane_params : 1x6 vector with the following parameters</li> <li>vinf_mag        = vinf_bplane_params(1) magnitude of infinity velocity [km/s]</li> <li>right_ascension = vinf_bplane_params(2) right ascension of the infinity velocity vector [rad]</li> <li>declination     = vinf_bplane_params(3) declination of the infinity velocity vector [rad]</li> <li>bt              = vinf_bplane_params(4) BT component of the B-vector [km]</li> <li>br              = vinf_bplane_params(5) BR component of the B-vector [km]</li> <li>th              = vinf_bplane_params(6) true anomaly along the hyperbola [rad]</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2VinfBplane/#function-signature","title":"Function Signature","text":"<pre><code>[vinf_bplane_params] = car2VinfBplane( cart, mu_planet )\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2kep/","title":"<code>car2kep</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2kep/#input","title":"INPUT:","text":"<p>in[6]       State vector in cartesian coordinates (position [L], velocity [L/T]). mu          Planetary gravity constant [L^3/(M*T^2)].</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2kep/#output","title":"OUTPUT:","text":"<p>kep[1,6]    Vector of Keplerian elements: kep = [a, e, i, Om, om, th], where theta is the true anomaly. a in [L], 0 &lt;= i  &lt;= pi   [rad] 0 &lt;= Om &lt;  2pi [rad] 0 &lt;= om &lt;  2pi [rad] 0 &lt;= th &lt;  2pi [rad]. p           Parameter [L]. E           Eccentric anomaly, hyperbolic anomaly or parabolic anomaly (for definitions see Vallado pag. 49). M           Mean anomaly [rad]. dt          Time from the pericentre passage [T]. Threshold on eccentricity for considering the orbit to be circular Value determined comparing the relative error on state and position between using the circular case and the elliptic case. With this elimit the relative error on position and velocity is always less then 1e-7. Angular momentum vector: h = cross(r,v) Inclination Line of nodes vector % n = cross([0 0 1],h); % Normalisation of nv to 1: n = n/norm(n) %                           n = n/sqrt(n(1)^2+n(2)^2+n(3)^2); % Arbitrary choice of n warning('spaceToolbox:car2kep:planarOrbit','Planar orbit. Arbitrary choice of Omega = 0.'); Argument of the ascending node Parameter Eccentricity vector: ev = 1/mucross(v,h) - r/nr ev  = 1/mu[v(2)h(3)-v(3)h(2),v(3)h(1)-v(1)h(3),v(1)h(2)-v(2)*h(1)] - r/nr; Argument of the pericentre % Arbitrary eccentricity vector Semi-major axis True anomaly: acos(dot(ev,r)/ne/nr); % the condition dot(r,cross(h,ev)) &lt; 0 works in the same way</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2kep/#function-signature","title":"Function Signature","text":"<pre><code>[kep] = car2kep(in,mu)\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2mee/","title":"<code>car2mee</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2mee/#description","title":"DESCRIPTION","text":"<p>This function converts Cartesian state vectors into Modified Equinoctial Elements (MEE). It first converts position and velocity vectors into Keplerian orbital elements, and subsequently transforms those into MEE. The MEE representation avoids singularities for zero inclination and eccentricity, making it suitable for a wide range of orbital regimes.</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2mee/#input","title":"INPUT","text":"<ul> <li>car : Cartesian state vector [rx, ry, rz, vx, vy, vz], where r = position vector [km] v = velocity vector [km/s]</li> <li>mu  : gravitational parameter of the central body [km^3/s^2]</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2mee/#output","title":"OUTPUT","text":"<ul> <li>mee : vector of Modified Equinoctial Elements [p, f, g, h, k, L] where: p : semi-latus rectum [km] f : ecos(omega + Omega) g : esin(omega + Omega) h : tan(i/2)cos(Omega) k : tan(i/2)sin(Omega) L : true longitude [rad]</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/car2mee/#function-signature","title":"Function Signature","text":"<pre><code>[mee] = car2mee( car, mu )\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/eci2synodic_eph/","title":"<code>eci2synodic_eph</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/eci2synodic_eph/#description","title":"DESCRIPTION","text":"<p>This function converts state vectors from the ECI (Earth-Centered Inertial) reference frame to the Synodic reference frame, given the state vector of a secondary body (e.g., Moon), and the gravitational parameters of both primary and secondary bodies.</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/eci2synodic_eph/#input","title":"INPUT","text":"<ul> <li>Xeci  : State vector in the ECI reference frame [position; velocity].</li> <li>svbody: State vector of the secondary body at a particular epoch [position; velocity].</li> <li>mu1   : Gravitational parameter of the primary body (e.g., Earth).</li> <li>mu2   : Gravitational parameter of the secondary body (e.g., Moon).</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/eci2synodic_eph/#output","title":"OUTPUT","text":"<ul> <li>Xsyn  : State vector in the Synodic reference frame [position; velocity].</li> <li>L_ref : Distance from the primary body to the secondary body.</li> <li>V_ref : Velocity of the secondary body relative to the primary body.</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/eci2synodic_eph/#function-signature","title":"Function Signature","text":"<pre><code>[Xsyn, L_ref, V_ref] = eci2synodic_eph(Xeci, svbody, mu1, mu2)\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/kep2car/","title":"<code>kep2car</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/kep2car/#description","title":"DESCRIPTION:","text":"<p>Converts from Keplerian orbital elements to Cartesian position and velocity. All units to be consistent each other. Angles in radians. Note: In the case of hyperbola, theta must be such that the point is on the physical leg of the hyperbola (the leg around the attracting mass).</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/kep2car/#input","title":"INPUT:","text":"<p>kep[6]      Vector of keplerian elements: [a e i Om om theta], where theta is the true anomaly. a in [L], angles in [rad]. In case of hyperbola (e&gt;1), it must be: kep(1)&lt;0. mu          Planetary gravity constant [L^3/(M*T^2)]. p           Semi-latus rectum [L]. Only used for parabola case.</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/kep2car/#output","title":"OUTPUT:","text":"<p>out[1,6]    State vector in cartesian coordinates (position [L], velocity [L/T]). elimitpar = 0.99999999999999999;</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/kep2car/#function-signature","title":"Function Signature","text":"<pre><code>[out] = kep2car(kep,mu,p)\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/kep2mee/","title":"<code>kep2mee</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/kep2mee/#description","title":"DESCRIPTION","text":"<p>This function converts classical Keplerian orbital elements into Modified Equinoctial Elements (MEE), which are non-singular for all values of inclination and eccentricity except for exactly zero eccentricity and retrograde equatorial orbits. The conversion is valid for elliptical and circular orbits.</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/kep2mee/#input","title":"INPUT","text":"<ul> <li>kep : vector of Keplerian elements [a, e, i, Omega, omega, theta] where: a     : semi-major axis [km] e     : eccentricity i     : inclination [rad] Omega : right ascension of ascending node [rad] omega : argument of pericenter [rad] theta : true anomaly [rad]</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/kep2mee/#output","title":"OUTPUT","text":"<ul> <li>mee : vector of Modified Equinoctial Elements [p, f, g, h, k, L] where: p : semi-latus rectum [km] f : ecos(omega + Omega) g : esin(omega + Omega) h : tan(i/2)cos(Omega) k : tan(i/2)sin(Omega) L : true longitude [rad]</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/kep2mee/#function-signature","title":"Function Signature","text":"<pre><code>[mee] = kep2mee( kep )\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/kepler2MEOE/","title":"<code>kepler2MEOE</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/kepler2MEOE/#function-signature","title":"Function Signature","text":"<pre><code>[MEEParameters] = kepler2MEOE(Object)\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/mee2car/","title":"<code>mee2car</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/mee2car/#description","title":"DESCRIPTION","text":"<p>This function converts a state vector expressed in Modified Equinoctial Elements (MEE) into Cartesian coordinates (position and velocity) using an intermediate conversion to Classical Orbital Elements (COE).</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/mee2car/#input","title":"INPUT","text":"<ul> <li>mee : 6x1 vector of Modified Equinoctial Elements [p, f, g, h, k, L], where: p : semi-latus rectum f : component of eccentricity vector along x g : component of eccentricity vector along y h : component of inclination vector along x k : component of inclination vector along y L : true longitude</li> <li>mu  : gravitational parameter of the central body [km3/s2]</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/mee2car/#output","title":"OUTPUT","text":"<ul> <li>car : 6x1 Cartesian state vector [rx, ry, rz, vx, vy, vz], where: r : position vector components in inertial frame [km] v : velocity vector components in inertial frame [km/s]</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/mee2car/#function-signature","title":"Function Signature","text":"<pre><code>[car] = mee2car( mee, mu )\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/mee2kep/","title":"<code>mee2kep</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/mee2kep/#description","title":"DESCRIPTION","text":"<p>This function converts a vector of Modified Equinoctial Elements (MEE) to the equivalent set of Classical Orbital Elements (COE).</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/mee2kep/#input","title":"INPUT","text":"<ul> <li>mee : 6x1 vector of Modified Equinoctial Elements [p, f, g, h, k, L], where: p : semi-latus rectum f : component of eccentricity vector along x g : component of eccentricity vector along y h : component of inclination vector along x k : component of inclination vector along y L : true longitude</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/mee2kep/#output","title":"OUTPUT","text":"<ul> <li>kep : 1x6 vector of Classical Orbital Elements [a, e, i, RAAN, \u03c9, \u03b8], where: a    : semi-major axis e    : eccentricity i    : inclination RAAN : right ascension of ascending node \u03c9    : argument of periapsis \u03b8    : true anomaly</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/mee2kep/#function-signature","title":"Function Signature","text":"<pre><code>[kep] = mee2kep(mee)\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/spherical2Car/","title":"<code>spherical2Car</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/spherical2Car/#description","title":"DESCRIPTION","text":"<p>Spherical coordinates (r, th, phi) to position vector (pos_x, pos_y, pos_z).</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/spherical2Car/#input","title":"INPUT","text":"<ul> <li>spherical : 1x3 spherical coordinates such that :</li> <li>spherical(1) is the radius</li> <li>spherical(2) is the right ascension</li> <li>spherical(3) is the declination</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/spherical2Car/#output","title":"OUTPUT","text":"<ul> <li>cart : position vector (pos_x, pos_y, pos_z)</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/spherical2Car/#function-signature","title":"Function Signature","text":"<pre><code>[cart] = spherical2Car( spherical )\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/theta2M/","title":"<code>theta2M</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/theta2M/#description","title":"DESCRIPTION","text":"<p>Conversion from true anomaly to mean anomaly for keplerian orbits. Also works for hyperbolic paths.</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/theta2M/#input","title":"INPUT","text":"<ul> <li>theta : true anomaly [rad]</li> <li>e     : eccentricity</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/theta2M/#output","title":"OUTPUT","text":"<ul> <li>M : mean anomaly</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/theta2M/#function-signature","title":"Function Signature","text":"<pre><code>[M] = theta2M(theta, e)\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/vinfBplane2car/","title":"<code>vinfBplane2car</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/vinfBplane2car/#description","title":"DESCRIPTION","text":"<p>This function computes the cartesian elements (pos_x, pos_y, pos_z, vel_x, vel_y, vel_z) in a planetary-centered inertial reference frame from the B-plane elements. This is only valid for hyperbolic trajectories.</p>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/vinfBplane2car/#input","title":"INPUT","text":"<ul> <li>vinf_bplane_params : 1x6 vector with the following parameters</li> <li>vinf_mag        = vinf_bplane_params(1) magnitude of infinity velocity [km/s]</li> <li>right_ascension = vinf_bplane_params(2) right ascension of the infinity velocity vector [rad]</li> <li>declination     = vinf_bplane_params(3) declination of the infinity velocity vector [rad]</li> <li>bt              = vinf_bplane_params(4) BT component of the B-vector [km]</li> <li>br              = vinf_bplane_params(5) BR component of the B-vector [km]</li> <li>th              = vinf_bplane_params(6) true anomaly along the hyperbola [rad]</li> <li>mu_planet : gravitational parameter of the planet [km3/s2]</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/vinfBplane2car/#output","title":"OUTPUT","text":"<ul> <li>cart : 1x6 vector with (pos_x, pos_y, pos_z, vel_x, vel_y, vel_z) in [km] and [km/s]</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/vinfBplane2car/#function-signature","title":"Function Signature","text":"<pre><code>[cart] = vinfBplane2car( vinf_bplane_params, mu_planet )\n</code></pre>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/wrapECI2Synodic_SE/","title":"<code>wrapECI2Synodic_SE</code>","text":""},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/wrapECI2Synodic_SE/#input","title":"INPUT","text":"<ul> <li>statesECI : (Nx6) [rr, vv] state vectors in eclipticJ2000 frame taken at different epochs (km, km/s)</li> <li>epochs    : (Nx1) epochs at which the state vectors are computed (MJD2000)</li> <li>idcentral : ID of the central body. See constants.m</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/wrapECI2Synodic_SE/#output","title":"OUTPUT","text":"<ul> <li>statesSYN : (Nx6) [rr, vv] state vectors in Sun-Earth Synodic frame taken at the same epochs (Lref, Vref)</li> </ul>"},{"location":"matlab/Astrodynamics/Astrodynamics%20conversions/wrapECI2Synodic_SE/#function-signature","title":"Function Signature","text":"<pre><code>[statesSYN] = wrapECI2Synodic_SE(statesECI, epochs, idcentral, customEphemerides, pl)\n</code></pre>"},{"location":"matlab/Astrodynamics/Basic%20Transfers/hohmann_transfer/","title":"<code>hohmann_transfer</code>","text":""},{"location":"matlab/Astrodynamics/Basic%20Transfers/hohmann_transfer/#description","title":"DESCRIPTION","text":"<p>This function computes the parameters of a Hohmann transfer between two circular orbits with radii r1 and r2 around a central body with gravitational parameter mu. It calculates the initial and final velocities, velocity increments, transfer time, and intermediate velocity vectors.</p>"},{"location":"matlab/Astrodynamics/Basic%20Transfers/hohmann_transfer/#input","title":"INPUT","text":"<ul> <li>r1 : initial orbit radius (km)</li> <li>r2 : final orbit radius (km)</li> <li>mu : gravitational parameter of the central body (km^3/s^2)</li> </ul>"},{"location":"matlab/Astrodynamics/Basic%20Transfers/hohmann_transfer/#output","title":"OUTPUT","text":"<ul> <li>hohmann : structure containing the following fields:</li> <li>r1   : initial orbit radius</li> <li>v1   : initial circular velocity</li> <li>rr1  : initial position vector</li> <li>vv1  : initial velocity vector</li> <li>r2   : final orbit radius</li> <li>v2   : final circular velocity</li> <li>rr2  : final position vector</li> <li>vv2  : final velocity vector</li> <li>vvd  : departure velocity after first burn</li> <li>vva  : arrival velocity before second burn</li> <li>dvv1 : velocity change vector at departure</li> <li>dvv2 : velocity change vector at arrival</li> <li>dv1  : delta-v at departure</li> <li>dv2  : delta-v at arrival</li> <li>dvt  : total delta-v required</li> <li>Tt   : transfer time (s)</li> </ul>"},{"location":"matlab/Astrodynamics/Basic%20Transfers/hohmann_transfer/#function-signature","title":"Function Signature","text":"<pre><code>[hohmann] = hohmann_transfer(r1, r2, mu)\n</code></pre>"},{"location":"matlab/Astrodynamics/Basic%20Transfers/rocketEq_givenDV/","title":"<code>rocketEq_givenDV</code>","text":""},{"location":"matlab/Astrodynamics/Basic%20Transfers/rocketEq_givenDV/#description","title":"DESCRIPTION","text":"<p>This function computes the final mass of a rocket after a velocity change (delta-v) using the Tsiolkovsky rocket equation. It also calculates the propellant mass expended and the mass ratio.</p>"},{"location":"matlab/Astrodynamics/Basic%20Transfers/rocketEq_givenDV/#input","title":"INPUT","text":"<ul> <li>m0  : initial mass of the rocket (kg)</li> <li>dv  : velocity change (delta-v) required (m/s)</li> <li>Isp : specific impulse of the rocket engine (s)</li> <li>g0  : gravitational acceleration at sea level (m/s^2) [optional, default = 9.806 m/s^2]</li> </ul>"},{"location":"matlab/Astrodynamics/Basic%20Transfers/rocketEq_givenDV/#output","title":"OUTPUT","text":"<ul> <li>mf : final mass of the rocket after delta-v (kg)</li> <li>k  : mass ratio, defined as propellant mass fraction (mp/m0)</li> <li>mp : propellant mass expended (kg)</li> </ul>"},{"location":"matlab/Astrodynamics/Basic%20Transfers/rocketEq_givenDV/#function-signature","title":"Function Signature","text":"<pre><code>[mf, k, mp] = rocketEq_givenDV(m0, dv, Isp, g0)\n</code></pre>"},{"location":"matlab/Astrodynamics/Basic%20Transfers/rocketEq_givenFinalMass/","title":"<code>rocketEq_givenFinalMass</code>","text":""},{"location":"matlab/Astrodynamics/Basic%20Transfers/rocketEq_givenFinalMass/#description","title":"DESCRIPTION","text":"<p>This function computes the velocity change (delta-v) required to reach a given final mass using the Tsiolkovsky rocket equation. It also calculates the propellant mass expended and the mass ratio.</p>"},{"location":"matlab/Astrodynamics/Basic%20Transfers/rocketEq_givenFinalMass/#input","title":"INPUT","text":"<ul> <li>m0  : initial mass of the rocket (kg)</li> <li>mf  : final mass of the rocket after delta-v (kg)</li> <li>Isp : specific impulse of the rocket engine (s)</li> <li>g0  : gravitational acceleration at sea level (m/s^2) [optional, default = 9.806 m/s^2]</li> </ul>"},{"location":"matlab/Astrodynamics/Basic%20Transfers/rocketEq_givenFinalMass/#output","title":"OUTPUT","text":"<ul> <li>dv : velocity change (delta-v) required (m/s)</li> <li>k  : mass ratio, defined as propellant mass fraction (mp/m0)</li> <li>mp : propellant mass expended (kg)</li> </ul>"},{"location":"matlab/Astrodynamics/Basic%20Transfers/rocketEq_givenFinalMass/#function-signature","title":"Function Signature","text":"<pre><code>[dv, k, mp] = rocketEq_givenFinalMass(m0, mf, Isp, g0)\n</code></pre>"},{"location":"matlab/Astrodynamics/Conics/Vinf2Hyperbola/","title":"<code>Vinf2Hyperbola</code>","text":""},{"location":"matlab/Astrodynamics/Conics/Vinf2Hyperbola/#description","title":"DESCRIPTION","text":"<p>this function allows to calculate the parameters of a hyperbola given the velocity at infinity and the radius at the hyperbolic pericenter.</p>"},{"location":"matlab/Astrodynamics/Conics/Vinf2Hyperbola/#input","title":"INPUT","text":"<ul> <li>vinf : infinity velocity (km/s)</li> <li>rpip : hyperbolic pericentre (km)</li> <li>mu   : gravitational parameter of the flyby body (km3/s2)</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/Vinf2Hyperbola/#output","title":"OUTPUT","text":"<ul> <li>delta : hyperbolic deflection (rad)</li> <li>vpip  : hyperbolic pericentre velocity (km/s)</li> <li>eip   : hyperbolic eccentricity</li> <li>Eip   : hyperbolic energy (km2/s2)</li> <li>aip   : hyperbolic semi-major axis (a&lt;0) (km)</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/Vinf2Hyperbola/#function-signature","title":"Function Signature","text":"<pre><code>[delta, vpip, eip, Eip, aip] = Vinf2Hyperbola(vinf, rpip, mu)\n</code></pre>"},{"location":"matlab/Astrodynamics/Conics/apses_velocities/","title":"<code>apses_velocities</code>","text":""},{"location":"matlab/Astrodynamics/Conics/apses_velocities/#description","title":"DESCRIPTION","text":"<p>This function computes the velocities at periapsis and apoapsis for an orbit given the periapsis radius, apoapsis radius, and standard gravitational parameter. It also calculates the semi-major axis, eccentricity, and orbital period.</p>"},{"location":"matlab/Astrodynamics/Conics/apses_velocities/#input","title":"INPUT","text":"<ul> <li>rp : periapsis radius (scalar, in consistent length units)</li> <li>ra : apoapsis radius (scalar, in consistent length units)</li> <li>mu : standard gravitational parameter (scalar, in consistent units)</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/apses_velocities/#output","title":"OUTPUT","text":"<ul> <li>vp     : velocity at periapsis (scalar, in consistent velocity units)</li> <li>va     : velocity at apoapsis (scalar, in consistent velocity units)</li> <li>sma    : semi-major axis of the orbit (scalar, in consistent length units)</li> <li>ecc    : eccentricity of the orbit (scalar, dimensionless)</li> <li>period : orbital period (scalar, in consistent time units)</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/apses_velocities/#function-signature","title":"Function Signature","text":"<pre><code>[vp, va, sma, ecc, period] = apses_velocities( rp, ra, mu )\n</code></pre>"},{"location":"matlab/Astrodynamics/Conics/deltaV_hyperbola/","title":"<code>deltaV_hyperbola</code>","text":""},{"location":"matlab/Astrodynamics/Conics/deltaV_hyperbola/#description","title":"DESCRIPTION","text":"<p>This function computes the delta-v required for a hyperbolic trajectory maneuver. It calculates the velocity at periapsis of the incoming hyperbola and compares it with the velocity required for an elliptical orbit to determine the necessary velocity change.</p>"},{"location":"matlab/Astrodynamics/Conics/deltaV_hyperbola/#input","title":"INPUT","text":"<ul> <li>vinf  : excess velocity at infinity [km/s]</li> <li>rpip  : periapsis radius of the hyperbolic trajectory [km]</li> <li>rat   : apoapsis radius of the target orbit [km]</li> <li>mu    : gravitational parameter of the central body [km^3/s^2]</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/deltaV_hyperbola/#output","title":"OUTPUT","text":"<ul> <li>dv    : delta-v required for orbit insertion [km/s]</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/deltaV_hyperbola/#function-signature","title":"Function Signature","text":"<pre><code>[ dv ] = deltaV_hyperbola( vinf, rpip, rat, mu )\n</code></pre>"},{"location":"matlab/Astrodynamics/Conics/hill_radius/","title":"<code>hill_radius</code>","text":""},{"location":"matlab/Astrodynamics/Conics/hill_radius/#description","title":"DESCRIPTION","text":"<p>This function computes the Hill radius of a secondary body orbiting a central body. The Hill radius represents the region around the secondary body where its gravitational influence dominates over the tidal forces of the central body. If the central body is Earth (ID 1) and the secondary body is the Sun (ID 3), the mass of the Moon is also included in the calculation.</p>"},{"location":"matlab/Astrodynamics/Conics/hill_radius/#input","title":"INPUT","text":"<ul> <li>idcentral       : integer identifier of the central body</li> <li>secondary_body  : integer identifier of the secondary body</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/hill_radius/#output","title":"OUTPUT","text":"<ul> <li>r_hill         : Hill radius of the secondary body [km]</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/hill_radius/#function-signature","title":"Function Signature","text":"<pre><code>[r_hill] = hill_radius( idcentral, secondary_body )\n</code></pre>"},{"location":"matlab/Astrodynamics/Conics/hyperbola_peri_time/","title":"<code>hyperbola_peri_time</code>","text":""},{"location":"matlab/Astrodynamics/Conics/hyperbola_peri_time/#description","title":"DESCRIPTION:","text":"<p>Time since periapsis (and time to periapsis) passage on a hyperbola given a true anomaly.</p>"},{"location":"matlab/Astrodynamics/Conics/hyperbola_peri_time/#input","title":"INPUT","text":"<ul> <li>a  : semi-major axis (km), negative for hyperbola</li> <li>e  : eccentricity (&gt;1)</li> <li>mu : gravitational parameter (km^3/s^2)</li> <li>f  : true anomaly (rad)</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/hyperbola_peri_time/#output","title":"OUTPUT","text":"<ul> <li>t_since_peri : time since periapsis (s). Positive if after periapsis.</li> <li>t_to_peri    : time to periapsis (s). Positive if periapsis is in the future.</li> <li>H            : hyperbolic anomaly (signed)</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/hyperbola_peri_time/#function-signature","title":"Function Signature","text":"<pre><code>[t_since_peri, t_to_peri, H] = hyperbola_peri_time(a, e, mu, f)\n</code></pre>"},{"location":"matlab/Astrodynamics/Conics/sphere_of_influence/","title":"<code>sphere_of_influence</code>","text":""},{"location":"matlab/Astrodynamics/Conics/sphere_of_influence/#description","title":"DESCRIPTION","text":"<p>This function computes the sphere of influence (SOI) of a secondary body orbiting a central body. The sphere of influence represents the region where the secondary body's gravity dominates over the tidal forces of the central body, making it the primary gravitational influence for objects within this region.</p>"},{"location":"matlab/Astrodynamics/Conics/sphere_of_influence/#input","title":"INPUT","text":"<ul> <li>idcentral       : integer identifier of the central body</li> <li>secondary_body  : integer identifier of the secondary body</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/sphere_of_influence/#output","title":"OUTPUT","text":"<ul> <li>r_soi          : Sphere of influence radius of the secondary body [km]</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/sphere_of_influence/#function-signature","title":"Function Signature","text":"<pre><code>[r_soi] = sphere_of_influence( idcentral, secondary_body )\n</code></pre>"},{"location":"matlab/Astrodynamics/Conics/vinfBplane2Hyperbola/","title":"<code>vinfBplane2Hyperbola</code>","text":""},{"location":"matlab/Astrodynamics/Conics/vinfBplane2Hyperbola/#description","title":"DESCRIPTION","text":"<p>This function computes the hyperbola parameters given B-plane parameters.</p>"},{"location":"matlab/Astrodynamics/Conics/vinfBplane2Hyperbola/#input","title":"INPUT","text":"<ul> <li>vinf_bplane_params : 1x6 vector with the following parameters</li> <li>vinf_mag        = vinf_bplane_params(1) magnitude of infinity velocity [km/s]</li> <li>right_ascension = vinf_bplane_params(2) right ascension of the infinity velocity vector [rad] --&gt; NOT USED!!! Can be NaN.</li> <li>declination     = vinf_bplane_params(3) declination of the infinity velocity vector [rad] --&gt; NOT USED!!! Can be NaN.</li> <li>bt              = vinf_bplane_params(4) BT component of the B-vector [km]</li> <li>br              = vinf_bplane_params(5) BR component of the B-vector [km]</li> <li>th              = vinf_bplane_params(6) true anomaly along the hyperbola [rad] --&gt; NOT USED!!! Can be NaN.</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/vinfBplane2Hyperbola/#output","title":"OUTPUT","text":"<ul> <li>delta : hyperbolic deflection (rad)</li> <li>vpip  : hyperbolic pericentre velocity (km/s)</li> <li>eip   : hyperbolic eccentricity</li> <li>Eip   : hyperbolic energy (km2/s2)</li> <li>aip   : hyperbolic semi-major axis (a&lt;0) (km)</li> </ul>"},{"location":"matlab/Astrodynamics/Conics/vinfBplane2Hyperbola/#function-signature","title":"Function Signature","text":"<pre><code>[delta, vpip, eip, Eip, aip] = vinfBplane2Hyperbola(vinf_bplane_params, mu_planet)\n</code></pre>"},{"location":"matlab/Astrodynamics/Propagation/FGCar_dt/","title":"<code>FGCar_dt</code>","text":""},{"location":"matlab/Astrodynamics/Propagation/FGCar_dt/#description","title":"DESCRIPTION","text":"<p>Keplerian propagation of Kepler propagation of an orbit. This works also for hyperbolic paths. Compared to FGKepler_dt.m, this takes in input the state of the spacecraft and not the keplerian elements.</p>"},{"location":"matlab/Astrodynamics/Propagation/FGCar_dt/#input","title":"INPUT","text":"<ul> <li>rr1 : 1x3 vector of spacecraft position before the propagation [km]</li> <li>vv1 : 1x3 vector of spacecraft velocity before the propagation [km/s]</li> <li>dt  : time of flight [s]</li> <li>mu  : gravitational parameter of the central body [km3/s2]</li> </ul>"},{"location":"matlab/Astrodynamics/Propagation/FGCar_dt/#output","title":"OUTPUT","text":"<ul> <li>rrf  : 1x3 vector of spacecraft position after the propagation [km]</li> <li>vvf  : 1x3 vector of spacecraft velocity after the propagation [km/s]</li> <li>kep2 : 1x6 vector of final keplerian elements after the propagation (see car2kep.m)</li> </ul>"},{"location":"matlab/Astrodynamics/Propagation/FGCar_dt/#function-signature","title":"Function Signature","text":"<pre><code>[rrf, vvf, kep2] = FGCar_dt(rr1, vv1, dt, mu)\n</code></pre>"},{"location":"matlab/Astrodynamics/Propagation/FGKepler_dt/","title":"<code>FGKepler_dt</code>","text":""},{"location":"matlab/Astrodynamics/Propagation/FGKepler_dt/#description","title":"DESCRIPTION","text":"<p>Kepler propagation of an orbit. This works also for hyperbolic paths.</p>"},{"location":"matlab/Astrodynamics/Propagation/FGKepler_dt/#input","title":"INPUT","text":"<ul> <li>kep1 : 1x6 vector with initial keplerian elements (see car2kep.m)</li> <li>dt   : time of flight [s]</li> <li>mu   : gravitational parameter of the central body [km3/s2]</li> </ul>"},{"location":"matlab/Astrodynamics/Propagation/FGKepler_dt/#output","title":"OUTPUT","text":"<ul> <li>rrf  : 1x3 vector of spacecraft position after the propagation [km]</li> <li>vvf  : 1x3 vector of spacecraft velocity after the propagation [km/s]</li> <li>kep2 : 1x6 vector of final keplerian elements after the propagation (see car2kep.m)</li> </ul>"},{"location":"matlab/Astrodynamics/Propagation/FGKepler_dt/#function-signature","title":"Function Signature","text":"<pre><code>[rrf, vvf, kep2] = FGKepler_dt(kep1, dt, mu)\n</code></pre>"},{"location":"matlab/Astrodynamics/Propagation/kepEq_t/","title":"<code>kepEq_t</code>","text":""},{"location":"matlab/Astrodynamics/Propagation/kepEq_t/#description","title":"DESCRIPTION:","text":"<p>It finds the time t corresponding to an angular position f. Elliptic orbits (e &lt; 1).</p>"},{"location":"matlab/Astrodynamics/Propagation/kepEq_t/#input","title":"INPUT:","text":"<p>f[1]    True anomaly [rad]. a[1]    Semi-major axis [L]. e[1]    Eccentricity. mu[1]   Planetary constant (mu = mass * G) [L^3/T^2]. f0[1]   Fixed true anomaly [rad]. t0[1]   Time corresponding to f0 [T].</p> <p>Optional: Default value = 0.</p>"},{"location":"matlab/Astrodynamics/Propagation/kepEq_t/#output","title":"OUTPUT:","text":"<p>t[1]    Time corresponding to f [T] between [-Inf, Inf]. CALLED FUNCTIONS: (none) FUTURE DEVELOPMENT: Extension to parabolic and hyperbolic orbits. ORIGINAL VERSION: Camilla Colombo, 20/02/2006, MATLAB, tl.m AUTHOR: Camilla Colombo, Nicolas Croisard, 20/11/2007, MATLAB, kepEq_t.m PREVIOUS VERSION: Camilla Colombo, 20/11/2007, MATLAB, tl_inf.m - Time corresponding to f [T] given in the range [-Inf, Inf]. Camilla Colombo, Nicolas Croisard, 20/11/2007, MATLAB, tl3.m - Header and function name in accordance with guidlines. CHANGELOG: 02/12/2008, Matteo Ceriotti: Optional argument t0. 02/12/2008, REVISION: Matteo Ceriotti 30/12/2009, Camilla Colombo: Header and function name in accordance with guidlines.</p>"},{"location":"matlab/Astrodynamics/Propagation/kepEq_t/#function-signature","title":"Function Signature","text":"<pre><code>[t] = kepEq_t(f, a, e, mu, f0, t0)\n</code></pre>"},{"location":"matlab/Astrodynamics/Propagation/propagateKepler/","title":"<code>propagateKepler</code>","text":""},{"location":"matlab/Astrodynamics/Propagation/propagateKepler/#description","title":"DESCRIPTION","text":"<p>This function propagates in keplerian dynamics an initial state over a grid of time of flights.</p>"},{"location":"matlab/Astrodynamics/Propagation/propagateKepler/#input","title":"INPUT","text":"<ul> <li>rr1 : 1x3 vector with initial position [km]</li> <li>vv1 : 1x3 vector with initial velocity [km/s]</li> <li>tt  : 1xN vector with time of flights [s]</li> <li>mu  : gravitational constant of the central body [km3/s2]</li> </ul>"},{"location":"matlab/Astrodynamics/Propagation/propagateKepler/#output","title":"OUTPUT","text":"<ul> <li>tt   : same as in input</li> <li>yy   : Nx6 matrix, where each row is the state, i.e., position and velocity vectors evaluated at each tt(i)</li> <li>kkep : Nx6 matrix, where each row is a set of keplerian elements (see car2kep.m) evaluated at each tt(i)</li> </ul>"},{"location":"matlab/Astrodynamics/Propagation/propagateKepler/#function-signature","title":"Function Signature","text":"<pre><code>[tt, yy, kkep] = propagateKepler(rr1, vv1, tt, mu)\n</code></pre>"},{"location":"matlab/Astrodynamics/Propagation/propagateKepler_tof/","title":"<code>propagateKepler_tof</code>","text":""},{"location":"matlab/Astrodynamics/Propagation/propagateKepler_tof/#description","title":"DESCRIPTION","text":"<p>This function propagates in keplerian dynamics an initial state for a specified time of flight.</p>"},{"location":"matlab/Astrodynamics/Propagation/propagateKepler_tof/#input","title":"INPUT","text":"<ul> <li>rr1     : 1x3 vector with initial position [km]</li> <li>vv1     : 1x3 vector with initial velocity [km/s]</li> <li>tof     : time of flight [sec]</li> <li>mu      : gravitational constant of the central body [km3/s2]</li> <li>npoints : number of points for the propagation (default: 500)</li> </ul>"},{"location":"matlab/Astrodynamics/Propagation/propagateKepler_tof/#output","title":"OUTPUT","text":"<ul> <li>tt   : same as in input</li> <li>yy   : Nx6 matrix, where each row is the state, i.e., position and velocity vectors evaluated at each tt(i)</li> <li>kkep : Nx6 matrix, where each row is a set of keplerian elements (see car2kep.m) evaluated at each tt(i)</li> </ul>"},{"location":"matlab/Astrodynamics/Propagation/propagateKepler_tof/#function-signature","title":"Function Signature","text":"<pre><code>[tt,yy] = propagateKepler_tof(rr1, vv1, tof, mu, npoints)\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/date2jd/","title":"<code>date2jd</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/date2jd/#description","title":"DESCRIPTION:","text":"<p>Returns the Julian day number of the given date (Gregorian calendar) plus a fractional part depending on the time of day. Note: The function is valid for the whole range of dates since 12:00 noon 24 November -4713, Gregorian calendar. (This bound is set in order to have symmetry with the inverse function jd2date.m) Note: The inputs must be feasible (i.e. the date must exist!). If an unfeasible date is inputed, wrong results are given because no check is done on that.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/date2jd/#input","title":"INPUT:","text":"<p>date[6]     Date in the Gregorian calendar, as a 6-elements vector [year, month, day, hour, minute, second]. For dates before 1582, the resulting date components are valid only in the Gregorian proleptic calendar. This is based on the Gregorian calendar but extended to cover dates before its introduction. Date must be after 12:00 noon, 24 November -4713.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/date2jd/#output","title":"OUTPUT:","text":"<p>jd[1]       Date in Julian Day. The JD (Julian day) count is from 0 at 12:00 noon, 1 January -4712 (4713 BC), Julian proleptic calendar. The corresponding date in Gregorian calendar is 12:00 noon, 24 November -4713. REFERENCES: Formula from http://scienceworld.wolfram.com/astronomy/JulianDate.html (last visited 15/02/2008) Compared to http://pdc.ro.nu/mjd.cgi for a few dates, the same results were found See also JD2DATE. CALLED FUNCTIONS hms2fracday AUTHOR: Nicolas Croisard, 16/02/2008, MATLAB, date2jd.m CHANGELOG: 03/03/2008, REVISION: Camilla Colombo 22/04/2010, Camilla Colombo: Header and function name in accordance with guidlines.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/date2jd/#function-signature","title":"Function Signature","text":"<pre><code>[jd] = date2jd(date)\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/date2mjd2000/","title":"<code>date2mjd2000</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/date2mjd2000/#description","title":"DESCRIPTION:","text":"<p>Returns the modified Julian day 2000 number of the given date (Gregorian calendar) plus a fractional part depending on the time of day. Note: The function is valid for the whole range of dates since 12:00 noon 24 November -4713, Gregorian calendar. (This bound is set in order to have symmetry with the inverse function jd2date) Note: The inputs must be feasible (i.e. the date must exist!). If an unfeasible date is inputed, wrong results are given because no check is done on that.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/date2mjd2000/#input","title":"INPUT:","text":"<p>date[6]     Date in the Gregorian calendar, as a 6-element vector [year, month, day, hour, minute, second]. For dates before 1582, the resulting date components are valid only in the Gregorian proleptic calendar. This is based on the Gregorian calendar but extended to cover dates before its introduction. date must be after 12:00 noon, 24 November -4713.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/date2mjd2000/#output","title":"OUTPUT:","text":"<p>mjd2000[1]  Date in MJD 2000. MJD2000 is defined as the number of days since 01-01-2000, 12:00 noon. See also mjd20002date. CALLED FUNCTIONS: date2jd AUTHOR: Nicolas Croisard, 16/02/2008, MATLAB, date2mjd2000.m CHANGELOG: 03/03/2008, REVISION, Camilla Colombo 22/04/2010, Camilla Colombo: Header and function name in accordance with guidlines.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/date2mjd2000/#function-signature","title":"Function Signature","text":"<pre><code>[mjd2000] = date2mjd2000(date)\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/datetime_string_to_mjd2000/","title":"<code>datetime_string_to_mjd2000</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/datetime_string_to_mjd2000/#description","title":"DESCRIPTION","text":"<p>This function converts a date-time string in ISO 8601 format ('yyyy-MM-ddTHH:mm:ss.SSSSSS') into the corresponding Modified Julian Date referenced to epoch J2000 (MJD2000). It is useful for converting human-readable timestamps into a numerical format commonly used in astrodynamics and orbital mechanics.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/datetime_string_to_mjd2000/#input","title":"INPUT","text":"<ul> <li>dt_str       : date-time string in the format 'YYYY-MM-DDTHH:MM:SS.SSSSSS'</li> </ul>"},{"location":"matlab/Astrodynamics/Time%20conversions/datetime_string_to_mjd2000/#output","title":"OUTPUT","text":"<ul> <li>date_mjd2000 : scalar value representing the Modified Julian Date referenced to epoch J2000 (days since 01 Jan 2000 12:00 TT)</li> </ul>"},{"location":"matlab/Astrodynamics/Time%20conversions/datetime_string_to_mjd2000/#function-signature","title":"Function Signature","text":"<pre><code>[ date_mjd2000 ] = datetime_string_to_mjd2000( dt_str )\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/datetime_string_to_vector/","title":"<code>datetime_string_to_vector</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/datetime_string_to_vector/#description","title":"DESCRIPTION","text":"<p>This function converts a date-time string in ISO 8601 format ('yyyy-MM-ddTHH:mm:ss.SSSSSS') into a numerical vector of six elements representing year, month, day, hour, minute, and second. It is useful when date components are required in numerical form for further computations or analysis.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/datetime_string_to_vector/#input","title":"INPUT","text":"<ul> <li>dt_str : date-time string in the format 'YYYY-MM-DDTHH:MM:SS.SSSSSS'</li> </ul>"},{"location":"matlab/Astrodynamics/Time%20conversions/datetime_string_to_vector/#output","title":"OUTPUT","text":"<ul> <li>vec    : 1x6 numerical vector [YYYY MM DD HH MM SS]. The seconds value is returned as an integer if it has no decimal part.</li> </ul>"},{"location":"matlab/Astrodynamics/Time%20conversions/datetime_string_to_vector/#function-signature","title":"Function Signature","text":"<pre><code>[vec] = datetime_string_to_vector(dt_str)\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/fracday2hms/","title":"<code>fracday2hms</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/fracday2hms/#description","title":"DESCRIPTION:","text":"<p>Converts the fraction of day to hours, minutes, and seconds.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/fracday2hms/#input","title":"INPUT:","text":"<p>fracDay[1] A single real greater or equal to 0 and strictly lower than 1.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/fracday2hms/#output","title":"OUTPUT:","text":"<p>hrs[1]     Number of hours as integer greater or equal to 0 and lower or equal to 23. mn[1]      Number of minutes as integer greater or equal to 0 and lower or equal to 59. sec[1]     Number of seconds as a real greater or equal to 0 and strictly lower than 60. See also hms2fracday. CALLED FUNCTIONS: (none) AUTHOR: Nicolas Croisard, 16/02/2008, MATLAB, fracday2hms.m CHANGELOG: 21/02/2008, REVISION, Matteo Ceriotti 22/04/2010, Camilla Colombo: Header and function name in accordance with guidlines.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/fracday2hms/#function-signature","title":"Function Signature","text":"<pre><code>[hrs, mn, sec] = fracday2hms(fracDay)\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/hms2fracday/","title":"<code>hms2fracday</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/hms2fracday/#input","title":"INPUT","text":"<p>hrs        Number of hours as integer greater or equal to 0 and lower or equal to 23. mn         Number of minutes as integer greater or equal to 0 and lower or equal to 59. sec        Number of seconds as a real greater or equal to 0 and strictly lower than 60.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/hms2fracday/#output","title":"OUTPUT","text":"<p>fracDay    A single real greater or equal to 0 and strictly lower than 1. See also FRACDAY2HMS. FUNCTIONS CALLED none - Nicolas Croisard - 16/02/2008 - Revised by Camilla Colombo - 29/02/2008</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/hms2fracday/#function-signature","title":"Function Signature","text":"<pre><code>[fracDay] = hms2fracday(hrs, mn, sec)\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/jd2date/","title":"<code>jd2date</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/jd2date/#input","title":"INPUT","text":"<p>jd          Date in Julian Day. The JD (Julian day) count is from 0 at 12:00 noon, 1 January -4712 (4713 BC), Julian proleptic calendar. The corresponding date in Gregorian calendar is 12:00 noon, 24 November -4713. It must be a non-negative real.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/jd2date/#output","title":"OUTPUT","text":"<p>date        Date in the Gregorian calendar, as a 6-element vector [year, month, day, hour, minute, second]. For dates before 1582, the resulting date components are valid only in the Gregorian proleptic calendar. This is based on the Gregorian calendar but extended to cover dates before its introduction. REFERENCES Formula from http://en.wikipedia.org/wiki/Julian_day (last visited 16/02/2008) Compared to http://pdc.ro.nu/mjd.cgi for a few dates, the same results were found See also DATE2JD. FUNCTIONS CALLED FRACDAY2HMS - Nicolas Croisard - 16/02/2008 - Revised by Matteo Ceriotti - 21/02/2008 - Validated with: - Fliegel, Van Flandern \"A machine Algorithm for Processing Calendar Dates\", Communications of the ACM, 1968. Also on Wertz, \"Space Mission Analysis and Design\". - A revised version of the algorithm on Vallado, \"Fundamentals of Astrodynamics and Applications\", third edition, for dates from year 1900 to year 2100.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/jd2date/#function-signature","title":"Function Signature","text":"<pre><code>[date] = jd2date(jd)\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/jd2mjd2000/","title":"<code>jd2mjd2000</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/jd2mjd2000/#function-signature","title":"Function Signature","text":"<pre><code>[tmjd2000] = jd2mjd2000(tjd)\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd20002date/","title":"<code>mjd20002date</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/mjd20002date/#input","title":"INPUT","text":"<p>mjd2000     Date in MJD 2000. MJD2000 is defined as the number of days since 01-01-2000, 12:00 noon. It must be a real greater or equal than -2451545.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd20002date/#output","title":"OUTPUT","text":"<p>date        Date in the Gregorian calendar, as a 6-element vector [year, month, day, hour, minute, second]. For dates before 1582, the resulting date components are valid only in the Gregorian proleptic calendar. This is based on the Gregorian calendar but extended to cover dates before its introduction. See also DATE2MJD2000. FUNCTIONS CALLED MJD20002JD JD2DATE - Nicolas Croisard - 16/02/2008 - Revised by Matteo Ceriotti - 21/02/2008</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd20002date/#function-signature","title":"Function Signature","text":"<pre><code>[date] = mjd20002date(mjd2000)\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd20002jd/","title":"<code>mjd20002jd</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/mjd20002jd/#input","title":"INPUT","text":"<p>mjd2000     Date in MJD 2000. MJD2000 is defined as the number of days since 01-01-2000, 12:00 noon.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd20002jd/#output","title":"OUTPUT","text":"<p>jd          Date in Julian Day. The JD (Julian day) count is from 0 at 12:00 noon, 1 January -4712 (4713 BC), Julian proleptic calendar. The corresponding date in Gregorian calendar is 12:00 noon, 24 November -4713. See also JD2MJD2000. FUNCTIONS CALLED none - Nicolas Croisard - 16/02/2008 - Revised by Matteo Ceriotti - 20/02/2008</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd20002jd/#function-signature","title":"Function Signature","text":"<pre><code>[jd] = mjd20002jd(mjd2000)\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd20002mjd/","title":"<code>mjd20002mjd</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/mjd20002mjd/#input","title":"INPUT","text":"<p>mjd2000     Date in MJD 2000. MJD2000 is defined as the number of days since 01-01-2000, 12:00 noon.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd20002mjd/#output","title":"OUTPUT","text":"<p>mjd         Date in modified Julian Day. The MJD count is from 00:00 midnight at the beginning of Wednesday November 17, 1858. See also MJD2MJD2000. FUNCTIONS CALLED none - Nicolas Croisard - 16/02/2008 - Revised by Matteo Ceriotti - 20/02/2008</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd20002mjd/#function-signature","title":"Function Signature","text":"<pre><code>[mjd] = mjd20002mjd(mjd2000)\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd2date/","title":"<code>mjd2date</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/mjd2date/#input","title":"INPUT","text":"<p>mjd         Date in modified Julian Day. The MJD count is from 00:00 midnight at the beginning of Wednesday November 17, 1858. It must be a real greater or equal than -2400000.5.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd2date/#output","title":"OUTPUT","text":"<p>date        Date in the Gregorian calendar, as a 6-element vector [year, month, day, hour, minute, second]. For dates before 1582, the resulting date components are valid only in the Gregorian proleptic calendar. This is based on the Gregorian calendar but extended to cover dates before its introduction. See also DATE2MJD. FUNCTIONS CALLED MJD2JD JD2DATE - Nicolas Croisard - 16/02/2008 - Revised by Matteo Ceriotti - 21/02/2008</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd2date/#function-signature","title":"Function Signature","text":"<pre><code>[date] = mjd2date(mjd)\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd2jd/","title":"<code>mjd2jd</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/mjd2jd/#input","title":"INPUT","text":"<p>mjd         Date in modified Julian Day. The MJD count is from 00:00 midnight at the beginning of Wednesday November 17, 1858.</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd2jd/#output","title":"OUTPUT","text":"<p>jd          Date in Julian Day. The JD (Julian day) count is from 0 at 12:00 noon, 1 January -4712 (4713 BC), Julian proleptic calendar. The corresponding date in Gregorian calendar is 12:00 noon, 24 November -4713. See also JD2MJD. FUNCTIONS CALLED none - Nicolas Croisard - 16/02/2008 - Revised by Matteo Ceriotti - 20/02/2008</p>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd2jd/#function-signature","title":"Function Signature","text":"<pre><code>[jd] = mjd2jd(mjd)\n</code></pre>"},{"location":"matlab/Astrodynamics/Time%20conversions/mjd2mjd2000/","title":"<code>mjd2mjd2000</code>","text":""},{"location":"matlab/Astrodynamics/Time%20conversions/mjd2mjd2000/#function-signature","title":"Function Signature","text":"<pre><code>[mjd2000] = mjd2mjd2000(mjd)\n</code></pre>"},{"location":"matlab/Cost%20functions/MODP/costFunction1_MODP/","title":"<code>costFunction1_MODP</code>","text":""},{"location":"matlab/Cost%20functions/MODP/costFunction1_MODP/#description","title":"DESCRIPTION:","text":"<p>This function selects the optimal trajectories based on a multi-objective optimization approach, considering both the total cost and time of flight (TOF). The function computes the Pareto front, identifying the set of non-dominated solutions, and returns only the trajectories on this front.</p>"},{"location":"matlab/Cost%20functions/MODP/costFunction1_MODP/#input","title":"INPUT:","text":"<ul> <li>legn   : Matrix where each row represents a different candidate trajectory. The cost for each leg is stored in the 3rd column of each group of three columns.</li> <li>vvf    : Matrix containing the final velocities for the corresponding candidate trajectories.</li> <li>vinff  : Matrix containing the incoming velocities for the corresponding candidate trajectories.</li> </ul>"},{"location":"matlab/Cost%20functions/MODP/costFunction1_MODP/#output","title":"OUTPUT:","text":"<ul> <li>legn   : Matrix containing only the trajectories that lie on the Pareto front.</li> <li>vvf    : The final velocities associated with the trajectories on the Pareto front.</li> <li>vinff  : The incoming velocities associated with the trajectories on the Pareto front.</li> </ul>"},{"location":"matlab/Cost%20functions/MODP/costFunction1_MODP/#function-signature","title":"Function Signature","text":"<pre><code>[legn, vvf, vinff] = costFunction1_MODP(legn, vvf, vinff)\n</code></pre>"},{"location":"matlab/Cost%20functions/MODP/costFunction2_MODP/","title":"<code>costFunction2_MODP</code>","text":""},{"location":"matlab/Cost%20functions/MODP/costFunction2_MODP/#description","title":"DESCRIPTION:","text":"<p>This function performs a multi-objective optimization by evaluating both the total cost and time of flight (TOF) for multiple candidate trajectories. It identifies the Pareto front, selecting the set of non-dominated solutions. The function also determines the trajectory with the minimum cost among all candidates.</p>"},{"location":"matlab/Cost%20functions/MODP/costFunction2_MODP/#input","title":"INPUT:","text":"<ul> <li>legn   : Matrix where each row represents a different candidate trajectory, with the cost for each leg stored in the 3rd column of each group of three columns.</li> <li>vvf    : Matrix containing the final velocities for the corresponding candidate trajectories.</li> <li>vinff  : Matrix containing the incoming velocities for the corresponding candidate trajectories.</li> </ul>"},{"location":"matlab/Cost%20functions/MODP/costFunction2_MODP/#output","title":"OUTPUT:","text":"<ul> <li>legn    : Matrix containing only the trajectories that lie on the Pareto front.</li> <li>vvf     : The final velocities associated with the trajectories on the Pareto front.</li> <li>vinff   : The incoming velocities associated with the trajectories on the Pareto front.</li> <li>PF      : Matrix representing the Pareto front of the cost matrix.</li> <li>COSTS   : Vector containing the total costs for all candidate trajectories, calculated as the sum of leg costs and incoming velocities.</li> <li>TOFYS   : Vector containing the time of flight for each trajectory, converted to years.</li> <li>minCOST : The minimum total cost found across all candidate trajectories.</li> <li>row     : The index (row number) of the trajectory with the minimum cost in the input matrix <code>legn</code>.</li> </ul>"},{"location":"matlab/Cost%20functions/MODP/costFunction2_MODP/#function-signature","title":"Function Signature","text":"<pre><code>[legn, vvf, vinff, PF, COSTS, TOFYS, minCOST, row] = costFunction2_MODP(legn, vvf, vinff)\n</code></pre>"},{"location":"matlab/Cost%20functions/MODP/custom/costFunction1_MODP_vdep/","title":"<code>costFunction1_MODP_vdep</code>","text":""},{"location":"matlab/Cost%20functions/MODP/custom/costFunction1_MODP_vdep/#description","title":"DESCRIPTION","text":"<p>This function computes two cost objectives for a given set of trajectory legs and determines the subset of solutions that form the Pareto front.</p>"},{"location":"matlab/Cost%20functions/MODP/custom/costFunction1_MODP_vdep/#input","title":"INPUT","text":"<ul> <li>legn  : matrix containing trajectory leg parameters, where columns represent different trajectory characteristics such as departure time, arrival time, and delta-v components.</li> <li>vvf   : matrix containing final velocity vectors for each trajectory leg.</li> <li>vinff : matrix containing incoming hyperbolic excess velocities.</li> <li>vdep  : scalar value representing the initial departure velocity.</li> <li>sigma : weighting factor for the time-of-flight in the total cost computation.</li> </ul>"},{"location":"matlab/Cost%20functions/MODP/custom/costFunction1_MODP_vdep/#output","title":"OUTPUT","text":"<ul> <li>legn  : subset of the input legn matrix corresponding to the Pareto-optimal solutions.</li> <li>vvf   : subset of the input vvf matrix corresponding to the Pareto-optimal solutions.</li> <li>vinff : subset of the input vinff matrix corresponding to the Pareto-optimal solutions.</li> </ul>"},{"location":"matlab/Cost%20functions/MODP/custom/costFunction1_MODP_vdep/#process","title":"PROCESS","text":"<ol> <li>Compute the departure delta-v (dv1), ensuring non-negative values.</li> <li>Compute the total time-of-flight (tofs) in years.</li> <li>Compute the total delta-v (dvtot) including all intermediate maneuvers.</li> <li>Formulate the cost matrix using time-of-flight and total delta-v weighted by sigma.</li> <li>Compute the Pareto front using the <code>paretoFront_MODP</code> function.</li> <li>Extract and return only the Pareto-optimal solutions.</li> </ol>"},{"location":"matlab/Cost%20functions/MODP/custom/costFunction1_MODP_vdep/#function-signature","title":"Function Signature","text":"<pre><code>[legn, vvf, vinff] = costFunction1_MODP_vdep(legn, vvf, vinff, vdep, sigma)\n</code></pre>"},{"location":"matlab/Cost%20functions/MODP/custom/costFunction2_MODP_vdep_varr/","title":"<code>costFunction2_MODP_vdep_varr</code>","text":""},{"location":"matlab/Cost%20functions/MODP/custom/costFunction2_MODP_vdep_varr/#description","title":"DESCRIPTION","text":"<p>This function evaluates multiple trajectory options and selects those on the Pareto front, considering both delta-v and time-of-flight. It also identifies the minimum delta-v trajectory.</p>"},{"location":"matlab/Cost%20functions/MODP/custom/costFunction2_MODP_vdep_varr/#input","title":"INPUT","text":"<ul> <li>legn  : matrix containing trajectory leg parameters, where columns represent different trajectory characteristics such as departure time, arrival time, and delta-v components.</li> <li>vvf   : matrix containing final velocity vectors for each trajectory leg.</li> <li>vinff : matrix containing incoming hyperbolic excess velocities.</li> <li>vdep  : scalar value representing the specified departure velocity.</li> <li>varr  : scalar value representing the specified arrival velocity.</li> <li>sigma : weighting factor for the time-of-flight in the total cost computation.</li> </ul>"},{"location":"matlab/Cost%20functions/MODP/custom/costFunction2_MODP_vdep_varr/#output","title":"OUTPUT","text":"<ul> <li>legn     : matrix containing the trajectory legs that belong to the Pareto front.</li> <li>vvf      : matrix containing the final velocities of the Pareto-optimal trajectories.</li> <li>vinff    : matrix containing the incoming excess velocities of the Pareto-optimal trajectories.</li> <li>PF       : matrix representing the Pareto front, storing time-of-flight and total cost.</li> <li>COSTS    : vector containing the total cost (delta-v + weighted time-of-flight) for each trajectory.</li> <li>TOFYS    : vector containing the time-of-flight values in years.</li> <li>minCOST  : scalar value of the minimum total cost among all solutions.</li> <li>row      : index of the trajectory corresponding to the minimum total cost.</li> </ul>"},{"location":"matlab/Cost%20functions/MODP/custom/costFunction2_MODP_vdep_varr/#process","title":"PROCESS","text":"<ol> <li>Compute the departure delta-v (dv1) and arrival delta-v (dv2), ensuring non-negative values.</li> <li>Compute the total time-of-flight (tofs).</li> <li>Compute the total delta-v (dvtot) including all intermediate maneuvers.</li> <li>Compute the cost for each trajectory as the sum of delta-v and weighted time-of-flight.</li> <li>Construct the cost matrix containing time-of-flight and total cost.</li> <li>Compute the Pareto front from the cost matrix.</li> <li>Select the trajectories that belong to the Pareto front.</li> <li>Identify and return the minimum delta-v trajectory.</li> </ol>"},{"location":"matlab/Cost%20functions/MODP/custom/costFunction2_MODP_vdep_varr/#function-signature","title":"Function Signature","text":"<pre><code>[legn, vvf, vinff, PF, COSTS, TOFYS, minCOST, row] = costFunction2_MODP_vdep_varr(legn, vvf, vinff, vdep, varr, sigma)\n</code></pre>"},{"location":"matlab/Cost%20functions/SODP/costFunction1_DP/","title":"<code>costFunction1_DP</code>","text":""},{"location":"matlab/Cost%20functions/SODP/costFunction1_DP/#description","title":"DESCRIPTION:","text":"<p>This function selects the optimal trajectory based on the minimum total cost, defined by the user. The function takes in multiple candidate trajectories and their associated velocities, evaluates them, and returns the best one according to the defined cost criteria.</p>"},{"location":"matlab/Cost%20functions/SODP/costFunction1_DP/#input","title":"INPUT:","text":"<ul> <li>legn   : Matrix where each row represents a different candidate trajectory, and the columns correspond to different legs of the trajectory. The cost for each leg is stored in the 3rd column of each group of three columns.</li> <li>vvf    : Matrix where each row contains the final velocities for the corresponding candidate trajectories.</li> <li>vinff  : Matrix where each row contains the incoming velocities for the corresponding candidate trajectories.</li> </ul>"},{"location":"matlab/Cost%20functions/SODP/costFunction1_DP/#output","title":"OUTPUT:","text":"<ul> <li>legn   : The optimal trajectory (row) from the input <code>legn</code> matrix, based on the minimum total cost.</li> <li>vvf    : The final velocities associated with the optimal trajectory.</li> <li>vinff  : The incoming velocities associated with the optimal trajectory.</li> </ul>"},{"location":"matlab/Cost%20functions/SODP/costFunction1_DP/#function-signature","title":"Function Signature","text":"<pre><code>[legn, vvf, vinff] = costFunction1_DP(legn, vvf, vinff)\n</code></pre>"},{"location":"matlab/Cost%20functions/SODP/costFunction2_DP/","title":"<code>costFunction2_DP</code>","text":""},{"location":"matlab/Cost%20functions/SODP/costFunction2_DP/#description","title":"DESCRIPTION:","text":"<p>This function calculates the total cost for multiple candidate trajectories, taking into account both the leg costs and incoming velocities. It then determines the trajectory with the minimum cost. Additionally, it computes the time of flight (TOF) for each trajectory in years.</p>"},{"location":"matlab/Cost%20functions/SODP/costFunction2_DP/#input","title":"INPUT:","text":"<ul> <li>legn   : Matrix where each row represents a different candidate trajectory, with the cost for each leg stored in the 3rd column of each group of three columns.</li> <li>vvf    : Matrix containing the final velocities for the corresponding candidate trajectories (not used in this function).</li> <li>vinff  : Matrix containing the incoming velocities for the corresponding candidate trajectories.</li> </ul>"},{"location":"matlab/Cost%20functions/SODP/costFunction2_DP/#output","title":"OUTPUT:","text":"<ul> <li>minCOST : The minimum total cost found across all candidate trajectories.</li> <li>row     : The index (row number) of the trajectory with the minimum cost in the input matrix <code>legn</code>.</li> <li>COSTS   : Vector containing the total costs for all candidate trajectories, calculated as the sum of leg costs and incoming velocities.</li> <li>TOFYS   : Vector containing the time of flight for each trajectory, converted to years.</li> </ul>"},{"location":"matlab/Cost%20functions/SODP/costFunction2_DP/#function-signature","title":"Function Signature","text":"<pre><code>[minCOST, row, COSTS, TOFYS] = costFunction2_DP(legn, vvf, vinff)\n</code></pre>"},{"location":"matlab/Cost%20functions/SODP/custom/costFunction1_DP_custom/","title":"<code>costFunction1_DP_custom</code>","text":""},{"location":"matlab/Cost%20functions/SODP/custom/costFunction1_DP_custom/#function-signature","title":"Function Signature","text":"<pre><code>[legn, vvf, vinff] = costFunction1_DP_custom(legn, vvf, vinff)\n</code></pre>"},{"location":"matlab/Cost%20functions/SODP/custom/costFunction1_DP_custom_vdep/","title":"<code>costFunction1_DP_custom_vdep</code>","text":""},{"location":"matlab/Cost%20functions/SODP/custom/costFunction1_DP_custom_vdep/#description","title":"DESCRIPTION","text":"<p>This function selects the optimal trajectory based on a cost function that considers both delta-v and time-of-flight. It returns the trajectory leg, final velocity, and incoming hyperbolic excess velocity corresponding to the minimum cost.</p>"},{"location":"matlab/Cost%20functions/SODP/custom/costFunction1_DP_custom_vdep/#input","title":"INPUT","text":"<ul> <li>legn  : matrix containing trajectory leg parameters, where columns represent different trajectory characteristics such as departure time, arrival time, and delta-v components.</li> <li>vvf   : matrix containing final velocity vectors for each trajectory leg.</li> <li>vinff : matrix containing incoming hyperbolic excess velocities.</li> <li>vdep  : scalar value representing the specified departure velocity.</li> <li>sigma : weighting factor for the time-of-flight in the total cost computation.</li> </ul>"},{"location":"matlab/Cost%20functions/SODP/custom/costFunction1_DP_custom_vdep/#output","title":"OUTPUT","text":"<ul> <li>legn  : row vector corresponding to the optimal trajectory leg.</li> <li>vvf   : row vector corresponding to the final velocity of the optimal trajectory.</li> <li>vinff : row vector corresponding to the incoming excess velocity of the optimal trajectory.</li> </ul>"},{"location":"matlab/Cost%20functions/SODP/custom/costFunction1_DP_custom_vdep/#process","title":"PROCESS","text":"<ol> <li>Compute the departure delta-v (dv1), ensuring non-negative values.</li> <li>Compute the total time-of-flight (tofs).</li> <li>Compute the total delta-v (dvtot) including all intermediate maneuvers.</li> <li>Normalize the time-of-flight in years.</li> <li>Compute the total cost as the sum of delta-v and weighted time-of-flight.</li> <li>Identify the trajectory with the minimum total cost.</li> <li>Return the corresponding trajectory leg, final velocity, and incoming excess velocity.</li> </ol>"},{"location":"matlab/Cost%20functions/SODP/custom/costFunction1_DP_custom_vdep/#function-signature","title":"Function Signature","text":"<pre><code>[legn, vvf, vinff] = costFunction1_DP_custom_vdep(legn, vvf, vinff, vdep, sigma)\n</code></pre>"},{"location":"matlab/Cost%20functions/SODP/custom/costFunction2_DP_custom/","title":"<code>costFunction2_DP_custom</code>","text":""},{"location":"matlab/Cost%20functions/SODP/custom/costFunction2_DP_custom/#function-signature","title":"Function Signature","text":"<pre><code>[minCOST, row, COSTS, TOFYS] = costFunction2_DP_custom(legn, vvf, vinff)\n</code></pre>"},{"location":"matlab/Cost%20functions/SODP/custom/costFunction2_DP_custom_vdep_varr/","title":"<code>costFunction2_DP_custom_vdep_varr</code>","text":""},{"location":"matlab/Cost%20functions/SODP/custom/costFunction2_DP_custom_vdep_varr/#description","title":"DESCRIPTION","text":"<p>This function computes the total cost of a trajectory based on delta-v and time-of-flight, incorporating departure and arrival velocity constraints. It identifies the minimum-cost trajectory among the given options.</p>"},{"location":"matlab/Cost%20functions/SODP/custom/costFunction2_DP_custom_vdep_varr/#input","title":"INPUT","text":"<ul> <li>legn  : matrix containing trajectory leg parameters, where columns represent different trajectory characteristics such as departure time, arrival time, and delta-v components.</li> <li>vvf   : matrix containing final velocity vectors for each trajectory leg.</li> <li>vinff : matrix containing incoming hyperbolic excess velocities.</li> <li>vdep  : scalar value representing the specified departure velocity.</li> <li>varr  : scalar value representing the specified arrival velocity.</li> <li>sigma : weighting factor for the time-of-flight in the total cost computation.</li> </ul>"},{"location":"matlab/Cost%20functions/SODP/custom/costFunction2_DP_custom_vdep_varr/#output","title":"OUTPUT","text":"<ul> <li>minCOST : minimum total cost among all trajectories.</li> <li>row     : index of the trajectory with the minimum cost.</li> <li>COSTS   : vector containing the total cost for each trajectory.</li> <li>TOFYS   : vector containing the time-of-flight in years for each trajectory.</li> </ul>"},{"location":"matlab/Cost%20functions/SODP/custom/costFunction2_DP_custom_vdep_varr/#process","title":"PROCESS","text":"<ol> <li>Compute the departure delta-v (dv1), ensuring non-negative values.</li> <li>Compute the arrival delta-v (dv2), ensuring non-negative values.</li> <li>Compute the total time-of-flight (tofs) in years.</li> <li>Compute the total delta-v (dvtot) including all intermediate maneuvers.</li> <li>Compute the total cost as the sum of delta-v and weighted time-of-flight.</li> <li>Identify the trajectory with the minimum total cost.</li> </ol>"},{"location":"matlab/Cost%20functions/SODP/custom/costFunction2_DP_custom_vdep_varr/#function-signature","title":"Function Signature","text":"<pre><code>[minCOST, row, COSTS, TOFYS] = costFunction2_DP_custom_vdep_varr(legn, vvf, vinff, vdep, varr, sigma)\n</code></pre>"},{"location":"matlab/Dynamic%20programming/ASTRA_DP/","title":"<code>ASTRA_DP</code>","text":""},{"location":"matlab/Dynamic%20programming/ASTRA_DP/#description","title":"DESCRIPTION","text":"<p>This is a wrapper for all ASTRA functionalities.</p>"},{"location":"matlab/Dynamic%20programming/ASTRA_DP/#input","title":"INPUT","text":"<p>seq      : vector with planets IDs in the MGA sequence - chosenRevs : - res        : vector with N:M resonant ratio and number of leg at which the resonant transfer is needed. If no resonant transfer is needed, leave it empty. E.g. EVEMMMJ with 2:1 and 3:1 on MM legs would have: res = [ 2 1 4 3 1 5 ], where 4 and 5 are the legs in which the 2:1 and 3:1 occurr. - depOpts    : 1x2 vector. depOpts(1) is for initial date range (MJD2000), depOpts(2) is for final date range (MJD2000), and depOpts(3) is for step size (days) - opt        : (1) is for SODP, (2) is for MODP, (3) is for DATES, (4) is for YEARS - MODP - vInfOpts   : min/max departing infinity velocities (km/s) - dsmOpts    : max defect DSM (km/s), and total DSMs (km/s) - plot       : 1x2 vector. plot(1) is for plotting the best DV trajectory, plot(2) is for plotting the Pareto front. Please put plot(i)=1 if you want to plot the results. - parallel   : if 1, then parallel computing is used - tstep      : (days) discretization time step</p>"},{"location":"matlab/Dynamic%20programming/ASTRA_DP/#function-signature","title":"Function Signature","text":"<pre><code>[OUTPUT] = ASTRA_DP(seq, INPUT)\n</code></pre>"},{"location":"matlab/Dynamic%20programming/ASTRA_MODP_v2/","title":"<code>ASTRA_MODP_v2</code>","text":""},{"location":"matlab/Dynamic%20programming/ASTRA_MODP_v2/#function-signature","title":"Function Signature","text":"<pre><code>[OUTPUT] = ASTRA_MODP_v2(INPUT, seq)\n</code></pre>"},{"location":"matlab/Dynamic%20programming/ASTRA_SODP_v2/","title":"<code>ASTRA_SODP_v2</code>","text":""},{"location":"matlab/Dynamic%20programming/ASTRA_SODP_v2/#function-signature","title":"Function Signature","text":"<pre><code>[OUTPUT] = ASTRA_SODP_v2(INPUT, seq)\n</code></pre>"},{"location":"matlab/Dynamic%20programming/ASTRA_dates/","title":"<code>ASTRA_dates</code>","text":""},{"location":"matlab/Dynamic%20programming/ASTRA_dates/#description","title":"DESCRIPTION","text":"<p>This function uses SODP (Single Objective Direct Problem) to find the optimal trajectory for a spacecraft given a range of launch dates. It iteratively computes the trajectory and cost for each launch date, then post-processes the results to determine the minimum cost trajectory.</p>"},{"location":"matlab/Dynamic%20programming/ASTRA_dates/#input","title":"INPUT","text":"<ul> <li>INPUT : structure containing mission parameters, including launch date options, plotting options, and other necessary configurations.</li> <li>seq   : sequence of IDs for flyby bodies (see constants.m)</li> </ul>"},{"location":"matlab/Dynamic%20programming/ASTRA_dates/#output","title":"OUTPUT","text":"<ul> <li>OUTPUT : structure array containing the computed trajectories and their associated costs for each considered launch date.</li> </ul>"},{"location":"matlab/Dynamic%20programming/ASTRA_dates/#function-signature","title":"Function Signature","text":"<pre><code>[OUTPUT] = ASTRA_dates(INPUT, seq)\n</code></pre>"},{"location":"matlab/Dynamic%20programming/ASTRA_wrapPath_DP/","title":"<code>ASTRA_wrapPath_DP</code>","text":""},{"location":"matlab/Dynamic%20programming/ASTRA_wrapPath_DP/#description","title":"DESCRIPTION","text":"<p>this function allows for building the path matrix of an MGA sequence.</p>"},{"location":"matlab/Dynamic%20programming/ASTRA_wrapPath_DP/#input","title":"INPUT","text":"<p>seq   : vector with planets IDs in the MGA sequence t0    : departing epoch (MJD2000) tofs  : vector with time of fligth for each leg of the sequence (days) NREVS : nx3 matrix (n=length(seq)-1) on which the multiple revolutions options are passed. If NREVS(i,3)~=0, then a resonance is included in the transfer. idcentral  : ID of the central body. See constants.m customEphemerides : user-defined custom ephemerides. See EphSS_cartesian.m to define those</p>"},{"location":"matlab/Dynamic%20programming/ASTRA_wrapPath_DP/#output","title":"OUTPUT","text":"<p>path : is the path matrix fig  : if requested by the user, a figure with the trajectory is returned</p>"},{"location":"matlab/Dynamic%20programming/ASTRA_wrapPath_DP/#function-signature","title":"Function Signature","text":"<pre><code>[path, fig] = ASTRA_wrapPath_DP(seq, t0, tofs, NREVS, idcentral, customEphemerides)\n</code></pre>"},{"location":"matlab/Dynamic%20programming/ASTRA_years/","title":"<code>ASTRA_years</code>","text":""},{"location":"matlab/Dynamic%20programming/ASTRA_years/#description","title":"DESCRIPTION","text":"<p>This function divides the launch window in different years (365.25 days) and uses ASTRA with MODP successively for the different years.</p>"},{"location":"matlab/Dynamic%20programming/ASTRA_years/#input","title":"INPUT","text":"<ul> <li>chosenRevs :</li> <li>res        : vector with N:M resonant ratio and number of leg at which the resonant transfer is needed. If no resonant transfer is needed, leave it empty. E.g. EVEMMMJ with 2:1 and 3:1 on MM legs would have: res = [ 2 1 4 3 1 5 ], where 4 and 5 are the legs in which the 2:1 and 3:1 occurr.</li> <li>depOpts    : 1x2 vector. depOpts(1) is for initial date range (MJD2000), depOpts(2) is for final date range (MJD2000), and depOpts(3) is for step size (days)</li> <li>opt        : (1) is for SODP, (2) is for MODP, (3) is for DATES, (4) is for YEARS - MODP</li> <li>vInfOpts   : min/max departing infinity velocities (km/s)</li> <li>dsmOpts    : max defect DSM (km/s), and total DSMs (km/s)</li> <li>plot       : 1x2 vector. plot(1) is for plotting the best DV trajectory, plot(2) is for plotting the Pareto front. Please put plot(i)=1 if you want to plot the results.</li> <li>parallel   : if 1, then parallel computing is used</li> <li>tstep      : (days) discretization time step</li> </ul>"},{"location":"matlab/Dynamic%20programming/ASTRA_years/#input_1","title":"INPUT:","text":"<p>seq      : vector with planets IDs in the MGA sequence</p>"},{"location":"matlab/Dynamic%20programming/ASTRA_years/#function-signature","title":"Function Signature","text":"<pre><code>[OUTPUT] = ASTRA_years(INPUT, seq)\n</code></pre>"},{"location":"matlab/Dynamic%20programming/ASTRA_years_sodp/","title":"<code>ASTRA_years_sodp</code>","text":""},{"location":"matlab/Dynamic%20programming/ASTRA_years_sodp/#description","title":"DESCRIPTION","text":"<p>This function divides the launch window in different years (365.25 days) and uses ASTRA with SODP successively for the different years.</p>"},{"location":"matlab/Dynamic%20programming/ASTRA_years_sodp/#input","title":"INPUT","text":"<ul> <li>chosenRevs :</li> <li>res        : vector with N:M resonant ratio and number of leg at which the resonant transfer is needed. If no resonant transfer is needed, leave it empty. E.g. EVEMMMJ with 2:1 and 3:1 on MM legs would have: res = [ 2 1 4 3 1 5 ], where 4 and 5 are the legs in which the 2:1 and 3:1 occurr.</li> <li>depOpts    : 1x2 vector. depOpts(1) is for initial date range (MJD2000), depOpts(2) is for final date range (MJD2000), and depOpts(3) is for step size (days)</li> <li>opt        : (1) is for SODP, (2) is for MODP, (3) is for DATES, (4) is for YEARS - MODP</li> <li>vInfOpts   : min/max departing infinity velocities (km/s)</li> <li>dsmOpts    : max defect DSM (km/s), and total DSMs (km/s)</li> <li>plot       : 1x2 vector. plot(1) is for plotting the best DV trajectory, plot(2) is for plotting the Pareto front. Please put plot(i)=1 if you want to plot the results.</li> <li>parallel   : if 1, then parallel computing is used</li> <li>tstep      : (days) discretization time step</li> </ul>"},{"location":"matlab/Dynamic%20programming/ASTRA_years_sodp/#input_1","title":"INPUT:","text":"<p>seq      : vector with planets IDs in the MGA sequence</p>"},{"location":"matlab/Dynamic%20programming/ASTRA_years_sodp/#function-signature","title":"Function Signature","text":"<pre><code>[OUTPUT] = ASTRA_years_sodp(INPUT, seq)\n</code></pre>"},{"location":"matlab/Dynamic%20programming/refineUsingASTRApath/","title":"<code>refineUsingASTRApath</code>","text":""},{"location":"matlab/Dynamic%20programming/refineUsingASTRApath/#description","title":"DESCRIPTION","text":"<p>This function refines a given trajectory path using the ASTRA tool by searching for nearby trajectories with a finer grid resolution. The refined search is performed around the specified initial path parameters.</p>"},{"location":"matlab/Dynamic%20programming/refineUsingASTRApath/#input","title":"INPUT","text":"<ul> <li>path   : Matrix containing the trajectory path to be refined. Includes information on sequence, initial time, time of flights, and other relevant parameters.</li> <li>INPUT  : Struct containing various input parameters for the refinement process, including time windows, step sizes, revolution options, and resolution settings.</li> </ul>"},{"location":"matlab/Dynamic%20programming/refineUsingASTRApath/#output","title":"OUTPUT","text":"<ul> <li>OUTPUTref : Struct containing the refined trajectory information obtained from ASTRA. This includes the optimal trajectory parameters based on the finer search grid.</li> </ul>"},{"location":"matlab/Dynamic%20programming/refineUsingASTRApath/#function-signature","title":"Function Signature","text":"<pre><code>[OUTPUTref] = refineUsingASTRApath(path, INPUT)\n</code></pre>"},{"location":"matlab/Dynamic%20programming/wrap_MODP_st2/","title":"<code>wrap_MODP_st2</code>","text":""},{"location":"matlab/Dynamic%20programming/wrap_MODP_st2/#description","title":"DESCRIPTION","text":"<p>This function wraps the Multi-Objective Dynamic Programming (MODP) process for the second stage of trajectory optimization. It evaluates possible trajectories for the spacecraft, computes their feasibility, and prunes non-optimal paths using parallel or sequential processing. The function ultimately selects and saves the best trajectories based on a cost function.</p>"},{"location":"matlab/Dynamic%20programming/wrap_MODP_st2/#input","title":"INPUT","text":"<ul> <li>LEGSnext : Matrix containing the possible next legs (trajectories) of the spacecraft.</li> <li>VASnext  : Matrix of spacecraft velocities corresponding to LEGSnext.</li> <li>legs     : Matrix of initial trajectory legs (current mission plan).</li> <li>runOpts  : Options for running the dynamic programming algorithm.</li> <li>indl     : Index of the current leg being processed.</li> <li>tstep    : Time step used for generating the time of flight (TOF) array.</li> <li>TOF_LIM  : Limits on the time of flight for the leg.</li> <li>INPUT    : Struct containing additional input parameters, including DSM options and the parallel processing flag.</li> </ul>"},{"location":"matlab/Dynamic%20programming/wrap_MODP_st2/#output","title":"OUTPUT","text":"<ul> <li>LEGSn    : Matrix containing the next legs after processing and optimization.</li> <li>VASn     : Matrix of spacecraft velocities corresponding to the selected next legs.</li> <li>VINFn    : Vector of spacecraft hyperbolic excess velocities for the selected next legs.</li> <li>nLP      : Number of launch points (nodes) generated for the leg.</li> <li>nDEF     : Number of defects found in the dynamic programming step.</li> </ul>"},{"location":"matlab/Dynamic%20programming/wrap_MODP_st2/#function-signature","title":"Function Signature","text":"<pre><code>[LEGSn, VASn, VINFn, nLP, nDEF] = wrap_MODP_st2(LEGSnext, VASnext, legs, runOpts, indl, tstep, TOF_LIM, INPUT)\n</code></pre>"},{"location":"matlab/Dynamic%20programming/DP%20functions/wrap_DynProgr_st1/","title":"<code>wrap_DynProgr_st1</code>","text":""},{"location":"matlab/Dynamic%20programming/DP%20functions/wrap_DynProgr_st1/#description","title":"DESCRIPTION:","text":"<p>This function performs the first stage of dynamic programming for interplanetary trajectory optimization. It computes the possible legs, associated velocities, and incoming velocities for the next stage, considering the initial conditions and constraints. The function supports parallel processing to speed up calculations.</p>"},{"location":"matlab/Dynamic%20programming/DP%20functions/wrap_DynProgr_st1/#input","title":"INPUT:","text":"<p>T0      : Initial time (epoch) for the departure from the first planet. legs    : Matrix representing the sequence of planetary encounters, where each row corresponds to a leg. runOpts : Vector containing options for the Lambert solver, such as the method for solving the Lambert problem. tstep   : Time step (in days) used for generating possible times of flight. TOF_LIM : Vector containing the minimum and maximum time of flight limits for the legs.</p>"},{"location":"matlab/Dynamic%20programming/DP%20functions/wrap_DynProgr_st1/#output","title":"OUTPUT:","text":"<p>LEGSnext : Matrix containing the possible trajectory legs for the next stage, including the departure and arrival planets, departure and arrival times, and the delta-v required. VASnext  : Matrix containing the arrival velocities at the destination planets for each leg. VINFnext : Vector containing the incoming velocities at the destination planets for each leg. tocVec   : Scalar representing the elapsed time for the function execution. nLP      : Scalar representing the number of possible legs for the next stage.</p>"},{"location":"matlab/Dynamic%20programming/DP%20functions/wrap_DynProgr_st1/#function-signature","title":"Function Signature","text":"<pre><code>[LEGSnext, VASnext, VINFnext, tocVec, nLP] = wrap_DynProgr_st1(T0, legs, runOpts, tstep, TOF_LIM, INPUT)\n</code></pre>"},{"location":"matlab/Dynamic%20programming/DP%20functions/wrap_DynProgr_st2/","title":"<code>wrap_DynProgr_st2</code>","text":""},{"location":"matlab/Dynamic%20programming/DP%20functions/wrap_DynProgr_st2/#description","title":"DESCRIPTION:","text":"<p>This function performs dynamic programming for the second stage of the trajectory optimization. It calculates and prunes potential trajectory legs, computes defects, and applies cost functions to determine the optimal trajectory based on various constraints and input parameters.</p>"},{"location":"matlab/Dynamic%20programming/DP%20functions/wrap_DynProgr_st2/#input","title":"INPUT","text":"<ul> <li>dsmOpts : Vector specifying the maximum allowed defect delta-v and other related parameters.</li> </ul>"},{"location":"matlab/Dynamic%20programming/DP%20functions/wrap_DynProgr_st2/#input_1","title":"INPUT:","text":"<p>LEGSnext : Matrix containing the possible trajectory legs for the current iteration, where each row represents a leg with columns for departure and arrival planets, departure and arrival times, and the delta-v required. VASnext  : Matrix containing the arrival velocities at the destination planets for each leg. VINFn    : Vector containing the incoming velocities at the destination planets for each leg. legs     : Matrix specifying the sequence of planets and associated indices for processing. runOpts  : Matrix containing options for the Lambert solution, including the method and parameters. indl     : Index of the current leg being processed. tstep    : Time step for discretizing the trajectory. TOF_LIM  : Limits for time of flight constraints.</p>"},{"location":"matlab/Dynamic%20programming/DP%20functions/wrap_DynProgr_st2/#output","title":"OUTPUT:","text":"<p>LEGSn  : Matrix containing the trajectory legs after applying dynamic programming, pruning, and cost functions. VASn   : Matrix containing the arrival velocities for the filtered trajectory legs. VINFn  : Vector containing the incoming velocities for the filtered trajectory legs. nLP    : Number of possible legs considered in this stage. nDEF   : Number of defects calculated for the current set of trajectory legs.</p>"},{"location":"matlab/Dynamic%20programming/DP%20functions/wrap_DynProgr_st2/#function-signature","title":"Function Signature","text":"<pre><code>[LEGSn, VASn, VINFn, nLP, nDEF] = wrap_DynProgr_st2(LEGSnext, VASnext, legs, runOpts, indl, tstep, TOF_LIM, INPUT)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/approxEphem_CC/","title":"<code>approxEphem_CC</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/approxEphem_CC/#description","title":"DESCRIPTION","text":"<p>Approximate circular-coplanar ephemerides for different systems (e.g., Solar System planets, Juputer moons,...)</p>"},{"location":"matlab/Ephemerides%20%26%20constants/approxEphem_CC/#input","title":"INPUT","text":"<ul> <li>idmoon : ID of the flyby body (see constants.m)</li> <li>t : epoch [MJD2000]</li> <li>idcentral : ID of the central body (see constants.m)</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/approxEphem_CC/#output","title":"OUTPUT","text":"<ul> <li>rr  : 1x3 position vector of flyby body at epoch [km]</li> <li>vv  : 1x3 velocity vector of flyby body at epoch [km/s]</li> <li>kep : 1x6 keplerian elements of the flyby body at epoch (see car2kep.m)</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/approxEphem_CC/#function-signature","title":"Function Signature","text":"<pre><code>[rr, vv, kep] = approxEphem_CC(idmoon, t, idcentral)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/astroConstantsj2000/","title":"<code>astroConstantsj2000</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/astroConstantsj2000/#description","title":"DESCRIPTION","text":"<p>This function retrieves astronomical constants for a specified planet in the Solar System. It provides the planet's distance from the Sun (semi-major axis), gravitational parameter, and radius. If the specified planet is not available in the pre-defined list, it attempts to calculate the distance using ephemerides data.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/astroConstantsj2000/#input","title":"INPUT","text":"<ul> <li>pl    : Planet index (1 for Mercury, 2 for Venus, ..., 8 for Neptune)</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/astroConstantsj2000/#output","title":"OUTPUT","text":"<ul> <li>r     : Distance from the Sun (semi-major axis) in kilometers.</li> <li>radPL : Radius of the planet in kilometers.</li> <li>muPL  : Gravitational parameter of the planet in km^3/s^2.</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/astroConstantsj2000/#function-signature","title":"Function Signature","text":"<pre><code>[r, radPL, muPL] = astroConstantsj2000(pl)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/constants/","title":"<code>constants</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/constants/#description","title":"DESCRIPTION","text":"<p>This function extracts central body and flyby body parameters. It assumes circular coplanar orbits of the flyby bodies around the central body. Each flyby body is assumed to be a perfect sphere.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/constants/#input","title":"INPUT","text":"<ul> <li>idcentral : ID of the central body 1:  Sun 30: Earth 5:  Jupiter 6:  Saturn 7:  Uranus</li> <li>pl        : ID of the flyby body, depending on the idpl if idcentral = 0: flyby body ID (1. Mercury, 2. Venus, 3. Earth, 4. Mars, 5. Jupiter, ...</li> <li>Saturn, 7. Uranus, 8. Neptune) if idcentral = 30 flyby body ID (0. Moon) if idcentral = 5 flyby body ID (1. Io, 2. Europa, 3. Ganimede, 4. Callisto) if idcentral = 6 flyby body ID (0. Mimas, 1. Enceladus, 2. Tethys, 3. Dione, 4. Rhea, 5. Titan) if idcentral = 7 flyby body ID (1. Miranda, 2. Ariel, 3. Umbriel, 4. Titania, 5. Oberon)</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/constants/#output","title":"OUTPUT","text":"<ul> <li>muCentral : gravitational parameter of the central body [km3/s2]</li> <li>mupl      : gravitational parameter of the flyby body [km3/s2]</li> <li>rpl       : circular orbit radius of the flyby body [km]</li> <li>radpl     : circular radius of the flyby body [km]</li> <li>hmin      : minimum altitude for the flyby [km]</li> <li>Tpl       : orbital period of the flyby body [s]</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/constants/#function-signature","title":"Function Signature","text":"<pre><code>[muCentral, mupl, rpl, radpl, hmin, Tpl] = constants(idcentral, pl)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/generateEPH/","title":"<code>generateEPH</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/generateEPH/#description","title":"DESCRIPTION:","text":"<p>This function generates an ephemeris matrix by computing the Cartesian position and velocity vectors for each time pair in the provided matrix. The result includes both the input time pairs and the computed vectors.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/generateEPH/#input","title":"INPUT:","text":"<p>M                 : Matrix where each row contains a time pair with the format [planet ID, time]. The matrix represents either departure or arrival times. idcentral         : ID of the central body. See constants.m customEphemerides : user-defined custom ephemerides. See EphSS_cartesian.m for reference</p>"},{"location":"matlab/Ephemerides%20%26%20constants/generateEPH/#output","title":"OUTPUT:","text":"<p>EPH : Matrix where each row includes the original time pair followed by the Cartesian position (rr) and velocity (vv) vectors. The matrix has 8 columns in total: [planet ID, time, rr (3 columns), vv (3 columns)]. NOTES: - <code>EphSS_cartesian</code> is a helper function that computes the Cartesian position and velocity vectors for given object ID and time.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/generateEPH/#function-signature","title":"Function Signature","text":"<pre><code>[EPH] = generateEPH(M, idcentral, customEphemerides)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/generateMAT/","title":"<code>generateMAT</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/generateMAT/#description","title":"DESCRIPTION:","text":"<p>This function generates a matrix of possible time pairs for a given trajectory leg, based on the departure and arrival planets, the initial times, and the time of flight constraints. It also creates matrices for unique departure and arrival time pairs.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/generateMAT/#input","title":"INPUT:","text":"<p>pl1  : Integer representing the departure planet ID. pl2  : Integer representing the arrival planet ID. T0   : Vector containing the possible initial times for the trajectory legs. TOFS : Vector containing the possible times of flight for the trajectory legs.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/generateMAT/#output","title":"OUTPUT:","text":"<p>MAT  : Matrix of possible time pairs for the trajectory legs. Each row represents a potential trajectory with columns for departure planet ID, initial time, arrival planet ID, and arrival time. M1   : Matrix of unique departure time pairs (departure planet ID and initial time). M2   : Matrix of unique arrival time pairs (arrival planet ID and arrival time).</p>"},{"location":"matlab/Ephemerides%20%26%20constants/generateMAT/#function-signature","title":"Function Signature","text":"<pre><code>[MAT, M1, M2] = generateMAT(pl1, pl2, T0, TOFS)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/maxmin_flybyAltitude/","title":"<code>maxmin_flybyAltitude</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/maxmin_flybyAltitude/#description","title":"DESCRIPTION","text":"<p>This function extracts minimum and maximum flyby altitudes for Solar System planets.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/maxmin_flybyAltitude/#input","title":"INPUT","text":"<ul> <li>pl : flyby body ID (1. Mercury, 2. Venus, 3. Earth, 4. Mars, 5. Jupiter, 6. Saturn, 7. Uranus, 8. Neptune)</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/maxmin_flybyAltitude/#output","title":"OUTPUT","text":"<ul> <li>hmin : minimum altitude for the flyby [km]</li> <li>hmax : maximum altitude for the flyby [km]</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/maxmin_flybyAltitude/#function-signature","title":"Function Signature","text":"<pre><code>[hmin, hmax] = maxmin_flybyAltitude(pl)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/planet_names_GA/","title":"<code>planet_names_GA</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/planet_names_GA/#description","title":"DESCRIPTION","text":"<p>This function gives strings with intials and full names of flyby bodies depending upon the selected system (see also constants.m).</p>"},{"location":"matlab/Ephemerides%20%26%20constants/planet_names_GA/#input","title":"INPUT","text":"<ul> <li>planet_id : ID of the flyby body (see also constants.m)</li> <li>idcentral : ID of the central body (see also constants.m)</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/planet_names_GA/#output","title":"OUTPUT","text":"<ul> <li>planet     : string with initial letter for the flyby body</li> <li>fullName   : string with full name of the flyby body</li> <li>cenralName : string with full name of the central body</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/planet_names_GA/#function-signature","title":"Function Signature","text":"<pre><code>[planet, fullName, cenralName] = planet_names_GA(planet_id, idcentral)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/wrap_generateEPH/","title":"<code>wrap_generateEPH</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/wrap_generateEPH/#description","title":"DESCRIPTION:","text":"<p>This function generates a combined ephemeris matrix by generating ephemeris data for two sets of planetary time pairs, and then combining and deduplicating the results.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/wrap_generateEPH/#input","title":"INPUT:","text":"<p>M1                : Matrix of unique departure time pairs, where each row contains departure planet ID and initial time. M2                : Matrix of unique arrival time pairs, where each row contains arrival planet ID and arrival time. idcentral         : ID of the central body. See constants.m customEphemerides : user-defined custom ephemerides. See EphSS_cartesian.m for reference</p>"},{"location":"matlab/Ephemerides%20%26%20constants/wrap_generateEPH/#output","title":"OUTPUT:","text":"<p>EPH : Combined ephemeris matrix containing unique rows of ephemeris data for both departure and arrival time pairs. NOTES: - <code>generateEPH</code> is a helper function that produces ephemeris data for given time pairs. - The output matrix <code>EPH</code> is unique and ordered based on the rows to ensure no duplicates and maintain stability.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/wrap_generateEPH/#function-signature","title":"Function Signature","text":"<pre><code>[EPH] = wrap_generateEPH(M1, M2, idcentral, customEphemerides)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/EphSS_from_mice/","title":"<code>EphSS_from_mice</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/EphSS_from_mice/#description","title":"DESCRIPTION","text":"<p>This function interfaces with the NASA NAIF MICE Toolkit to extract the position and velocity vectors of a solar system body at a given time. It is specifically designed for multiple gravity assist trajectory design.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/EphSS_from_mice/#input","title":"INPUT","text":"<ul> <li>IDspk     : SPICE ID of the body (e.g., 399 for Earth). If the ID is &lt; 5, the function appends '99' (e.g., 3 becomes 399) to comply with standard NAIF object codes for planets.</li> <li>t         : epoch in Modified Julian Date 2000 (MJD2000).</li> <li>idcentral : (optional) identifier for the central body; currently only supports value 1 (i.e., the Sun-centric frame).</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/EphSS_from_mice/#output","title":"OUTPUT","text":"<ul> <li>rr : 1x3 position vector [km] of the body in the ecliptic J2000 frame</li> <li>vv : 1x3 velocity vector [km/s] of the body in the ecliptic J2000 frame</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/EphSS_from_mice/#function-signature","title":"Function Signature","text":"<pre><code>[rr, vv] = EphSS_from_mice(IDspk, t, idcentral)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/EphSS_from_mice_workaround/","title":"<code>EphSS_from_mice_workaround</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/EphSS_from_mice_workaround/#function-signature","title":"Function Signature","text":"<pre><code>[rr, vv] = EphSS_from_mice_workaround(IDspk, t, idcentral)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/getSPK/","title":"<code>getSPK</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/getSPK/#description","title":"DESCRIPTION","text":"<p>This function retrieves a Spacecraft and Planet Kernel (SPK) file from NASA's Horizons API for a specified object and time range, saving it to a given directory. If a file with the same name already exists, the function either overwrites it (if the overwrite flag is set) or stops execution with a warning.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/getSPK/#input","title":"INPUT","text":"<ul> <li>spk_id  : string specifying the SPK ID of the target object.</li> <li>date_i  : string specifying the start date for the SPK file in a format accepted by the Horizons API.</li> <li>date_f  : string specifying the end date for the SPK file in a format accepted by the Horizons API.</li> <li>spk_dir : string specifying the directory where the SPK file should be saved. If empty, the file is saved in the current directory.</li> <li>varargin: optional parameters: 'overwrite', 'on'  -&gt; Overwrites an existing SPK file. 'overwrite', 'off' -&gt; Prevents overwriting (default). 'warning', 'on'    -&gt; Displays a warning if the file exists (default). 'warning', 'off'   -&gt; Suppresses warnings if the file exists.</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/getSPK/#output","title":"OUTPUT","text":"<ul> <li>success : binary flag indicating success (1) or failure (0) in retrieving and saving the SPK file.</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/getSPK/#function-signature","title":"Function Signature","text":"<pre><code>[success] = getSPK(spk_id,date_i,date_f,spk_dir,varargin)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/processDate/","title":"<code>processDate</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/processDate/#description","title":"DESCRIPTION","text":"<p>This function converts an input time expressed in Modified Julian Date 2000 (MJD2000) into a formatted date string compatible with the NASA NAIF MICE Toolkit. It is primarily used for trajectory design problems involving multiple gravity assists.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/processDate/#input","title":"INPUT","text":"<ul> <li>t    : time in Modified Julian Date 2000 (MJD2000)</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/processDate/#output","title":"OUTPUT","text":"<ul> <li>date : formatted date string 'YYYY MM DD HH.mmssssssss' (TDB time scale) to be passed to SPICE functions such as cspice_str2et</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Eph_MICE_interface/processDate/#function-signature","title":"Function Signature","text":"<pre><code>[date] = processDate(t)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Jupiter%20system/approxEphemJupMoons_cc/","title":"<code>approxEphemJupMoons_cc</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Jupiter%20system/approxEphemJupMoons_cc/#description","title":"DESCRIPTION","text":"<p>This function provides an approximation of the ephemerides for Jupiter's moons (Io, Europa, Ganymede, and Callisto) using Keplerian elements. It is intended for use in Delta-V (DV) and time of flight (TOF) analyses but not for mission design purposes.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Jupiter%20system/approxEphemJupMoons_cc/#input","title":"INPUT","text":"<ul> <li>idmoon : Integer identifier for the Jupiter moon: 1 --&gt; Io 2 --&gt; Europa 3 --&gt; Ganymede 4 --&gt; Callisto</li> <li>t      : Time of interest in Modified Julian Date (MJD2000).</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Jupiter%20system/approxEphemJupMoons_cc/#output","title":"OUTPUT","text":"<ul> <li>rr     : Position vector of the moon at time t (in kilometers).</li> <li>vv     : Velocity vector of the moon at time t (in kilometers per second).</li> <li>kep    : Keplerian elements of the moon at time t.</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Jupiter%20system/approxEphemJupMoons_cc/#process","title":"PROCESS","text":"<ul> <li>Defines reference epoch and initial Keplerian elements for each moon.</li> <li>Computes the position and velocity vectors by propagating the initial Keplerian elements to the given time using the FGKepler_dt function.</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Jupiter%20system/approxEphemJupMoons_cc/#function-signature","title":"Function Signature","text":"<pre><code>[rr, vv, kep] = approxEphemJupMoons_cc(idmoon, t)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Jupiter%20system/jupMoonsConstants/","title":"<code>jupMoonsConstants</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Jupiter%20system/jupMoonsConstants/#description","title":"DESCRIPTION","text":"<p>This function extracts physical and orbital parameters of main Juoiter moons.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Jupiter%20system/jupMoonsConstants/#input","title":"INPUT","text":"<ul> <li>idMO : moon ID (1. Io, 2. Europa, 3. Ganimede, 4. Callisto)</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Jupiter%20system/jupMoonsConstants/#output","title":"OUTPUT","text":"<ul> <li>rcm  : circular orbit radius of the body [km]</li> <li>mum  : gravitational parameter of the body [km3/s2]</li> <li>radm : circular radius of the body [km]</li> <li>hmin : minimum altitude for the flyby [km]</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Jupiter%20system/jupMoonsConstants/#function-signature","title":"Function Signature","text":"<pre><code>[rcm, mum, radm, hmin] = jupMoonsConstants(idMO)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Saturn%20system/approxEphemSatMoons_cc/","title":"<code>approxEphemSatMoons_cc</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Saturn%20system/approxEphemSatMoons_cc/#description","title":"DESCRIPTION","text":"<p>Approximate ephemerides of Saturn moons, assumed to be in circular coplanar orbits around Saturn. The reference epoch is 2030-01-01.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Saturn%20system/approxEphemSatMoons_cc/#input","title":"INPUT","text":"<ul> <li>idmoon :</li> <li>t      : epoch at which the ephemerides are computed [MJD2000]</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Saturn%20system/approxEphemSatMoons_cc/#output","title":"OUTPUT","text":"<ul> <li>rr  : 1x3 vector with moon position [km]</li> <li>vv  : 1x3 vector with moon velocity [km]</li> <li>kep : 1x6 vector with keplerian elements (see car2kep.m)</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Saturn%20system/approxEphemSatMoons_cc/#function-signature","title":"Function Signature","text":"<pre><code>[rr, vv, kep] = approxEphemSatMoons_cc(idmoon, t)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Saturn%20system/satMoonsConstants/","title":"<code>satMoonsConstants</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Saturn%20system/satMoonsConstants/#description","title":"DESCRIPTION","text":"<p>This function extracts physical and orbital parameters of main Saturn moons.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Saturn%20system/satMoonsConstants/#input","title":"INPUT","text":"<ul> <li>idMO : moon ID (0. Mimas, 1. Enceladus, 2. Tethys, 3. Dione, 4. Rhea, 5. Titan)</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Saturn%20system/satMoonsConstants/#output","title":"OUTPUT","text":"<ul> <li>rcm  : circular orbit radius of the body [km]</li> <li>mum  : gravitational parameter of the body [km3/s2]</li> <li>radm : circular radius of the body [km]</li> <li>hmin : minimum altitude for the flyby [km]</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Saturn%20system/satMoonsConstants/#function-signature","title":"Function Signature","text":"<pre><code>[rcm, mum, radm, hmin] = satMoonsConstants(idMO)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/EphSS_car/","title":"<code>EphSS_car</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/EphSS_car/#description","title":"DESCRIPTION:","text":"<p>It uses uplanet for planets, moon_eph for the Moon, and NeoEphemeris for asteroid ephemerides. Outputs cartesian position and velocity of the body, centered in the Sun for all the bodies but the Moon (for which a cartesian Earth-centered reference frame is chosen).</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/EphSS_car/#input","title":"INPUT:","text":"<p>n[1]    ID of the body: 1 to 9: Planets t[1]    Time [d, MJD2000]. That is: modified Julian day since 01/01/2000, 12:00 noon (MJD2000 = MJD-51544.5)</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/EphSS_car/#output","title":"OUTPUT:","text":"<p>r[1,3]  Cartesian position of the body (Sun-centered for all bodies). v[1,3]  Cartesian velocity.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/EphSS_car/#function-signature","title":"Function Signature","text":"<pre><code>[r,v,kep] = EphSS_car(n,t)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/EphSS_cartesian/","title":"<code>EphSS_cartesian</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/EphSS_cartesian/#description","title":"DESCRIPTION:","text":"<p>This function computes the Cartesian position (rr) and velocity (vv) vectors for a given celestial body at a specific time. It uses different ephemeris functions depending on the type of body, such as planets, asteroids, or other objects.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/EphSS_cartesian/#input","title":"INPUT:","text":"<p>pl : Identifier for the celestial body. - Values &lt;= 10 correspond to planets in the Solar System. - Values between 11 and 473 correspond to Jupiter-family comets. - Values between 474 and 1183 correspond to Centaurs. - Value 1194 corresponds to the asteroid Lutetia. - Other values are handled by a default ephemeris function. t          : Time at which the position and velocity vectors are to be computed. idcentral  : ID of the central body. See constants.m</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/EphSS_cartesian/#output","title":"OUTPUT:","text":"<p>rr : Cartesian position vector of the celestial body (3x1 vector). vv : Cartesian velocity vector of the celestial body (3x1 vector). FUNCTION CALLS: EphSS_car    : Computes ephemeris for planets in the Solar System. EphCA_car    : Computes ephemeris for Jupiter-family comets. EphCE_car    : Computes ephemeris for Centaurs. EphLutetia   : Computes ephemeris for the asteroid Lutetia. EphLOWq      : Computes ephemeris for other celestial bodies not covered by the specific cases.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/EphSS_cartesian/#function-signature","title":"Function Signature","text":"<pre><code>[rr, vv] = EphSS_cartesian(pl, t, idcentral)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/planetConstants/","title":"<code>planetConstants</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/planetConstants/#description","title":"DESCRIPTION","text":"<p>This function extracts body parameters for Solar System planets, assuming circular coplanar orbits of the flyby bodies around the central body. Each body is assumed to be a perfect sphere.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/planetConstants/#input","title":"INPUT","text":"<ul> <li>idPL : flyby body ID (1. Mercury, 2. Venus, 3. Earth, 4. Mars, 5. Jupiter, 6. Saturn, 7. Uranus, 8. Neptune)</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/planetConstants/#output","title":"OUTPUT","text":"<ul> <li>muPL   : gravitational parameter of the body [km3/s2]</li> <li>radius : circular radius of the body [km]</li> <li>sma    : semi-major axis of the body [km]</li> <li>rpMin  : minimum periapsis radius of the body in the 2000-2100 timeframe [km]</li> <li>raMin  : minimum apoapsis radius of the body in the 2000-2100 timeframe [km]</li> <li>hmin   : minimum altitude for the flyby [km]</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/planetConstants/#function-signature","title":"Function Signature","text":"<pre><code>[muPL, radius, sma, rpMin, raMin, hmin] = planetConstants(idPL)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/uplanet/","title":"<code>uplanet</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/uplanet/#description","title":"DESCRIPTION:","text":"<p>Planetary orbital elements are restituited in a Sun-centred ecliptic system. These ephemerides were succesfully compared with JPL/NAIF/SPICE ephemerides using de405.bps.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/uplanet/#input","title":"INPUT","text":"<p>mjd2000[1]  Time, modified Julian day since 01/01/2000, 12:00 noon (MJD2000 = MJD-51544.5) ibody[1]    Integer number identifying the celestial body (&lt; 11) 1:   Mercury 2:   Venus 3:   Earth 4:   Mars 5:   Jupiter 6:   Saturn 7:   Uranus 8:   Neptune 9:   Pluto 10:  Sun</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/uplanet/#output","title":"OUTPUT:","text":"<p>kep[6]      Mean Keplerian elements of date kep = [a e i Om om theta] [km, rad] ksun[1]     Gravity constant of the Sun [km^3/s^2] Note: The ephemerides of the Moon are given by EphSS_kep, according to to the algorithm in ephMoon.m AUTHOR: P. Dysli, 1977 PREVIOUS VERSION: P. Dysli, 1977, MATLAB, uplanet.m - Header and function name in accordance with guidlines.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/uplanet/#function-signature","title":"Function Signature","text":"<pre><code>[kep] = uplanet(mjd2000, ibody)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/Other%20bodies/EphCA_car/","title":"<code>EphCA_car</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/Other%20bodies/EphCA_car/#inputs","title":"INPUTS:","text":"<p>n: ID of the comet. [ND] t: epoch at which the ephemerides should be computed. [MJD2000]</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/Other%20bodies/EphCA_car/#outputs","title":"OUTPUTS:","text":"<p>rr: vector [1x3] containing position of the comet. [km] vv: vector [1x3] containing velocity of the comet. [km/s] kep: keplerian elements for the comet. [sma, ecc, incl, Om, om, th] (it can be added as output). NOTE: All the inputs required by the user are designed as 'user input'. Functions used: propagateKepler.m car2kep.m Author: Andrea Bellome (main structure). Jose Ignacio Rico Alvarez (modifications to apply the code for all the considered comets). History of modifications: Creation date: 18 - June - 2021</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/Other%20bodies/EphCA_car/#function-signature","title":"Function Signature","text":"<pre><code>[rr, vv, kep] = EphCA_car(n, t)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/Other%20bodies/EphCE_car/","title":"<code>EphCE_car</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/Other%20bodies/EphCE_car/#inputs","title":"INPUTS:","text":"<p>n: ID of the comet. [ND] t: epoch at which the ephemerides should be computed. [MJD2000]</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/Other%20bodies/EphCE_car/#outputs","title":"OUTPUTS:","text":"<p>rr: vector [1x3] containing position of the comet. [km] vv: vector [1x3] containing velocity of the comet. [km/s] kep: keplerian elements for the comet. [sma, ecc, incl, Om, om, th] (it can be added as output). NOTE: All the inputs required by the user are designed as 'user input'. Functions used: propagateKepler.m car2kep.m Author: Andrea Bellome (main structure). Jose Ignacio Rico Alvarez (modifications to apply the code for all the considered comets). History of modifications: Creation date: 18 - June - 2021</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/Other%20bodies/EphCE_car/#function-signature","title":"Function Signature","text":"<pre><code>[rr, vv, kep] = EphCE_car(n, t)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/Other%20bodies/EphLOWq/","title":"<code>EphLOWq</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/Other%20bodies/EphLOWq/#function-signature","title":"Function Signature","text":"<pre><code>[rr, vv] = EphLOWq(idcom, t)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/Other%20bodies/EphLutetia/","title":"<code>EphLutetia</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Solar%20System/Other%20bodies/EphLutetia/#function-signature","title":"Function Signature","text":"<pre><code>[rr, vv] = EphLutetia(pl, t)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Uranus%20system/approxEphemUraMoons_cc/","title":"<code>approxEphemUraMoons_cc</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Uranus%20system/approxEphemUraMoons_cc/#inputs","title":"INPUTS","text":"<ul> <li>idmoon: number indicating which Uranus moon to consider.</li> <li>t: Epoch at which moon state vector &amp; Orbital Elements are to be computed, expressed in days past since MJD2000. OUTPUTS %%</li> <li>rr: Moon position vector components  at the desired epoch in [km].</li> <li>vv: Moon velocity vector components at the desired epoch in [km/s].</li> <li>kep: 1x6 vector of orbital elements ordered as [a, e, i, Om, om, th], where th is the true anomaly. Angles in [rad], semi-major axis in [km]. CHANGELOG %% 27/08/2024, J.C Garcia Mateas: corrected the Orbital Elements for the reference epoch &amp; added function description &amp; comments. FUNCTIONS %%</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Uranus%20system/approxEphemUraMoons_cc/#function-signature","title":"Function Signature","text":"<pre><code>[rr, vv, kep] = approxEphemUraMoons_cc(idmoon, t)\n</code></pre>"},{"location":"matlab/Ephemerides%20%26%20constants/Uranus%20system/uranusMoonsConstants/","title":"<code>uranusMoonsConstants</code>","text":""},{"location":"matlab/Ephemerides%20%26%20constants/Uranus%20system/uranusMoonsConstants/#description","title":"DESCRIPTION","text":"<p>This function extracts physical and orbital parameters of main Uranus moons.</p>"},{"location":"matlab/Ephemerides%20%26%20constants/Uranus%20system/uranusMoonsConstants/#input","title":"INPUT","text":"<ul> <li>idMO : moon ID (1. Miranda, 2. Ariel, 3. Umbriel, 4. Titania, 5. Oberon)</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Uranus%20system/uranusMoonsConstants/#output","title":"OUTPUT","text":"<ul> <li>rcm  : circular orbit radius of the body [km]</li> <li>mum  : gravitational parameter of the body [km3/s2]</li> <li>radm : circular radius of the body [km]</li> <li>hmin : minimum altitude for the flyby [km]</li> </ul>"},{"location":"matlab/Ephemerides%20%26%20constants/Uranus%20system/uranusMoonsConstants/#function-signature","title":"Function Signature","text":"<pre><code>[rcm, mum, radm, hmin] = uranusMoonsConstants(idMO)\n</code></pre>"},{"location":"matlab/Lambert%20problem%20and%20defects/findDV/","title":"<code>findDV</code>","text":""},{"location":"matlab/Lambert%20problem%20and%20defects/findDV/#description","title":"DESCRIPTION","text":"<p>This function computes DV defects.</p>"},{"location":"matlab/Lambert%20problem%20and%20defects/findDV/#input","title":"INPUT","text":"<ul> <li>vvrel_A : 1x3 vector with incoming relative velocity [km/s]</li> <li>vvrel_D : 1x3 vector with outgoing relative velocity [km/s]</li> <li>muPL    : gravitational parameter of the flyby body [km3/s2]</li> <li>rpmin   : minimum flyby periapsis [km]</li> </ul>"},{"location":"matlab/Lambert%20problem%20and%20defects/findDV/#output","title":"OUTPUT","text":"<ul> <li>dv      : DV defect manoeuvre [km/s]</li> <li>alpha   : deflection required for the flyby [rad]</li> <li>alpha_A : max. deflection for the minimum periapsis flyby [rad]</li> </ul>"},{"location":"matlab/Lambert%20problem%20and%20defects/findDV/#function-signature","title":"Function Signature","text":"<pre><code>[dv, alpha, alpha_A] = findDV(vvrel_A, vvrel_D, muPL, rpmin)\n</code></pre>"},{"location":"matlab/Lambert%20problem%20and%20defects/lambertMR_MEXIFY/","title":"<code>lambertMR_MEXIFY</code>","text":""},{"location":"matlab/Lambert%20problem%20and%20defects/lambertMR_MEXIFY/#description","title":"DESCRIPTION","text":"<p>Lambert problem solution for Keplerian dynamics and for prograde orbits only.</p>"},{"location":"matlab/Lambert%20problem%20and%20defects/lambertMR_MEXIFY/#input","title":"INPUT","text":"<ul> <li>RI    : 1x3 vector with initial position [km]</li> <li>RF    : 1x3 vector with final position [km]</li> <li>TOF   : time of flight [sec]</li> <li>MU    : gravitational parameter of the central body [km3/s2]</li> <li>Nrev  : integer number of revolutions</li> <li>Ncase : if 0, then low-energy is selected, if 1, then high energy</li> </ul>"},{"location":"matlab/Lambert%20problem%20and%20defects/lambertMR_MEXIFY/#output","title":"OUTPUT","text":"<ul> <li>VI : 1x3 vector with initial velocity [km/s]</li> <li>VF : 1x3 vector with final velocity [km/s]</li> </ul>"},{"location":"matlab/Lambert%20problem%20and%20defects/lambertMR_MEXIFY/#function-signature","title":"Function Signature","text":"<pre><code>[VI,VF] = lambertMR_MEXIFY(RI, RF, TOF, MU, Nrev, Ncase)\n</code></pre>"},{"location":"matlab/Lambert%20problem%20and%20defects/maxRev_LP/","title":"<code>maxRev_LP</code>","text":""},{"location":"matlab/Lambert%20problem%20and%20defects/maxRev_LP/#description","title":"DESCRIPTION","text":"<p>This function computes the maximum number of revolutions allowed for a Lambert arc based on the given time of flight and positions. It provides an estimate of how many full revolutions can fit within the provided transfer time, assuming the minimum semi-major axis for the two-body orbit connecting the input positions.</p>"},{"location":"matlab/Lambert%20problem%20and%20defects/maxRev_LP/#input","title":"INPUT","text":"<ul> <li>tof_days   : time of flight for the transfer arc [days]</li> <li>rr1        : initial position vector [km]</li> <li>rr2        : final position vector [km]</li> <li>muCentral  : gravitational parameter of the central body [km^3/s^2]</li> </ul>"},{"location":"matlab/Lambert%20problem%20and%20defects/maxRev_LP/#output","title":"OUTPUT","text":"<ul> <li>NumRevMax : maximum number of full revolutions feasible within the given time of flight [-]</li> </ul>"},{"location":"matlab/Lambert%20problem%20and%20defects/maxRev_LP/#function-signature","title":"Function Signature","text":"<pre><code>[NumRevMax] = maxRev_LP(tof_days, rr1, rr2, muCentral)\n</code></pre>"},{"location":"matlab/Low%20thrust/lowThrustFromASTRASolution/","title":"<code>lowThrustFromASTRASolution</code>","text":""},{"location":"matlab/Low%20thrust/lowThrustFromASTRASolution/#description","title":"DESCRIPTION","text":"<p>This function is used to process the ASTRA solution for low-thrust trajectory optimization. It processes the trajectory data, computes the thrust profile, and solves for the optimal solution based on the given parameters and constraints. If the thrust system is insufficient for any leg of the trajectory, it terminates early. It generates an output structure that includes the trajectory details, including mass evolution, delta-v, and time of flight for each leg of the mission.</p>"},{"location":"matlab/Low%20thrust/lowThrustFromASTRASolution/#input","title":"INPUT","text":"<ul> <li>astraSolution : structure containing ASTRA solution data</li> <li>path      : trajectory path data</li> <li>revs      : revolutions' options for each leg</li> <li>res       : resonance options for each leg</li> <li>vdep_free : velocity for free departure [km/s]</li> <li>varr_free : velocity for free arrival [km/s]</li> <li>lowThrustParameters : structure containing low-thrust trajectory parameters</li> <li>Tmax          : maximum thrust [N]</li> <li>Isp           : specific impulse [s]</li> <li>m0            : initial mass [kg]</li> <li>gamma         : discount factor for the smoothing parameter (default is 0.5)</li> <li>rhoLim        : limit on the smoothing parameter for optimal control solution (default is 0.001)</li> <li>plot          : boolean flag to enable plotting of the thrust profile (default is false)</li> <li>useParallel   : boolean flag to enable parallel computation (default is false)</li> <li>g0            : gravitational acceleration constant [m/s^2]</li> <li>idcentral         : ID of the central body for the transfer</li> <li>customEphemerides : function handle for custom ephemerides</li> </ul>"},{"location":"matlab/Low%20thrust/lowThrustFromASTRASolution/#output","title":"OUTPUT","text":"<ul> <li>LT_SOLUTION : structure containing the low-thrust trajectory solution</li> <li>LTsol : low-thrust solution for each leg, including mass, time of flight, delta-v, and other trajectory details</li> <li>m0                : initial mass at the beginning of the leg</li> <li>mf                : final mass after the leg</li> <li>mp                : mass change during the leg</li> <li>DV                : delta-v for the leg</li> <li>tof               : time of flight for the leg</li> <li>cumulative_tof    : cumulative time of flight for all legs</li> </ul>"},{"location":"matlab/Low%20thrust/lowThrustFromASTRASolution/#function-signature","title":"Function Signature","text":"<pre><code>[LT_SOLUTION, struc] = lowThrustFromASTRASolution( astraSolution, lowThrustParameters, idcentral, customEphemerides )\n</code></pre>"},{"location":"matlab/Low%20thrust/wrapSolveFopt/","title":"<code>wrapSolveFopt</code>","text":""},{"location":"matlab/Low%20thrust/wrapSolveFopt/#description","title":"DESCRIPTION","text":"<p>This function solves the fuel-optimal low-thrust problem.</p>"},{"location":"matlab/Low%20thrust/wrapSolveFopt/#input","title":"INPUT:","text":"<ul> <li>param: structure with the required parameters from processDataAndWriteParam.m</li> </ul>"},{"location":"matlab/Low%20thrust/wrapSolveFopt/#output","title":"OUTPUT:","text":"<ul> <li>LTsol: structure with the following fields:</li> <li>transfer : Matrix containing the processed trajectory data with the following columns: [time (days), position (km), velocity (km/s), mass (kg), thrust magnitude (N), thrust vector (N)].</li> <li>lambdas: initial conditions for the co-states for fuel-optimal problem</li> <li>Tmax    : max. thrust [N]</li> <li>Isp     : specific impulse [s]</li> <li>g0      : gravitational acceleration at sea level [m/s2]</li> <li>m0      : initial mass [kg]</li> <li>mf      : final mass [kg]</li> <li>tof     : time of flight [days]</li> <li>DV      : DV of the low-thrust transfer [km/s]</li> <li>param   : structure with relevant parameters for the solution</li> <li>success : boolean to check if the solver has succeeded or not</li> </ul>"},{"location":"matlab/Low%20thrust/wrapSolveFopt/#function-signature","title":"Function Signature","text":"<pre><code>[LTsol] = wrapSolveFopt( param )\n</code></pre>"},{"location":"matlab/Low%20thrust/Plot_low_thrust/plotLT/","title":"<code>plotLT</code>","text":""},{"location":"matlab/Low%20thrust/Plot_low_thrust/plotLT/#description","title":"DESCRIPTION","text":"<p>This function plots the trajectory, mass evolution, and thrust magnitude for a low-thrust space trajectory. Depending on the number of requested</p>"},{"location":"matlab/Low%20thrust/Plot_low_thrust/plotLT/#input","title":"INPUT","text":"<ul> <li>transfer: Matrix containing trajectory and associated parameters: Column 1  : Time [days] Columns 2-4: Position (x, y, z) [km] Columns 5-7: Velocity (vx, vy, vz) [km/s] Column 8  : Spacecraft mass [kg] Column 9  : Thrust magnitude [N]</li> <li>param: Structure containing simulation parameters:</li> <li>param.AU: Astronomical Unit [m], used to scale positions to AU</li> </ul>"},{"location":"matlab/Low%20thrust/Plot_low_thrust/plotLT/#output","title":"OUTPUT","text":"<ul> <li>Trajectory in 3D space</li> <li>Mass evolution over time</li> <li>Thrust magnitude over time</li> <li>figTRAJ   : Figure handle for the trajectory plot</li> <li>figMASS   : Figure handle for the mass evolution plot (optional)</li> <li>figTHRmag : Figure handle for the thrust magnitude plot (optional)</li> </ul>"},{"location":"matlab/Low%20thrust/Plot_low_thrust/plotLT/#function-signature","title":"Function Signature","text":"<pre><code>[figTRAJ, figMASS, figTHRmag] = plotLT( transfer, param, holdon )\n</code></pre>"},{"location":"matlab/Low%20thrust/Plot_low_thrust/plotLT_Th/","title":"<code>plotLT_Th</code>","text":""},{"location":"matlab/Low%20thrust/Plot_low_thrust/plotLT_Th/#description","title":"DESCRIPTION","text":"<p>This function generates a plot of the thrust magnitude over time for a low-thrust trajectory. The plot can either create a new figure or overlay the data onto an existing figure, depending on the input argument 'holdon'.</p>"},{"location":"matlab/Low%20thrust/Plot_low_thrust/plotLT_Th/#input","title":"INPUT","text":"<ul> <li>transfer : matrix containing trajectory data (see also plotLT.m)</li> <li>param    : structure containing parameters for the plot. For example, 'rho' is used in the plot legend to label the curve.</li> <li>holdon   : optional binary input. If set to 0 (default), a new figure is created for the plot. If set to 1, the plot is overlaid onto the current figure.</li> <li>name     : optional string input. This is the name of the curve for the legend display.</li> </ul>"},{"location":"matlab/Low%20thrust/Plot_low_thrust/plotLT_Th/#output","title":"OUTPUT","text":"<ul> <li>figTHRmag : handle to the figure containing the thrust magnitude plot.</li> </ul>"},{"location":"matlab/Low%20thrust/Plot_low_thrust/plotLT_Th/#function-signature","title":"Function Signature","text":"<pre><code>[figTHRmag] = plotLT_Th( transfer, param, holdon, name )\n</code></pre>"},{"location":"matlab/Low%20thrust/Plot_low_thrust/wrapPlotLTFull/","title":"<code>wrapPlotLTFull</code>","text":""},{"location":"matlab/Low%20thrust/Plot_low_thrust/wrapPlotLTFull/#description","title":"DESCRIPTION","text":"<p>This function generates trajectory plots for a low-thrust transfer, including mass and thrust magnitude plots. It calls the plotLT function to generate the primary plots and overlays initial and final states on the trajectory plot.</p>"},{"location":"matlab/Low%20thrust/Plot_low_thrust/wrapPlotLTFull/#input","title":"INPUT","text":"<ul> <li>LT_SOLUTION : structure containing low-thrust transfer data for all the legs of an MGA transfer</li> <li>param : structure containing parameters</li> </ul>"},{"location":"matlab/Low%20thrust/Plot_low_thrust/wrapPlotLTFull/#output","title":"OUTPUT","text":"<ul> <li>figTRAJ   : figure handle for the trajectory plot</li> <li>figMASS   : figure handle for the mass evolution plot</li> <li>figTHRmag : figure handle for the thrust magnitude plot</li> </ul>"},{"location":"matlab/Low%20thrust/Plot_low_thrust/wrapPlotLTFull/#function-signature","title":"Function Signature","text":"<pre><code>[figTRAJ, figMASS, figTHRmag] = wrapPlotLTFull(LT_SOLUTION, param)\n</code></pre>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/postProcessLT/","title":"<code>postProcessLT</code>","text":""},{"location":"matlab/Low%20thrust/Processing_low_thrust/postProcessLT/#description","title":"DESCRIPTION","text":"<p>This function processes the results of a low-thrust trajectory optimization by converting scaled states back to physical units, extracting the thrust profile, and assembling all relevant trajectory data into a single matrix.</p>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/postProcessLT/#input","title":"INPUT","text":"<ul> <li>time         : Vector of time points (scaled units).</li> <li>states       : Matrix of state vectors (scaled units), where each row corresponds to a time step and contains [position, velocity, mass].</li> <li>propFunction : Function handle for the propulsion model, which returns the thrust profile in the RTN frame.</li> <li>pm           : Parameter structure containing constants and scaling factors, including:</li> <li>MU        : Mass unit (kg).</li> <li>LU        : Length unit (km).</li> <li>TU        : Time unit (s).</li> <li>muScl     : Scaled gravitational parameter.</li> <li>TmaxScl   : Scaled maximum thrust.</li> <li>IspScl    : Scaled specific impulse.</li> <li>g0Scl     : Scaled gravitational acceleration.</li> <li>rho       : Density parameter for the propulsion model.</li> </ul>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/postProcessLT/#output","title":"OUTPUT","text":"<ul> <li>transfer : Matrix containing the processed trajectory data with the following columns: [time (days), position (km), velocity (km/s), mass (kg), thrust magnitude (N), thrust vector (N)].</li> </ul>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/postProcessLT/#function-signature","title":"Function Signature","text":"<pre><code>[transfer] = postProcessLT( time, states, propFunction, pm )\n</code></pre>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/postProcessPathASTRA_lowThrust/","title":"<code>postProcessPathASTRA_lowThrust</code>","text":""},{"location":"matlab/Low%20thrust/Processing_low_thrust/postProcessPathASTRA_lowThrust/#description","title":"DESCRIPTION","text":"<p>This function processes the output of a low-thrust trajectory optimization problem to generate a structured output. It calculates velocity adjustments (DSM), ephemerides, and departure/arrival states, while considering constraints such as flyby conditions and central body parameters.</p>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/postProcessPathASTRA_lowThrust/#input","title":"INPUT","text":"<ul> <li>path      : matrix describing the trajectory, including object IDs and epochs</li> <li>vdep      : scalar, maximum departure velocity (default is 0 if not provided)</li> <li>varr      : scalar, maximum arrival velocity (default is 0 if not provided)</li> <li>idcentral : scalar, central body identifier (default is 1 for Sun)</li> </ul>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/postProcessPathASTRA_lowThrust/#output","title":"OUTPUT","text":"<ul> <li>struc : structure containing detailed information about the trajectory, including departure and arrival states, velocity adjustments, and ephemerides for each transfer leg.</li> </ul>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/postProcessPathASTRA_lowThrust/#function-signature","title":"Function Signature","text":"<pre><code>[struc] = postProcessPathASTRA_lowThrust(path, vdep, varr, idcentral, customEphemerides)\n</code></pre>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/processDataAndWriteParam/","title":"<code>processDataAndWriteParam</code>","text":""},{"location":"matlab/Low%20thrust/Processing_low_thrust/processDataAndWriteParam/#input","title":"INPUT:","text":"<p>m0          : initial mass                                        [kg] tof         : time of flight                                      [s] state1      : initial state                                       [km],[km/s] state2      : final state                                         [km],[km/s] Tmax        : max. thrust                                         [N] Isp         : specific impulse                                    [s] g0          : Earth acceleration at sea level (default: 9.80665)  [m/s2] Nrev        : number of revolutions (default: 0) idcentral   : ID of the central body (default: 1, i.e., Sun) useParallel : if true, uses parallel for fsolve (default: false)</p>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/processDataAndWriteParam/#output","title":"OUTPUT:","text":"<p>param : structure with all the info needed for running the solver</p>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/processDataAndWriteParam/#function-signature","title":"Function Signature","text":"<pre><code>[param] = processDataAndWriteParam(m0, tof, state1, state2, Tmax, Isp, g0, Nrev, idcentral, useParallel)\n</code></pre>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/writeParamLT/","title":"<code>writeParamLT</code>","text":""},{"location":"matlab/Low%20thrust/Processing_low_thrust/writeParamLT/#description","title":"DESCRIPTION","text":"<p>This function initializes and returns a parameter structure required for low-thrust trajectory optimization. The structure contains constants, scaled parameters, and solver options used in the optimization process.</p>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/writeParamLT/#input","title":"INPUT","text":"<ul> <li>Tmax       : Maximum thrust (N).</li> <li>Isp        : Specific impulse (s).</li> <li>m0         : Initial mass (kg).</li> <li>g0         : Standard gravitational acceleration (m/s^2). Default is 9.8065.</li> <li>idcentral  : ID of the central body (1 for Sun, other planets correspond to their respective IDs). Default is 1.</li> <li>useParallel: Boolean to specify if parallel computation should be used. Default is false.</li> </ul>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/writeParamLT/#output","title":"OUTPUT","text":"<ul> <li>param : Structure containing the following fields:</li> <li>mu          : Gravitational parameter of the central body (km^3/s^2).</li> <li>AU          : Astronomical unit (km).</li> <li>Tmax        : Maximum thrust (N).</li> <li>g0          : Gravitational acceleration (m/s^2).</li> <li>Isp         : Specific impulse (s).</li> <li>day         : Duration of one day (s).</li> <li>year        : Duration of one year (days).</li> <li>useEdelbaum: Boolean for using Edelbaum approximation (default false).</li> <li>LU          : Length unit (km).</li> <li>TU          : Time unit (s).</li> <li>MU          : Mass unit (kg).</li> <li>muScl       : Scaled gravitational parameter.</li> <li>IspScl      : Scaled specific impulse.</li> <li>TmaxScl     : Scaled thrust.</li> <li>g0Scl       : Scaled gravitational acceleration.</li> <li>m0Scl       : Scaled initial mass.</li> <li>fsolveoptions: Options for the fsolve function, including tolerances, maximum evaluations, and parallel computation settings.</li> <li>odeoptions  : Options for ODE solvers, including tolerances.</li> <li>bvpoptions  : Options for boundary value problem solvers, including tolerances and statistics.</li> <li>plots       : Boolean for enabling/disabling plots (default false).</li> <li>full        : Boolean for enabling/disabling full output (default false).</li> </ul>"},{"location":"matlab/Low%20thrust/Processing_low_thrust/writeParamLT/#function-signature","title":"Function Signature","text":"<pre><code>[param] = writeParamLT( Tmax, Isp, m0, g0, idcentral, useParallel)\n</code></pre>"},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateEopt_MEXIFY/","title":"<code>propagateEopt_MEXIFY</code>","text":""},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateEopt_MEXIFY/#description","title":"DESCRIPTION:","text":"<p>This function propagates the spacecraft dynamics in two-body problem and applies the energy-optimal (time-fixed) control.</p>"},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateEopt_MEXIFY/#input","title":"INPUT:","text":"<ul> <li>t       : time [LU]</li> <li>xvalues : 7x1 vector with MEE and mass (adimensional variables)</li> <li>pp      : 4x1 vector with:</li> <li>pp(1) : mu [LU3/TU2] -- gravitational parameter of the central body</li> <li>pp(2) : TmaxScl [adim] -- max. thrust</li> <li>pp(3) : IspScl [TU] -- specific impulse</li> <li>pp(4) : g0Scl [LU/TU2] -- Earth's gravitational acceleration at sea level</li> </ul>"},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateEopt_MEXIFY/#output","title":"OUTPUT:","text":"<ul> <li>dx     : accelerations of the state vector (i.e., xvalues)</li> <li>thrust : 3x1 thrust vector (adim.)</li> <li>m      : mass (adim.)</li> </ul>"},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateEopt_MEXIFY/#function-signature","title":"Function Signature","text":"<pre><code>[dx, thrust, m] = propagateEopt_MEXIFY( t, xvalues, pp )\n</code></pre>"},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateFopt_MEXIFY/","title":"<code>propagateFopt_MEXIFY</code>","text":""},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateFopt_MEXIFY/#description","title":"DESCRIPTION:","text":"<p>This function propagates the spacecraft dynamics in two-body problem and applies the fuel-optimal (time-fixed) control.</p>"},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateFopt_MEXIFY/#input","title":"INPUT:","text":"<ul> <li>t       : time [LU]</li> <li>xvalues : 7x1 vector with MEE and mass (adimensional variables)</li> <li>pp      : 4x1 vector with:</li> <li>pp(1) : mu [LU3/TU2] -- gravitational parameter of the central body</li> <li>pp(2) : TmaxScl [adim] -- max. thrust</li> <li>pp(3) : IspScl [TU] -- specific impulse</li> <li>pp(4) : g0Scl [LU/TU2] -- Earth's gravitational acceleration at sea level</li> </ul>"},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateFopt_MEXIFY/#output","title":"OUTPUT:","text":"<ul> <li>dx     : accelerations of the state vector (i.e., xvalues)</li> <li>thrust : 3x1 thrust vector (adim.)</li> <li>m      : mass (adim.)</li> </ul>"},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateFopt_MEXIFY/#function-signature","title":"Function Signature","text":"<pre><code>[dx, thrust, m] = propagateFopt_MEXIFY( t, xvalues, pp )\n</code></pre>"},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateState_vA/","title":"<code>propagateState_vA</code>","text":""},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateState_vA/#description","title":"DESCRIPTION:","text":"<p>This function is used to compute the difference between target final state and final state resulting from the propagation. The states are given in Mean Equinoctial Elements (MEE).</p>"},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateState_vA/#input","title":"INPUT:","text":"<ul> <li>lambda0      : 7x1 vector with initial conditions for co-states</li> <li>propFunction : MATLAB anonymous function of time and states (e.g., see propagateFopt_MEXIFY.m or propagateEopt_MEXIFY.m)</li> <li>pm           : structure with parameters for the propagation</li> </ul>"},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateState_vA/#output","title":"OUTPUT:","text":"<p>F : 6x1 vector with difference between target final state and final state resulting from the propagation.</p>"},{"location":"matlab/Low%20thrust/Propagation_optimal_control/propagateState_vA/#function-signature","title":"Function Signature","text":"<pre><code>[F] = propagateState_vA(lambda0, propFunction, pm)\n</code></pre>"},{"location":"matlab/Pareto%20front/paretoFront/","title":"<code>paretoFront</code>","text":""},{"location":"matlab/Pareto%20front/paretoFront/#description","title":"DESCRIPTION","text":"<p>Filters a set of points P according to Pareto dominance, i.e., points that are dominated (both weakly and strongly) are filtered.</p>"},{"location":"matlab/Pareto%20front/paretoFront/#input","title":"INPUT","text":"<ul> <li>P    : N-by-D matrix, where N is the number of points and D is the number of elements (objectives) of each point.</li> </ul>"},{"location":"matlab/Pareto%20front/paretoFront/#output","title":"OUTPUT","text":"<ul> <li>P    : Pareto-filtered P</li> <li>idxs : indices of the non-dominated solutions Example: p = [1 1 1; 2 0 1; 2 -1 1; 1, 1, 0]; [f, idxs] = paretoFront(p) f = [1 1 1; 2 0 1] idxs = [1; 2]</li> </ul>"},{"location":"matlab/Pareto%20front/paretoFront/#function-signature","title":"Function Signature","text":"<pre><code>[ PP, idxs] = paretoFront( p )\n</code></pre>"},{"location":"matlab/Pareto%20front/paretoFront_MODP/","title":"<code>paretoFront_MODP</code>","text":""},{"location":"matlab/Pareto%20front/paretoFront_MODP/#description","title":"DESCRIPTION","text":"<p>Wrapper for computing Pareto front in MODP.</p>"},{"location":"matlab/Pareto%20front/paretoFront_MODP/#input","title":"INPUT","text":"<ul> <li>COSTmatrix : N-by-D matrix, where N is the number of points and D is the number of elements (objectives) of each point.</li> </ul>"},{"location":"matlab/Pareto%20front/paretoFront_MODP/#output","title":"OUTPUT","text":"<ul> <li>PARETO_FRONT : matrix with Pareto front as follows:</li> <li>PARETO_FRONT(:,1:N) : objectives on the front</li> <li>PARETO_FRONT(:,end) : rows' IDs of the point in COSTmatrix</li> <li>PARETO_UNIQUE : same as PARETO_FRONT but with unique points w.r.t. the first objective</li> </ul>"},{"location":"matlab/Pareto%20front/paretoFront_MODP/#function-signature","title":"Function Signature","text":"<pre><code>[PARETO_FRONT, PARETO_UNIQUE] = paretoFront_MODP( COSTmatrix )\n</code></pre>"},{"location":"matlab/Plot%20and%20save/generateOutputSequenceTXT/","title":"<code>generateOutputSequenceTXT</code>","text":""},{"location":"matlab/Plot%20and%20save/generateOutputSequenceTXT/#description","title":"DESCRIPTION","text":"<p>This function generates a textual representation of a sequence of planets from a given trajectory path by converting each planet ID to a corresponding symbol or name.</p>"},{"location":"matlab/Plot%20and%20save/generateOutputSequenceTXT/#input","title":"INPUT","text":"<ul> <li>path   : Matrix where each row represents a state in the trajectory with the 7th column indicating the planet ID.</li> </ul>"},{"location":"matlab/Plot%20and%20save/generateOutputSequenceTXT/#output","title":"OUTPUT","text":"<ul> <li>sequence : A string representing the sequence of planets in the trajectory, where each planet ID is replaced by a specific symbol or name.</li> </ul>"},{"location":"matlab/Plot%20and%20save/generateOutputSequenceTXT/#function-signature","title":"Function Signature","text":"<pre><code>[sequence] = generateOutputSequenceTXT(path, idcentral)\n</code></pre>"},{"location":"matlab/Plot%20and%20save/generateOutputTXT/","title":"<code>generateOutputTXT</code>","text":""},{"location":"matlab/Plot%20and%20save/generateOutputTXT/#description","title":"DESCRIPTION","text":"<p>This function generates a text file containing detailed information about a trajectory path, including departure and arrival planets, v-infinity velocities, transfer types, and additional trajectory metrics.</p>"},{"location":"matlab/Plot%20and%20save/generateOutputTXT/#input","title":"INPUT","text":"<ul> <li>path   : Matrix where each row represents a state in the trajectory with columns for position (x, y, z), velocity (vx, vy, vz), planetary ID, time, and v-infinity information.</li> <li>folder : (Optional) Directory path where the output text file will be saved. If not specified, the file is saved in the \"results\" folder or created if it doesn't exist.</li> <li>nametemp : (Optional) Name of the output text file. If not specified, a default name based on the trajectory sequence is used.</li> </ul>"},{"location":"matlab/Plot%20and%20save/generateOutputTXT/#output","title":"OUTPUT","text":"<ul> <li>out    : A file handle to the created text file containing the trajectory details and metrics formatted as specified.</li> </ul>"},{"location":"matlab/Plot%20and%20save/generateOutputTXT/#function-signature","title":"Function Signature","text":"<pre><code>[out] = generateOutputTXT(path, idcentral, customEphemerides, folder, nametemp)\n</code></pre>"},{"location":"matlab/Plot%20and%20save/plotPLTS_tt/","title":"<code>plotPLTS_tt</code>","text":""},{"location":"matlab/Plot%20and%20save/plotPLTS_tt/#description","title":"DESCRIPTION","text":"<p>This function plots the orbits of specified planets over a given time range and provides an option to either open a new figure or use an existing one. It also plots the Sun's position for reference.</p>"},{"location":"matlab/Plot%20and%20save/plotPLTS_tt/#input","title":"INPUT","text":"<ul> <li>pl     : Vector of planet IDs to plot.</li> <li>t0     : Start time for plotting (in days).</li> <li>tend   : End time for plotting (in days).</li> <li>holdon : Optional flag to determine whether to hold on to the current figure (1) or open a new one (0).</li> <li>colors : RGB triplet for the plot of the orbits. Default is black</li> <li>names  : cell with names of the planets. Default is empty. This is used only for putting legend to the plot.</li> </ul>"},{"location":"matlab/Plot%20and%20save/plotPLTS_tt/#output","title":"OUTPUT","text":"<ul> <li>fig   : Handle to the figure created or used for plotting.</li> </ul>"},{"location":"matlab/Plot%20and%20save/plotPLTS_tt/#process","title":"PROCESS","text":"<ul> <li>If only three input arguments are provided, a new figure is opened.</li> <li>If a fourth argument is provided, the function either uses the current figure or opens a new one based on the <code>holdon</code> flag.</li> <li>For each planet, compute and plot its orbit over the specified time range.</li> <li>The orbits are plotted in Astronomical Units (AU) with the Sun's position marked as a yellow point.</li> </ul>"},{"location":"matlab/Plot%20and%20save/plotPLTS_tt/#function-signature","title":"Function Signature","text":"<pre><code>[fig] = plotPLTS_tt(pl, t0, tend, idcentral, customEphemerides, holdon, colors, names, linewidth, style)\n</code></pre>"},{"location":"matlab/Plot%20and%20save/plotPareto/","title":"<code>plotPareto</code>","text":""},{"location":"matlab/Plot%20and%20save/plotPareto/#description","title":"DESCRIPTION","text":"<p>This function plots the Pareto front of solutions on a 2D plot, with the x-axis representing time of flight (in years) and the y-axis representing delta-v (in km/s). The plot can be customized with various input arguments to hold the plot, change markers, colors, and add labels.</p>"},{"location":"matlab/Plot%20and%20save/plotPareto/#input","title":"INPUT","text":"<ul> <li>paretofront : Matrix where each row represents a point on the Pareto front, with the first column being the time of flight and the second column being the delta-v.</li> <li>holdon      : Boolean flag to determine whether to hold the current plot or create a new one. If holdon == 1, the current plot is held; otherwise, a new plot is created.</li> <li>marker      : String specifying the marker type for the plot points (e.g., 'o', 'x').</li> <li>color       : String or RGB triplet specifying the color of the plot markers.</li> <li>name        : String specifying the name to be used in the legend for this Pareto front.</li> <li>markersize  : Scalar value specifying the size of the plot markers.</li> </ul>"},{"location":"matlab/Plot%20and%20save/plotPareto/#output","title":"OUTPUT","text":"<ul> <li>fig : Handle to the created or modified figure.</li> </ul>"},{"location":"matlab/Plot%20and%20save/plotPareto/#function-signature","title":"Function Signature","text":"<pre><code>[fig] = plotPareto(paretofront, holdon, marker, color, name, markersize)\n</code></pre>"},{"location":"matlab/Plot%20and%20save/plotPath/","title":"<code>plotPath</code>","text":""},{"location":"matlab/Plot%20and%20save/plotPath/#description","title":"DESCRIPTION","text":"<p>This function plots the trajectory of a spacecraft and the orbits of planets along with various related plots. The spacecraft's trajectory is based on the provided path data, which includes the state vectors at different time points. The function also generates plots in both the ECI (Earth-Centered Inertial) and Synodic reference frames, as well as plots of distance and velocity over time.</p>"},{"location":"matlab/Plot%20and%20save/plotPath/#input","title":"INPUT","text":"<ul> <li>path      : Nx8 matrix where each row contains the state vector of the spacecraft at a given time. Columns represent position and velocity in ECI frame, as well as time and planet IDs.</li> <li>idcentral : ID of the central body. See constants.m</li> <li>customEphemerides : user-defined custom ephemerides. See EphSS_cartesian.m for reference</li> <li>holdon    : optional flag to determine if the current figure should be held for additional plotting. Default is 0 (create new figure).</li> <li>color     : optional color for the trajectory plot. Default is 'b' (blue).</li> <li>firstL    : optional flag to highlight the departure condition. Default is 1 (highlight).</li> </ul>"},{"location":"matlab/Plot%20and%20save/plotPath/#output","title":"OUTPUT","text":"<ul> <li>figECI : handle to the figure showing the spacecraft trajectory and planets' orbits in the ECI frame.</li> <li>STRUC  : structure containing trajectory and planet data including:</li> <li>StatesSC : spacecraft states in ECI frame</li> <li>EpochsSC : time epochs corresponding to spacecraft states</li> <li>TOFsSC   : time of flight between waypoints</li> <li>DistSC   : distance from the Sun over time</li> <li>VelSC    : spacecraft velocity over time</li> <li>SatesScFB : state vectors at flyby points</li> <li>EpochsScFB : epochs of flyby points</li> <li>Planets  : structure array of planets' states in the ECI and Synodic frames</li> <li>figSYN : handle to the figure showing the spacecraft trajectory and planets' orbits in the Synodic frame.</li> <li>figRSC : handle to the figure showing the distance from the Sun over time.</li> <li>figVSC : handle to the figure showing the spacecraft velocity over time.</li> </ul>"},{"location":"matlab/Plot%20and%20save/plotPath/#function-signature","title":"Function Signature","text":"<pre><code>[figECI, STRUC, figSYN, figRSC, figVSC] = plotPath(path, idcentral, customEphemerides, holdon, color, firstL)\n</code></pre>"},{"location":"matlab/Plot%20and%20save/saveOUTPUT_MODP/","title":"<code>saveOUTPUT_MODP</code>","text":""},{"location":"matlab/Plot%20and%20save/saveOUTPUT_MODP/#description","title":"DESCRIPTION","text":"<p>This function saves the output results of a multi-objective optimization problem, including details of the optimal trajectory, associated costs, and other relevant metrics.</p>"},{"location":"matlab/Plot%20and%20save/saveOUTPUT_MODP/#input","title":"INPUT","text":"<ul> <li>LEGSnext  : Matrix containing the legs of the trajectory for each candidate solution.</li> <li>VASnext   : Matrix containing the velocity vectors associated with the trajectory legs.</li> <li>VINFnext  : Matrix containing the hyperbolic excess velocity vectors for each leg.</li> <li>INPUT     : Struct containing various input parameters, including the cost function.</li> <li>runOpts   : Matrix containing run-time options for the optimization process.</li> <li>chosenRev : Vector indicating the chosen number of revolutions for each leg.</li> <li>tocTOT    : Total elapsed time for the optimization process.</li> </ul>"},{"location":"matlab/Plot%20and%20save/saveOUTPUT_MODP/#output","title":"OUTPUT","text":"<ul> <li>OUTPUT    : Struct containing all relevant outputs of the optimization process. This includes information about the Pareto front, the minimum cost path, and additional metrics for performance analysis.</li> </ul>"},{"location":"matlab/Plot%20and%20save/saveOUTPUT_MODP/#function-signature","title":"Function Signature","text":"<pre><code>[OUTPUT] = saveOUTPUT_MODP(LEGSnext, VASnext, VINFnext, INPUT, runOpts, chosenRev, tocTOT)\n</code></pre>"},{"location":"matlab/Plot%20and%20save/saveOUTPUT_SODP/","title":"<code>saveOUTPUT_SODP</code>","text":""},{"location":"matlab/Plot%20and%20save/saveOUTPUT_SODP/#description","title":"DESCRIPTION:","text":"<p>This function saves various results from a space mission optimization process. It handles cases where no solutions are found and where solutions are available. It computes and saves the Pareto front, minimum cost path, and additional information.</p>"},{"location":"matlab/Plot%20and%20save/saveOUTPUT_SODP/#input","title":"INPUT","text":"<p>runOpts    : Options for running the mission optimization. chosenRev  : Vector of chosen revision options. tocTOT     : Total time of computation.</p>"},{"location":"matlab/Plot%20and%20save/saveOUTPUT_SODP/#inputs","title":"INPUTS:","text":"<p>LEGSnext   : Matrix of the next leg configurations. VASnext    : Matrix of the velocities associated with the next leg configurations. VINFnext   : Matrix of the inertias associated with the next leg configurations.</p>"},{"location":"matlab/Plot%20and%20save/saveOUTPUT_SODP/#function-signature","title":"Function Signature","text":"<pre><code>[OUTPUT] = saveOUTPUT_SODP(LEGSnext, VASnext, VINFnext, INPUT, runOpts, chosenRev, tocTOT)\n</code></pre>"},{"location":"matlab/Processing/fromSeq2Legs/","title":"<code>fromSeq2Legs</code>","text":""},{"location":"matlab/Processing/fromSeq2Legs/#description","title":"DESCRIPTION:","text":"<p>This function processes a sequence of planetary encounters, converting it into a list of trajectory legs. It also calculates the number of legs, the number of flybys, and the total number of planets in the sequence.</p>"},{"location":"matlab/Processing/fromSeq2Legs/#input","title":"INPUT:","text":"<p>SEQ   : Vector representing the sequence of planetary encounters, where each element corresponds to a specific planet.</p>"},{"location":"matlab/Processing/fromSeq2Legs/#output","title":"OUTPUT:","text":"<p>legs  : Matrix where each row represents a trajectory leg, with the first column indicating the departure planet and the second column indicating the arrival planet. nlegs : Scalar representing the total number of trajectory legs. nfbs  : Scalar representing the number of flybys, calculated as the total number of legs minus one. nplts : Scalar representing the total number of planets in the sequence, calculated as the total number of legs plus one.</p>"},{"location":"matlab/Processing/fromSeq2Legs/#function-signature","title":"Function Signature","text":"<pre><code>[legs, nlegs, nfbs, nplts] = fromSeq2Legs(SEQ)\n</code></pre>"},{"location":"matlab/Processing/generateDiffRuns/","title":"<code>generateDiffRuns</code>","text":""},{"location":"matlab/Processing/generateDiffRuns/#description","title":"DESCRIPTION:","text":"<p>This function processes a matrix of revision codes and generates a corresponding matrix of revision options. It also optionally appends additional data to the output matrix based on the input <code>res</code>.</p>"},{"location":"matlab/Processing/generateDiffRuns/#inputs","title":"INPUTS:","text":"<p>revVec : Matrix of revision codes. Each element specifies a different revision type. res     : (Optional) Matrix of results, where the last column indicates which legs are being referenced.</p>"},{"location":"matlab/Processing/generateDiffRuns/#output","title":"OUTPUT","text":"<p>REVS is structured as follows: - Each row corresponds to a revision code and its mapped options. - Additional columns are appended if <code>res</code> is provided, based on the legs results. EXAMPLES: If <code>revVec</code> is [10; 21; 30] and <code>res</code> is [1 2; 3 4; 5 6], the output <code>REVS</code> will include the mapped options and potentially additional columns from <code>res</code>. PROCESSING STEPS: 1. Initialize <code>REVS</code> with zeroes. 2. Map revision codes to options. 3. Optionally append additional data from <code>res</code> based on leg results.</p>"},{"location":"matlab/Processing/generateDiffRuns/#output_1","title":"OUTPUT:","text":"<p>REVS    : Matrix of revision options, with each revision code mapped to a specific option set. Optionally includes data from <code>res</code> if <code>res</code> is provided. PROCESS: 1. Reshape <code>res</code> to have 3 rows and adjust it for processing. 2. Extract the last column of <code>res</code> which represents legs results. 3. Initialize a variable to track the column index for revision options. 4. Loop through each element of <code>revVec</code> to map the revision codes to option sets: - 0  -&gt; [0 0] - 10 -&gt; [1 0] - 11 -&gt; [1 1] - 20 -&gt; [2 0] - 21 -&gt; [2 1] - 30 -&gt; [3 0] - 31 -&gt; [3 1] 5. Append two zero columns to <code>REVS</code> for possible additional data. 6. If <code>res</code> is provided, append the data from <code>res</code> to the last two columns of <code>REVS</code>.</p>"},{"location":"matlab/Processing/generateDiffRuns/#function-signature","title":"Function Signature","text":"<pre><code>[REVS] = generateDiffRuns(revVec, res)\n</code></pre>"},{"location":"matlab/Processing/numberOfDefects/","title":"<code>numberOfDefects</code>","text":""},{"location":"matlab/Processing/numberOfDefects/#description","title":"DESCRIPTION","text":"<p>This function calculates the total number of unique defect cases based on the given legs data and time of flight (TOF) values. Each unique node configuration in <code>LEGSnext</code> is paired with each TOF to compute the total number of defect cases.</p>"},{"location":"matlab/Processing/numberOfDefects/#input","title":"INPUT","text":"<ul> <li>LEGSnext : Matrix containing leg information. The last few columns are used to identify unique nodes.</li> <li>TOFS     : Array of time of flight values.</li> </ul>"},{"location":"matlab/Processing/numberOfDefects/#output","title":"OUTPUT","text":"<ul> <li>nDEF     : Total number of unique defect cases, calculated as the product of the number of unique nodes and the number of TOF values.</li> </ul>"},{"location":"matlab/Processing/numberOfDefects/#function-signature","title":"Function Signature","text":"<pre><code>[nDEF] = numberOfDefects(LEGSnext, TOFS)\n</code></pre>"},{"location":"matlab/Processing/path2Vinfs/","title":"<code>path2Vinfs</code>","text":""},{"location":"matlab/Processing/path2Vinfs/#description","title":"DESCRIPTION","text":"<p>This function computes the v-infinity vectors at each leg of a trajectory path. It calculates both the departure and arrival v-infinity vectors and their magnitudes based on the input path data.</p>"},{"location":"matlab/Processing/path2Vinfs/#input","title":"INPUT","text":"<ul> <li>path : Matrix where each row represents a state in the trajectory with columns for position (x, y, z), velocity (vx, vy, vz), planetary ID, time, and v-infinity.</li> <li>idcentral : ID of the central body. See constants.m</li> </ul>"},{"location":"matlab/Processing/path2Vinfs/#output","title":"OUTPUT","text":"<ul> <li>VINFS : Matrix containing the departure and arrival v-infinity vectors and their magnitudes for each leg of the trajectory.</li> <li>vvd   : Matrix of v-infinity vectors at the departure of each leg.</li> <li>vva   : Matrix of v-infinity vectors at the arrival of each leg.</li> <li>rrd   : Matrix of position vectors at the departure of each leg.</li> <li>rra   : Matrix of position vectors at the arrival of each leg.</li> </ul>"},{"location":"matlab/Processing/path2Vinfs/#function-signature","title":"Function Signature","text":"<pre><code>[VINFS, vvd, vva, rrd, rra] = path2Vinfs(path, idcentral, customEphemerides)\n</code></pre>"},{"location":"matlab/Processing/planetIdToName/","title":"<code>planetIdToName</code>","text":""},{"location":"matlab/Processing/planetIdToName/#description","title":"DESCRIPTION","text":"<p>This function converts a planet ID to its corresponding planet name. The planet IDs are mapped to their respective names using a predefined list of planet names. If the provided ID is out of the expected range, the function returns the ID as a string.</p>"},{"location":"matlab/Processing/planetIdToName/#input","title":"INPUT","text":"<ul> <li>idPL : Integer representing the ID of the planet (1 for Mercury, 2 for Venus, etc.).</li> <li>idcentral : ID of the central body. See constants.m</li> </ul>"},{"location":"matlab/Processing/planetIdToName/#output","title":"OUTPUT","text":"<ul> <li>name : String containing the name of the planet corresponding to the given ID. If the ID is out of range, the function returns the ID itself as a string.</li> </ul>"},{"location":"matlab/Processing/planetIdToName/#function-signature","title":"Function Signature","text":"<pre><code>[name] = planetIdToName(idPL, idcentral)\n</code></pre>"},{"location":"matlab/Processing/postProcessOutputASTRA/","title":"<code>postProcessOutputASTRA</code>","text":""},{"location":"matlab/Processing/postProcessOutputASTRA/#description","title":"DESCRIPTION","text":"<p>This function processes the output of the ASTRA tool, extracting key information and organizing it into a structured format for easier analysis and querying. The processed data includes mission sequences, leg parameters, resonance information, cost functions, time of flight, Pareto-front solutions, and the path with minimum cost.</p>"},{"location":"matlab/Processing/postProcessOutputASTRA/#input","title":"INPUT","text":"<ul> <li>OUTPUT : Structure array containing the raw results from ASTRA, with fields such as:</li> <li>minPATH  : Matrix with the path of minimum cost.</li> <li>res      : Resonance information (optional).</li> <li>LEGS     : Matrix with leg parameters (e.g., departure/arrival times, velocity values, etc.).</li> <li>VAS      : Arrival velocity vectors (km/s).</li> <li>VINFa    : Arrival infinity velocities (km/s).</li> <li>COSTS    : Cost values for the trajectories (e.g., delta-v in km/s).</li> <li>TOFYS    : Time of flight (years).</li> <li>ovPF     : Pareto-front solutions.</li> <li>minCOST  : Minimum cost value across solutions.</li> <li>chosenRevs : Resonance data for each leg.</li> </ul>"},{"location":"matlab/Processing/postProcessOutputASTRA/#output","title":"OUTPUT","text":"<ul> <li>processed_OUTPUT : Structure containing the processed and reorganized data:</li> <li>seq            : Sequence of IDs for the flyby bodies.</li> <li>res            : Resonance information (empty if not present).</li> <li>LEGS           : Matrix of leg parameters for all solutions.</li> <li>VAS            : Arrival velocity vectors (km/s).</li> <li>VINFd          : Departure infinity velocities (km/s).</li> <li>VINFa          : Arrival infinity velocities (km/s).</li> <li>REVS           : Resonance data for all legs.</li> <li>depDates       : Departure dates (MJD2000).</li> <li>arrDates       : Arrival dates (MJD2000).</li> <li>defectsPerLeg  : Defects per leg (km/s) if present, otherwise empty.</li> <li>COSTS          : Overall cost function values (km/s).</li> <li>TOFYS          : Overall time of flight (years).</li> <li>PARETO_FRONT   : Pareto-front solutions.</li> <li>LEGSpf         : Leg parameters corresponding to Pareto-front solutions.</li> <li>VASpf          : Arrival velocity vectors for Pareto-front solutions.</li> <li>VINFapf        : Arrival infinity velocities for Pareto-front solutions.</li> <li>REVSpf         : Resonance data for Pareto-front solutions.</li> <li>minPATH        : Path corresponding to the minimum cost solution.</li> <li>minCOST        : Minimum cost value.</li> <li>minTOFY        : Time of flight for the minimum cost solution.</li> <li>minVINFd       : Departure infinity velocity for the minimum cost solution.</li> <li>minVINFa       : Arrival infinity velocity for the minimum cost solution.</li> <li>minREVS        : Resonance data for the minimum cost solution.</li> </ul>"},{"location":"matlab/Processing/postProcessOutputASTRA/#function-signature","title":"Function Signature","text":"<pre><code>[processed_OUTPUT] = postProcessOutputASTRA( OUTPUT )\n</code></pre>"},{"location":"matlab/Processing/process_paretoFront_structure/","title":"<code>process_paretoFront_structure</code>","text":""},{"location":"matlab/Processing/process_paretoFront_structure/#description","title":"DESCRIPTION","text":"<p>This function processes the output of a multi-objective trajectory optimization routine for multiple gravity assist trajectories by converting the raw results into a user-friendly structured format. It extracts and organizes path details, objective values, times of flight, and dynamical defects for each point on the Pareto front.</p>"},{"location":"matlab/Processing/process_paretoFront_structure/#input","title":"INPUT","text":"<ul> <li>INPUT            : structure containing mission setup parameters, including the objective functions and SPICE settings</li> <li>processed_OUTPUT : structure containing raw optimization results, including legs, velocities, and revolution data</li> </ul>"},{"location":"matlab/Processing/process_paretoFront_structure/#output","title":"OUTPUT","text":"<ul> <li>paretoFront : structured array where each element contains the following fields for a single trajectory on the Pareto front:</li> <li>path        : full trajectory path as time-state matrix</li> <li>revs        : sequence of revolutions for each leg</li> <li>res         : additional resolution data</li> <li>objVal      : values of the objective functions</li> <li>tof_days    : total time of flight in days</li> <li>tof_years   : total time of flight in years</li> <li>tofs_days   : vector of times of flight for each leg (days)</li> <li>vinfDep     : launch hyperbolic excess velocity (km/s)</li> <li>vinfArr     : arrival hyperbolic excess velocity (km/s)</li> <li>defects     : vector of dynamical defects per leg</li> <li>defects_sum : sum of all dynamical defects</li> </ul>"},{"location":"matlab/Processing/process_paretoFront_structure/#function-signature","title":"Function Signature","text":"<pre><code>[ paretoFront ] = process_paretoFront_structure( INPUT, processed_OUTPUT )\n</code></pre>"},{"location":"matlab/Processing/seq2SeqName/","title":"<code>seq2SeqName</code>","text":""},{"location":"matlab/Processing/seq2SeqName/#description","title":"DESCRIPTION","text":"<p>This function converts a sequence of planet or celestial body IDs into a concatenated string representing the sequence by name. If the ID corresponds to a known planet, its name is retrieved and added to the sequence name; otherwise, the ID itself is used as a string.</p>"},{"location":"matlab/Processing/seq2SeqName/#input","title":"INPUT","text":"<ul> <li>seq : Array of integers representing the sequence of planet or celestial body IDs.</li> <li>idcentral : ID of the central body. See constants.m</li> </ul>"},{"location":"matlab/Processing/seq2SeqName/#output","title":"OUTPUT","text":"<ul> <li>seqName : A string representing the concatenated names of the planets or IDs in the sequence.</li> </ul>"},{"location":"matlab/Processing/seq2SeqName/#function-signature","title":"Function Signature","text":"<pre><code>[seqName] = seq2SeqName(seq, idcentral)\n</code></pre>"},{"location":"matlab/Processing/transferTypes/","title":"<code>transferTypes</code>","text":""},{"location":"matlab/Processing/transferTypes/#description","title":"DESCRIPTION","text":"<p>given a path from ASTRA output, find the transfer types (OO, OI, IO, II).</p>"},{"location":"matlab/Processing/transferTypes/#input","title":"INPUT","text":"<ul> <li>path      : MGA transfer as coming from ASTRA output\u00f9</li> <li>idcentral : ID of the central body</li> </ul>"},{"location":"matlab/Processing/transferTypes/#output","title":"OUTPUT","text":"<ul> <li>TYPES  : matrix containing the follwing info :</li> <li>TYPES(:,1) : departing planet</li> <li>TYPES(:,2) : arrival planet</li> <li>TYPES(:,3:4) : transfer type (88=OO, 81=OI, 18=IO, 11=II)</li> <li>STATES : matrix containing the following info :</li> <li>STATES(:,1)    : departing planet</li> <li>STATES(:,2)    : arrival planet</li> <li>STATES(:,3:8)  : SC state after the flyby with the dep. planet</li> <li>STATES(:,9:14) : SC state after the flyby with the arr. planet</li> </ul>"},{"location":"matlab/Processing/transferTypes/#function-signature","title":"Function Signature","text":"<pre><code>[TYPES, STATES, fig] = transferTypes(path, idcentral)\n</code></pre>"},{"location":"matlab/Pruning/check_ISNAN_DP/","title":"<code>check_ISNAN_DP</code>","text":""},{"location":"matlab/Pruning/check_ISNAN_DP/#description","title":"DESCRIPTION:","text":"<p>This function checks for and removes any invalid trajectory legs from the input matrices where the delta-v value is <code>NaN</code> (not a number). It cleans up the corresponding entries in the associated velocity matrices as well.</p>"},{"location":"matlab/Pruning/check_ISNAN_DP/#input","title":"INPUT:","text":"<p>LEGSnext : Matrix containing the possible trajectory legs, where each row represents a leg with columns for departure and arrival planets, departure and arrival times, and the delta-v required. VASnext  : Matrix containing the arrival velocities at the destination planets for each leg. VINFnext : Vector containing the incoming velocities at the destination planets for each leg.</p>"},{"location":"matlab/Pruning/check_ISNAN_DP/#output","title":"OUTPUT:","text":"<p>LEGSnext : Cleaned matrix with invalid trajectory legs (those with <code>NaN</code> delta-v values) removed. VASnext  : Cleaned matrix with corresponding rows removed from the arrival velocities. VINFnext : Cleaned vector with corresponding entries removed from the incoming velocities.</p>"},{"location":"matlab/Pruning/check_ISNAN_DP/#function-signature","title":"Function Signature","text":"<pre><code>[LEGSnext, VASnext, VINFnext] = check_ISNAN_DP(LEGSnext, VASnext, VINFnext)\n</code></pre>"},{"location":"matlab/Pruning/prune_DEFECT_DP/","title":"<code>prune_DEFECT_DP</code>","text":""},{"location":"matlab/Pruning/prune_DEFECT_DP/#description","title":"DESCRIPTION:","text":"<p>This function prunes (removes) trajectory legs that have defects exceeding a specified maximum value. It filters out the legs based on the defect values, along with their associated velocity vectors and final velocity norms.</p>"},{"location":"matlab/Pruning/prune_DEFECT_DP/#inputs","title":"INPUTS:","text":"<p>LEGSnext : Matrix of trajectory legs, where each row contains details of the legs, including defect values. VASnext  : Matrix of velocity vectors associated with each trajectory leg. VINFnext : Matrix of final velocity norms for each trajectory leg. defectMax: Maximum allowed defect value. Legs with defects greater than this value will be removed.</p>"},{"location":"matlab/Pruning/prune_DEFECT_DP/#outputs","title":"OUTPUTS:","text":"<p>LEGSnext : Updated matrix of trajectory legs after pruning. VASnext  : Updated matrix of velocity vectors after pruning. VINFnext : Updated matrix of final velocity norms after pruning. FUNCTION CALLS: find   : Finds indices of elements that meet the specified condition (defect value &gt; defectMax).</p>"},{"location":"matlab/Pruning/prune_DEFECT_DP/#function-signature","title":"Function Signature","text":"<pre><code>[LEGSnext, VASnext, VINFnext] = prune_DEFECT_DP(LEGSnext, VASnext, VINFnext, defectMax)\n</code></pre>"},{"location":"matlab/Pruning/prune_DEFECTtot_DP/","title":"<code>prune_DEFECTtot_DP</code>","text":""},{"location":"matlab/Pruning/prune_DEFECTtot_DP/#description","title":"DESCRIPTION:","text":"<p>This function prunes (removes) trajectory legs based on the total defect value. It calculates the total defect for each leg and removes those with a total defect exceeding a specified maximum value.</p>"},{"location":"matlab/Pruning/prune_DEFECTtot_DP/#inputs","title":"INPUTS:","text":"<p>LEGSnext : Matrix of trajectory legs, where each row contains details of the legs, including defect values for each segment. VASnext  : Matrix of velocity vectors associated with each trajectory leg. VINFnext : Matrix of final velocity norms for each trajectory leg. defectTOTMax : Maximum allowed total defect value. Legs with a total defect greater than this value will be removed.</p>"},{"location":"matlab/Pruning/prune_DEFECTtot_DP/#outputs","title":"OUTPUTS:","text":"<p>LEGSnext : Updated matrix of trajectory legs after pruning. VASnext  : Updated matrix of velocity vectors after pruning. VINFnext : Updated matrix of final velocity norms after pruning. FUNCTION CALLS: sum    : Computes the total defect for each trajectory leg by summing over specified columns. find   : Finds indices of elements that meet the specified condition (total defect &gt; defectTOTMax).</p>"},{"location":"matlab/Pruning/prune_DEFECTtot_DP/#function-signature","title":"Function Signature","text":"<pre><code>[LEGSnext, VASnext, VINFnext] = prune_DEFECTtot_DP(LEGSnext, VASnext, VINFnext, defectTOTMax)\n</code></pre>"},{"location":"matlab/Pruning/prune_TOFY_tot/","title":"<code>prune_TOFY_tot</code>","text":""},{"location":"matlab/Pruning/prune_TOFY_tot/#description","title":"DESCRIPTION:","text":"<p>This function prunes the possible trajectory legs based on the total time of flight (TOF). It removes any trajectory legs where the total time of flight exceeds a specified limit.</p>"},{"location":"matlab/Pruning/prune_TOFY_tot/#input","title":"INPUT:","text":"<ul> <li>LEGSnext : Matrix containing the possible trajectory legs, where each row represents a leg with columns for departure and arrival planets, departure and arrival times, and the delta-v required.</li> <li>VASnext  : Matrix containing the arrival velocities at the destination planets for each leg.</li> <li>VINFnext : Vector containing the incoming velocities at the destination planets for each leg.</li> <li>tofyTOT  : Scalar specifying the maximum allowable total time of flight in years.</li> </ul>"},{"location":"matlab/Pruning/prune_TOFY_tot/#output","title":"OUTPUT:","text":"<ul> <li>LEGSnext : Matrix with trajectory legs that exceed the specified time of flight limit removed.</li> <li>VASnext  : Matrix with corresponding rows removed from the arrival velocities.</li> <li>VINFnext : Vector with corresponding entries removed from the incoming velocities.</li> <li>indxs    : Vector containing the indices of the removed trajectory legs.</li> </ul>"},{"location":"matlab/Pruning/prune_TOFY_tot/#function-signature","title":"Function Signature","text":"<pre><code>[LEGSnext, VASnext, VINFnext, indxs] = prune_TOFY_tot(LEGSnext, VASnext, VINFnext, tofyTOT)\n</code></pre>"},{"location":"matlab/Pruning/prune_VINF_DP/","title":"<code>prune_VINF_DP</code>","text":""},{"location":"matlab/Pruning/prune_VINF_DP/#description","title":"DESCRIPTION","text":"<p>This function prunes the sets of legs, velocity asymptotes (VAS), and velocity-infinity vectors (VINF) based on specified velocity-infinity limits. It removes entries where the velocity-infinity exceeds or is less than the given limits.</p>"},{"location":"matlab/Pruning/prune_VINF_DP/#input","title":"INPUT","text":"<ul> <li>LEGSnext : Matrix containing the legs data, where the last column represents the velocity-infinity data.</li> <li>VASnext  : Matrix containing the velocity asymptote data.</li> <li>VINFnext : Matrix containing the velocity-infinity data.</li> <li>INPUT    : Structure containing velocity-infinity options:</li> <li>vInfOpts : A 2-element vector with minimum and maximum allowable velocity-infinity values.</li> </ul>"},{"location":"matlab/Pruning/prune_VINF_DP/#output","title":"OUTPUT","text":"<ul> <li>LEGSnext : Pruned matrix of legs data, with entries removed based on velocity-infinity limits.</li> <li>VASnext  : Pruned matrix of velocity asymptote data, corresponding to the remaining entries in LEGSnext.</li> <li>VINFnext : Pruned matrix of velocity-infinity data, corresponding to the remaining entries in LEGSnext.</li> </ul>"},{"location":"matlab/Pruning/prune_VINF_DP/#process","title":"PROCESS","text":"<ul> <li>Remove rows from LEGSnext, VASnext, and VINFnext where the velocity-infinity is outside the range defined by INPUT.vInfOpts.</li> </ul>"},{"location":"matlab/Pruning/prune_VINF_DP/#function-signature","title":"Function Signature","text":"<pre><code>[LEGSnext, VASnext, VINFnext] = prune_VINF_DP(LEGSnext, VASnext, VINFnext, INPUT)\n</code></pre>"},{"location":"matlab/Pruning/prune_VINFn_DP/","title":"<code>prune_VINFn_DP</code>","text":""},{"location":"matlab/Pruning/prune_VINFn_DP/#description","title":"DESCRIPTION:","text":"<p>This function prunes the possible trajectory legs based on specified limits for the incoming velocity (<code>VINF</code>). It removes any trajectory legs where the incoming velocity falls outside the specified range.</p>"},{"location":"matlab/Pruning/prune_VINFn_DP/#input","title":"INPUT:","text":"<ul> <li>LEGSnext : Matrix containing the possible trajectory legs, where each row represents a leg with columns for departure and arrival planets, departure and arrival times, and the delta-v required.</li> <li>VASnext  : Matrix containing the arrival velocities at the destination planets for each leg.</li> <li>VINFnext : Vector containing the incoming velocities at the destination planets for each leg.</li> <li>vinflim  : Matrix specifying the minimum and maximum allowable incoming velocities for each planet in the sequence.</li> </ul>"},{"location":"matlab/Pruning/prune_VINFn_DP/#output","title":"OUTPUT:","text":"<ul> <li>LEGSnext : Matrix with trajectory legs that have incoming velocities outside the specified limits removed.</li> <li>VASnext  : Matrix with corresponding rows removed from the arrival velocities.</li> <li>VINFnext : Vector with corresponding entries removed from the incoming velocities.</li> </ul>"},{"location":"matlab/Pruning/prune_VINFn_DP/#function-signature","title":"Function Signature","text":"<pre><code>[LEGSnext, VASnext, VINFnext] = prune_VINFn_DP(LEGSnext, VASnext, VINFnext, vinflim)\n</code></pre>"},{"location":"matlab/Pruning/wrap_Pruning_DP/","title":"<code>wrap_Pruning_DP</code>","text":""},{"location":"matlab/Pruning/wrap_Pruning_DP/#description","title":"DESCRIPTION:","text":"<p>This function applies a series of pruning steps to filter trajectory legs based on various criteria. It sequentially checks for NaN values, then prunes based on defect limits, final velocity norms, and total time of flight.</p>"},{"location":"matlab/Pruning/wrap_Pruning_DP/#inputs","title":"INPUTS:","text":"<ul> <li>LEGSn  : Matrix of trajectory legs to be pruned.</li> <li>VASn   : Matrix of velocity vectors corresponding to each trajectory leg.</li> <li>VINFn  : Matrix of final velocity norms corresponding to each trajectory leg.</li> <li>INPUT  : Structure containing pruning criteria:</li> <li>INPUT.dsmOpts(1) : Maximum allowed individual defect for pruning.</li> <li>INPUT.dsmOpts(2) : Maximum allowed total defect for pruning.</li> <li>INPUT.vInfLim    : Velocity norm limits for pruning.</li> <li>INPUT.tofyMax    : Maximum allowed total time of flight for pruning.</li> </ul>"},{"location":"matlab/Pruning/wrap_Pruning_DP/#outputs","title":"OUTPUTS:","text":"<ul> <li>LEGSn  : Pruned matrix of trajectory legs.</li> <li>VASn   : Pruned matrix of velocity vectors.</li> <li>VINFn  : Pruned matrix of final velocity norms. FUNCTION CALLS:</li> <li>check_ISNAN_DP   : Removes rows with NaN values in the trajectory legs matrix.</li> <li>prune_DEFECT_DP  : Removes rows where the individual defect exceeds the specified limit.</li> <li>prune_DEFECTtot_DP : Removes rows where the total defect exceeds the specified limit.</li> <li>prune_VINFn_DP   : Removes rows where the final velocity norm exceeds the specified limit.</li> <li>prune_TOFY_tot   : Removes rows where the total time of flight exceeds the specified limit.</li> </ul>"},{"location":"matlab/Pruning/wrap_Pruning_DP/#function-signature","title":"Function Signature","text":"<pre><code>[LEGSn, VASn, VINFn] = wrap_Pruning_DP(LEGSn, VASn, VINFn, INPUT)\n</code></pre>"},{"location":"matlab/Pruning/wrap_Pruning_DP_st1/","title":"<code>wrap_Pruning_DP_st1</code>","text":""},{"location":"matlab/Pruning/wrap_Pruning_DP_st1/#description","title":"DESCRIPTION:","text":"<p>This function applies a series of pruning operations to filter out invalid or undesirable trajectory legs based on several criteria. It first removes any legs with invalid data, then prunes legs based on incoming velocity limits and total time of flight constraints.</p>"},{"location":"matlab/Pruning/wrap_Pruning_DP_st1/#input","title":"INPUT:","text":"<ul> <li>LEGSn  : Matrix containing the possible trajectory legs, where each row represents a leg with columns for departure and arrival planets, departure and arrival times, and the delta-v required.</li> <li>VASn   : Matrix containing the arrival velocities at the destination planets for each leg.</li> <li>VINFn  : Vector containing the incoming velocities at the destination planets for each leg.</li> <li>INPUT  : Structure containing various constraints and limits, including:</li> <li>vInfLim : Matrix specifying the minimum and maximum allowable incoming velocities.</li> <li>tofyMax : Scalar specifying the maximum allowable total time of flight in years.</li> </ul>"},{"location":"matlab/Pruning/wrap_Pruning_DP_st1/#output","title":"OUTPUT:","text":"<ul> <li>LEGSn  : Matrix with trajectory legs filtered based on the pruning criteria.</li> <li>VASn   : Matrix with corresponding rows removed from the arrival velocities.</li> <li>VINFn  : Vector with corresponding entries removed from the incoming velocities.</li> </ul>"},{"location":"matlab/Pruning/wrap_Pruning_DP_st1/#function-signature","title":"Function Signature","text":"<pre><code>[LEGSn, VASn, VINFn] = wrap_Pruning_DP_st1(LEGSn, VASn, VINFn, INPUT)\n</code></pre>"},{"location":"matlab/Resonances/checkResonance_DP/","title":"<code>checkResonance_DP</code>","text":""},{"location":"matlab/Resonances/checkResonance_DP/#description","title":"DESCRIPTION","text":"<p>This function checks if specific resonances can be achieved during a spacecraft's flyby based on the provided resonance ratio. It evaluates the feasibility of resonant orbits by calculating the spacecraft's post-flyby trajectory and comparing it with the required conditions for resonance.</p>"},{"location":"matlab/Resonances/checkResonance_DP/#input","title":"INPUT","text":"<ul> <li>LEGSnext : Matrix containing the legs of the spacecraft's trajectory, where each row corresponds to a different leg.</li> <li>VASnext  : Matrix containing the spacecraft's velocities corresponding to each leg.</li> <li>VINFnext : Matrix containing the hyperbolic excess velocities for each leg.</li> <li>plt      : Identifier for the planet the flyby is around.</li> <li>res      : Array containing the desired resonance ratio [numerator, denominator].</li> <li>parallel : Boolean flag to indicate whether to run the resonance checks in parallel.</li> </ul>"},{"location":"matlab/Resonances/checkResonance_DP/#output","title":"OUTPUT","text":"<ul> <li>LEGSnext : Updated matrix of legs after filtering out those that cannot achieve resonance.</li> <li>VASnext  : Updated matrix of velocities after filtering.</li> <li>VINFnext : Updated matrix of hyperbolic excess velocities after filtering.</li> </ul>"},{"location":"matlab/Resonances/checkResonance_DP/#function-signature","title":"Function Signature","text":"<pre><code>[LEGSnext, VASnext, VINFnext] = checkResonance_DP(LEGSnext, VASnext, VINFnext, plt, res, parallel, idcentral, customEphemerides)\n</code></pre>"},{"location":"matlab/Resonances/constructResonantOrbits_DP/","title":"<code>constructResonantOrbits_DP</code>","text":""},{"location":"matlab/Resonances/constructResonantOrbits_DP/#description","title":"DESCRIPTION","text":"<p>This function constructs resonant orbits for a spacecraft by evaluating potential trajectories that satisfy a specified resonance condition with a planet. It computes the spacecraft's incoming and outgoing velocities during a planetary flyby and determines if a resonant orbit can be achieved while minimizing the change in orbital inclination.</p>"},{"location":"matlab/Resonances/constructResonantOrbits_DP/#input","title":"INPUT","text":"<ul> <li>legp    : Row vector containing the current leg information of the spacecraft's trajectory.</li> <li>vasp    : Row vector of the spacecraft's velocity corresponding to the current leg.</li> <li>vinfp   : Row vector of the spacecraft's hyperbolic excess velocity for the current leg.</li> <li>plt     : ID of the planet involved in the resonance.</li> <li>res     : Array specifying the desired resonance [numerator, denominator].</li> <li>tolINCL : Tolerance for the inclination change between the incoming and outgoing orbit.</li> <li>parallel: Boolean flag indicating if parallel processing is used (not used in this function).</li> </ul>"},{"location":"matlab/Resonances/constructResonantOrbits_DP/#output","title":"OUTPUT","text":"<ul> <li>legn    : Matrix containing the legs of the spacecraft's trajectory after constructing the resonant orbits. Empty if no valid orbit is found.</li> <li>vasn    : Matrix of spacecraft velocities after constructing resonant orbits. Empty if no valid orbit is found.</li> <li>vinfn   : Vector of spacecraft's hyperbolic excess velocities after constructing resonant orbits. Empty if no valid orbit is found.</li> <li>MAT_VV  : Matrix containing various parameters of the evaluated orbits, including incoming/outgoing velocities and inclination change.</li> </ul>"},{"location":"matlab/Resonances/constructResonantOrbits_DP/#function-signature","title":"Function Signature","text":"<pre><code>[legn, vasn, vinfn, MAT_VV] = constructResonantOrbits_DP(legp, vasp, vinfp, plt, res, tolINCL, idcentral, customEphemerides)\n</code></pre>"},{"location":"matlab/Resonances/wrapConstructionResonance_DP/","title":"<code>wrapConstructionResonance_DP</code>","text":""},{"location":"matlab/Resonances/wrapConstructionResonance_DP/#description","title":"DESCRIPTION","text":"<p>This function attempts to construct resonant orbits for a spacecraft trajectory by checking if resonances can be achieved and then generating the corresponding resonant orbits. It operates in both parallel and sequential modes.</p>"},{"location":"matlab/Resonances/wrapConstructionResonance_DP/#input","title":"INPUT","text":"<ul> <li>LEGSnext : Matrix containing the legs of the spacecraft's trajectory, where each row corresponds to a different leg.</li> <li>VASnext  : Matrix containing the spacecraft's velocities corresponding to each leg.</li> <li>VINFnext : Matrix containing the hyperbolic excess velocities for each leg.</li> <li>legs     : Matrix containing the initial legs of the trajectory.</li> <li>res      : Array containing the desired resonance ratio [numerator, denominator].</li> <li>indl     : Index identifying the specific leg to analyze in the 'legs' matrix.</li> <li>tolINCL  : Tolerance for inclination matching during resonance construction.</li> <li>parallel : Boolean flag to indicate whether to run the resonance checks in parallel.</li> </ul>"},{"location":"matlab/Resonances/wrapConstructionResonance_DP/#output","title":"OUTPUT","text":"<ul> <li>LEGSn  : Matrix of legs after constructing resonant orbits.</li> <li>VASn   : Matrix of velocities after constructing resonant orbits.</li> <li>VINFn  : Matrix of hyperbolic excess velocities after constructing resonant orbits.</li> </ul>"},{"location":"matlab/Resonances/wrapConstructionResonance_DP/#function-signature","title":"Function Signature","text":"<pre><code>[LEGSn, VASn, VINFn] = wrapConstructionResonance_DP(LEGSnext, VASnext, VINFnext, legs, res, indl, tolINCL, parallel, idcentral, customEphemerides)\n</code></pre>"},{"location":"matlab/Revolutions%20options/maxRevOuterPlanets/","title":"<code>maxRevOuterPlanets</code>","text":""},{"location":"matlab/Revolutions%20options/maxRevOuterPlanets/#description","title":"DESCRIPTION","text":"<p>This function updates the matrix of chosen revolutions to set the revolutions for outer planets (with sequence IDs in the range 5 to 1192) to zero. It ensures that the updated matrix reflects that no revolutions are performed for these specific outer planets.</p>"},{"location":"matlab/Revolutions%20options/maxRevOuterPlanets/#input","title":"INPUT","text":"<ul> <li>seq        : Sequence of IDs for flyby bodies, indicating the order in which they are visited.</li> <li>chosenRevs : Matrix representing different permutations of number of revolutions and cases (low-/high-energy) for each leg. Each column represents a leg of the sequence.</li> <li>idcentral  : ID of the central body. See constants.m</li> </ul>"},{"location":"matlab/Revolutions%20options/maxRevOuterPlanets/#output","title":"OUTPUT","text":"<ul> <li>chosenRevs : Updated matrix where the revolutions for the outer planets (IDs 5 to 1192) are set to zero. Each column corresponds to a leg of the sequence of flyby bodies. The coding is as follows: 0  --&gt; means 0 revolutions on the leg. 10 --&gt; means 1 revolution and case 0 (low energy) on the leg. 11 --&gt; means 1 revolution and case 1 (high energy) on the leg. 20 --&gt; means 2 revolutions and case 0 (low energy) on the leg. 21 --&gt; means 2 revolutions and case 1 (high energy) on the leg. and so on...</li> </ul>"},{"location":"matlab/Revolutions%20options/maxRevOuterPlanets/#process","title":"PROCESS","text":"<ul> <li>Identify indices in the sequence where IDs are between 5 and 1192 (inclusive).</li> <li>Determine the number of legs up to the identified index.</li> <li>Update the chosenRevs matrix by setting the revolutions for these legs to 0.</li> <li>Ensure that the updated matrix has unique rows in a stable order.</li> </ul>"},{"location":"matlab/Revolutions%20options/maxRevOuterPlanets/#function-signature","title":"Function Signature","text":"<pre><code>[chosenRevs] = maxRevOuterPlanets(seq, chosenRevs, idcentral)\n</code></pre>"},{"location":"matlab/Revolutions%20options/permn/","title":"<code>permn</code>","text":""},{"location":"matlab/Revolutions%20options/permn/#function-signature","title":"Function Signature","text":"<pre><code>[M, I] = permn(V, N, K)\n</code></pre>"},{"location":"matlab/Revolutions%20options/processResonances/","title":"<code>processResonances</code>","text":""},{"location":"matlab/Revolutions%20options/processResonances/#description","title":"DESCRIPTION","text":"<p>This function processes the matrix of chosen revolutions by setting the revolutions for specific resonant legs to zero and ensuring that the matrix contains unique rows. It also reshapes the results matrix back to its original format.</p>"},{"location":"matlab/Revolutions%20options/processResonances/#input","title":"INPUT","text":"<ul> <li>chosenRevs : Matrix representing permutations of number of revolutions and cases (low-/high-energy) for each leg. Each column represents a leg of the sequence.</li> <li>res        : Matrix of results where each row contains information about a leg, with the last column indicating the resonant leg.</li> </ul>"},{"location":"matlab/Revolutions%20options/processResonances/#output","title":"OUTPUT","text":"<ul> <li>chosenRevs : Updated matrix with the revolutions for resonant legs set to zero. The matrix is also ensured to have unique rows.</li> <li>res        : Reshaped matrix of results back to a single row format.</li> </ul>"},{"location":"matlab/Revolutions%20options/processResonances/#process","title":"PROCESS","text":"<ul> <li>Reshape the results matrix to have 3 rows and as many columns as necessary.</li> <li>Extract the resonant legs from the last column of the reshaped matrix.</li> <li>Set the revolutions for these resonant legs to zero in the chosenRevs matrix.</li> <li>Ensure that the chosenRevs matrix contains unique rows.</li> <li>Reshape the results matrix back to a single row format.</li> </ul>"},{"location":"matlab/Revolutions%20options/processResonances/#function-signature","title":"Function Signature","text":"<pre><code>[chosenRevs, res] = processResonances(chosenRevs, res)\n</code></pre>"},{"location":"matlab/Revolutions%20options/rev2RevOpt/","title":"<code>rev2RevOpt</code>","text":""},{"location":"matlab/Revolutions%20options/rev2RevOpt/#description","title":"DESCRIPTION","text":"<p>This function is used to generate options for Lambert problem Number of revolutions and case (low-/high- energy).</p>"},{"location":"matlab/Revolutions%20options/rev2RevOpt/#input","title":"INPUT","text":"<ul> <li>rev : number encoding number of revolutions and case for Lambert problem. For example: rev = 0  --&gt; means 0 revs. rev = 10 --&gt; means 1 rev. and case 0 (low energy) rev = 11 --&gt; means 1 rev. and case 1 (high energy) rev = 20 --&gt; means 2 revs. and case 0 (low energy) rev = 21 --&gt; means 2 revs. and case 1 (high energy) and so on...</li> <li>res : 1x3 vector with N:M resonant ratio and number of leg at which the resonant transfer is needed. If no resonant transfer is needed, leave it empty.</li> <li>indleg : ID of the current leg.</li> </ul>"},{"location":"matlab/Revolutions%20options/rev2RevOpt/#output","title":"OUTPUT","text":"<ul> <li>revopt : 1x4 vector with the following info:</li> <li>revopt(1:2) is for number of revolutions and case for Lambert problem solution.</li> <li>revopt(3:4) is for resonant ratio, if present: then revopt(1:2) = 0. If not present, revopt(3:4) = 0.</li> </ul>"},{"location":"matlab/Revolutions%20options/rev2RevOpt/#function-signature","title":"Function Signature","text":"<pre><code>[revopt] = rev2RevOpt(rev, res, indleg)\n</code></pre>"},{"location":"matlab/Time%20of%20flight%20options/TOF_per_LEGS_ASTRA/","title":"<code>TOF_per_LEGS_ASTRA</code>","text":""},{"location":"matlab/Time%20of%20flight%20options/TOF_per_LEGS_ASTRA/#function-signature","title":"Function Signature","text":"<pre><code>[tofs, minTOF, maxTOF, tstep] = TOF_per_LEGS_ASTRA(plIN, plT, Nrev, tstep, TOF_LIM, indleg)\n</code></pre>"},{"location":"matlab/Time%20of%20flight%20options/tofGeneration_v2/","title":"<code>tofGeneration_v2</code>","text":""},{"location":"matlab/Time%20of%20flight%20options/tofGeneration_v2/#function-signature","title":"Function Signature","text":"<pre><code>[tofs, minTOF, maxTOF, tstep] = tofGeneration_v2(plIN, plT, Nrev, tstep)\n</code></pre>"},{"location":"matlab/Time%20of%20flight%20options/wrap_TOFs/","title":"<code>wrap_TOFs</code>","text":""},{"location":"matlab/Time%20of%20flight%20options/wrap_TOFs/#function-signature","title":"Function Signature","text":"<pre><code>[TOFS, minTOF, maxTOF, tst] = wrap_TOFs(pl1, pl2, optMR, tstep, TOF_LIM, indl)\n</code></pre>"},{"location":"matlab/astra_optimization/crossFast/","title":"<code>crossFast</code>","text":""},{"location":"matlab/astra_optimization/crossFast/#description","title":"DESCRIPTION:","text":"<p>Very fast cross product. It requires about 1/10 of the time of cross.m. The output is a row or column vector, as in the first input vector.</p>"},{"location":"matlab/astra_optimization/crossFast/#input","title":"INPUT:","text":"<p>r1[3]   First vector (row or column). r2[3]   Second vector (row or column).</p>"},{"location":"matlab/astra_optimization/crossFast/#output","title":"OUTPUT:","text":"<p>out[3]  Cross product between r1 and r2. Row or column depending on r1. CALLED FUNCTIONS: (none) AUTHOR: Matteo Ceriotti, 12/02/2007, MATLAB, crossFast.m PREVIOUS VERSION: Matteo Ceriotti, 12/02/2007, MATLAB, crossfast.m - Header and function name in accordance with guidlines. CHANGELOG: 14/02/2007, REVISION: Camilla Colombo 30/12/2009, Camilla Colombo: Header and function name in accordance with guidlines.</p>"},{"location":"matlab/astra_optimization/crossFast/#function-signature","title":"Function Signature","text":"<pre><code>[out] = crossFast(r1,r2)\n</code></pre>"},{"location":"matlab/astra_optimization/findFlyby_TE/","title":"<code>findFlyby_TE</code>","text":""},{"location":"matlab/astra_optimization/findFlyby_TE/#function-signature","title":"Function Signature","text":"<pre><code>[RP, DELTA] = findFlyby_TE(vvrelIN, vvrelOU, plIN, tIN, idcentral, customEphemerides)\n</code></pre>"},{"location":"matlab/astra_optimization/maxMinPeriAltitude/","title":"<code>maxMinPeriAltitude</code>","text":""},{"location":"matlab/astra_optimization/maxMinPeriAltitude/#function-signature","title":"Function Signature","text":"<pre><code>[rpMin, rpMax] = maxMinPeriAltitude(path, rpperc)\n</code></pre>"},{"location":"matlab/astra_optimization/mga_nDSM_customEph/","title":"<code>mga_nDSM_customEph</code>","text":""},{"location":"matlab/astra_optimization/mga_nDSM_customEph/#function-signature","title":"Function Signature","text":"<pre><code>[DV, dv, MAT, output] = mga_nDSM_customEph(seq, t0, tofs, dv1, dvs, eps, eta, rps, struc_revs_man, customEphemerides, plotsol)\n</code></pre>"},{"location":"matlab/astra_optimization/minMaxDVS/","title":"<code>minMaxDVS</code>","text":""},{"location":"matlab/astra_optimization/minMaxDVS/#function-signature","title":"Function Signature","text":"<pre><code>[dvsMin, dvsMax] = minMaxDVS(dvsMaxMag, NmanLeg)\n</code></pre>"},{"location":"matlab/astra_optimization/minMaxEps/","title":"<code>minMaxEps</code>","text":""},{"location":"matlab/astra_optimization/minMaxEps/#function-signature","title":"Function Signature","text":"<pre><code>[epsMin, epsMax] = minMaxEps(NmanLeg)\n</code></pre>"},{"location":"matlab/astra_optimization/minMaxFirstMan/","title":"<code>minMaxFirstMan</code>","text":""},{"location":"matlab/astra_optimization/minMaxFirstMan/#function-signature","title":"Function Signature","text":"<pre><code>[dv1Min, dv1Max] = minMaxFirstMan(vinfMin, vinfMax, optFirstMan, NmanLeg)\n</code></pre>"},{"location":"matlab/astra_optimization/optPSO/","title":"<code>optPSO</code>","text":""},{"location":"matlab/astra_optimization/optPSO/#description","title":"DESCRIPTION","text":"<p>This function defines and returns the configuration settings for the Particle Swarm Optimization (PSO) algorithm, based on the provided bounds for the decision variables. The function allows optional parallel evaluation of the objective function and sets specific parameters such as the swarm size, maximum number of iterations, and social adjustment weight to control the swarm behavior during optimization.</p>"},{"location":"matlab/astra_optimization/optPSO/#input","title":"INPUT","text":"<ul> <li>lb          : lower bounds of the decision variables (1\u00d7NVAR vector)</li> <li>ub          : upper bounds of the decision variables (1\u00d7NVAR vector)</li> <li>useParallel : (optional) boolean flag to enable parallel execution of particleswarm evaluations (default: false)</li> </ul>"},{"location":"matlab/astra_optimization/optPSO/#output","title":"OUTPUT","text":"<ul> <li>optionsPSO  : structure containing all the PSO options to be used with MATLAB's particleswarm optimizer</li> <li>NVAR        : number of decision variables inferred from the bounds</li> <li>MAXIT       : maximum number of PSO iterations</li> </ul>"},{"location":"matlab/astra_optimization/optPSO/#function-signature","title":"Function Signature","text":"<pre><code>[optionsPSO, NVAR, MAXIT] = optPSO(lb, ub, useParallel)\n</code></pre>"},{"location":"matlab/astra_optimization/path2FlybyParam/","title":"<code>path2FlybyParam</code>","text":""},{"location":"matlab/astra_optimization/path2FlybyParam/#function-signature","title":"Function Signature","text":"<pre><code>[RP, DELTA, path] = path2FlybyParam(path, idcentral, customEphemerides)\n</code></pre>"},{"location":"matlab/astra_optimization/postProcessPathASTRA_dsm_lowThrust/","title":"<code>postProcessPathASTRA_dsm_lowThrust</code>","text":""},{"location":"matlab/astra_optimization/postProcessPathASTRA_dsm_lowThrust/#function-signature","title":"Function Signature","text":"<pre><code>[struc] = postProcessPathASTRA_dsm_lowThrust( dv, output, MAT, vdep_free, varr_free, idcentral, customEphemerides )\n</code></pre>"},{"location":"matlab/astra_optimization/revs2NmanLeg/","title":"<code>revs2NmanLeg</code>","text":""},{"location":"matlab/astra_optimization/revs2NmanLeg/#function-signature","title":"Function Signature","text":"<pre><code>[NmanLeg] = revs2NmanLeg(revs)\n</code></pre>"},{"location":"matlab/astra_optimization/swingby_vA/","title":"<code>swingby_vA</code>","text":""},{"location":"matlab/astra_optimization/swingby_vA/#description","title":"DESCRIPTION","text":"<p>This function computes the output position and velocity vectors after a gravity assist (swing-by) maneuver. The maneuver is modeled as an instantaneous velocity rotation of the incoming hyperbolic excess vector with a specified turn angle and plane orientation. The central body ephemerides are retrieved using a default or user-defined function.</p>"},{"location":"matlab/astra_optimization/swingby_vA/#input","title":"INPUT","text":"<ul> <li>rrIN              : incoming position vector at swing-by (1\u00d73) [km]</li> <li>vvIN              : incoming velocity vector at swing-by (1\u00d73) [km/s]</li> <li>plIN              : ID of the flyby planet (integer, see constants.m)</li> <li>tIN               : time of swing-by [TDB] (scalar, in seconds or days)</li> <li>kIN               : rotation angle defining the plane of the flyby (rad)</li> <li>rpIN              : pericenter radius of swing-by trajectory [km]</li> <li>muPLIN            : gravitational parameter of the planet [km^3/s^2]</li> <li>idcentral         : (optional) ID of the central body for ephemerides computation (default = 1)</li> <li>customEphemerides : (optional) function handle to compute planetary ephemerides (default = @EphSS_cartesian)</li> </ul>"},{"location":"matlab/astra_optimization/swingby_vA/#output","title":"OUTPUT","text":"<ul> <li>rrOU    : output position vector after swing-by (1\u00d73) [km]</li> <li>vvOU    : output velocity vector after swing-by (1\u00d73) [km/s]</li> <li>vvInfIN : incoming hyperbolic excess velocity vector (1\u00d73) [km/s]</li> <li>vvInfOU : outgoing hyperbolic excess velocity vector (1\u00d73) [km/s]</li> </ul>"},{"location":"matlab/astra_optimization/swingby_vA/#function-signature","title":"Function Signature","text":"<pre><code>[rrOU, vvOU, vvInfIN, vvInfOU] = swingby_vA(rrIN, vvIN, plIN, tIN, kIN, rpIN, muPLIN, idcentral, customEphemerides)\n</code></pre>"},{"location":"matlab/astra_optimization/tnh2car/","title":"<code>tnh2car</code>","text":""},{"location":"matlab/astra_optimization/tnh2car/#description","title":"DESCRIPTION:","text":"<p>Transformation from tangential-normal-h to Cartesian reference frame. Tangential-normal-h (tnh) reference frame: {t,n,h} t-axis: direction tangent to the motion. h-axis: direction of the angular momentum. n-axis: direction in the orbit plane, normal to t (inward). Cartesian (car) reference frame: {x,y,z} inertial reference frame. Note: other definition use the {t,h,n} reference frame, where n is outward!</p>"},{"location":"matlab/astra_optimization/tnh2car/#input","title":"INPUT:","text":"<p>x_tnh[3]    Vector to be transformed, expressed in {t,n,h}. s_car[6]    State vector (position [L], velocity [L/T]) of the orbiting body, expressed in {x,y,z}.</p>"},{"location":"matlab/astra_optimization/tnh2car/#output","title":"OUTPUT:","text":"<p>x_car[3,1]  Vector transformed into {x,y,z}. EXAMPLE: Given a spacecraft in orbit: - we have the thrust vector in {t,n,h}; - we want the thrust vector in {x,y,z}. In this case: x_rth = Thrust vector in {t,n,h}; s_car = [position, velocity] of the spacecraft in {x,y,z}; x_car = Thrust vector, transformed in {x,y,z}. CALLED FUNCTIONS: crossFast AUTHOR: Camilla Colombo, 03/03/2006, MATLAB, tnh2car.m PREVIOUS VERSION: Camilla Colombo, 03/03/2006, MATLAB, tnh_carT.m - Header and function name in accordance with guidlines. CHANGELOG: 10/01/2007, REVISION: Matteo Ceriotti 11/02/2008, Matteo Ceriotti: Help improved. 30/09/2009, Camilla Colombo: Header and function name in accordance with guidlines. 29/03/2010, Camilla Colombo: crossFast used.</p>"},{"location":"matlab/astra_optimization/tnh2car/#function-signature","title":"Function Signature","text":"<pre><code>[x_car, A] = tnh2car(x_tnh,s_car)\n</code></pre>"},{"location":"matlab/astra_optimization/v02dv1/","title":"<code>v02dv1</code>","text":""},{"location":"matlab/astra_optimization/v02dv1/#function-signature","title":"Function Signature","text":"<pre><code>[dv1] = v02dv1(v0, xp1, vp1)\n</code></pre>"},{"location":"matlab/astra_optimization/wrap_mga_nDSM/","title":"<code>wrap_mga_nDSM</code>","text":""},{"location":"matlab/astra_optimization/wrap_mga_nDSM/#function-signature","title":"Function Signature","text":"<pre><code>[DV, dv, t0, tofs, MAT, output] = wrap_mga_nDSM(seq, x, struc_revs_man, customEphemerides, plotsol)\n</code></pre>"}]}